int i = 10;
std::cout << (i & 1 == 0);

0
1

Нормальный человек подумает, что 1. Но компьютер не человек, как и те, кто помнят наизусть приоритет операций. Эти машины ответят 0. Почему?

Потому что приоритет оператора сравнения больше приоритета битового И. Поэтому в начале сравнятся 1 и 0. Будет 0. А И с нулем будет всегда нуль. Минут 5-10 я потратил на выяснение этой ошибки при написании этого поста. Правильно печатает ответ так:
int i = 10;
std::cout << ((i & 1 )== 0);

И чтобы с вами(и со мной) больше такого не случалось, приведу здесь приоритеты операций в С++.

1. Постфиксный инкремент/декремент: `++`, `--`
2. Вызов функции: `()`
3. Индексный доступ: `[]`
4. Доступ к члену: `.`, `->`
5. Префиксный инкремент/декремент: `++`, `--`, унарный плюс (`+`), унарный минус (`-`), логическое отрицание (`!`), побитовое дополнение (`~`), разыменование (`*`), взятие адреса (`&`), приведение типа (`static_cast`, `dynamic_cast`, `reinterpret_cast`, `const_cast`), `sizeof`
6. Операторы умножения: `*`, `/`, `%`
7. Операторы сложения: `+`, `-`
8. Побитовые сдвиги: `<<`, `>>`
9. Операторы сравнения: `<`, `>`, `<=`, `>=`
10. Операторы равенства: `==`, `!=`
11. Побитовое И: `&`
12. Побитовое исключающее ИЛИ: `^`
13. Побитовое ИЛИ: `|`
14. Логическое И: `&&`
15. Логическое ИЛИ: `||`
16. Тернарный оператор: `? :`
17. Операторы присваивания: `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`, `&=`, `^=`, `|=`
18. Оператор запятой: `,`

Надеюсь, что больше нас всех эта тема не побеспокоит. Потому что я не раз на эти грабли наступал, но постоянно успевал забывать про это до следующего прокола. Думаю, что вы тоже.

Stay alert. Stay cool.