Этим постом мы начинаем серию рассказов про метрики, которые позволяют нам численно или качественно оценить определенные характеристика дизайна нашего приложения. Когда программным обеспечением в потенциале будут пользоваться миллионы людей, очень важно иметь какие-то объективные критерии, которые помогут выявить проблемы с архитектурой еще на этапе проектирования. Чем дольше проблема остается в коде, тем дороже будет стоить ее решение. А ошибки в дизайне - самые дорогостоящие из всех.

Сегодня мы препарируем цикломатическую сложность. Название уже страшное. Но постараюсь объяснить на пальцах.

Цикломатическую сложность - топологическая сложность программы. То есть берется в расчет именно структура кода, а не сложность его вычисления. Время выполнения конкретной строчки тут не играет роль. Здесь мы оперируем потоками управления программы. 

Представьте себе функцию, как лабиринт. У лабиринта есть вход и выход, а также запутанные ходы. На всех перекрестках стоят указатели с условиями прохода в ту или иную сторону. И действие по выбору прохода определяется набором входных параметров функции. Человек, который проходит лабиринт, оставляет после себя след. Лабиринт очень узкий, поэтому при повторном прохождении какого-то участка, следы накладываются друг на друга. Так вот, все то многообразие уникальных путей в лабиринте, которые может начертит своими следами человек, и будет теми самыми потоками управления программы. А их количество - цикломатической сложностью.

Если представить это более формально, то каждая функция - граф. Узлы этого графа - неделимый набор команд, которые выполняются одна за другой при любом стечении обстоятельств. А ребра этого графа - переходы между такими группами команд. Например, при ветвлении стандартным if-else появляются два новых узла и 4 новых ребра. Сложно тут как-то символами это нарисовать, но вот у вас есть узел(какой-то набор инструкций перед ветвлением), дальше ветвление порождает две ниточки от этого узла, которые заканчиваются узлами. Один узел для ветки if, другой узел - для ветки else. После условной конструкции идет тоже общий код - еще один узел. Поэтому нам нужно связать узел, который после if-else, с узлами для разных веток. Получили еще 2 ребра. Как-то так. Ребра, естественно, ориентированы от начального узла к конечному. То есть получается вот такой ориентированный граф. И количество его линейно-независимых маршрутов(what the hell is that??) является цикломатической сложностью. Как я понял, линейно-независимые маршруты - такие маршруты, которые не учитывают повторное прохождение цикла.

Есть даже формула, для подсчета этого числа, но там используется понятие компоненты связности, а оно довольно сложное для объяснения и скорее всего не нужно для понимания сути. Там еще и разные формулы в зависимости от этих компонент связности. Так что опустим это. Понимание маршрутов графа необходимо и достаточно, чтобы посчитать цикломатическую сложность самостоятельно. 

Как это вообще применять к дизайну программы и о чем это число может говорить нам?

Вопрос хороший и ответ на него довольно простой. Чем больше потоков управления в вашем коде - чем он сложнее, а значит хуже. Такой код сложнее понимать, держать в голове и тестировать. Создатель этой метрики рекомендует считать свою метрику для каждого модуля и, при достижении значения метрики 10, делить модуль на более мелкие части. Так будет намного проще читать и понимать код. Это не просто рандомное число, оно вычислено на основе большого количества критически важных программ и было занесено в методику структурного тестирования Национальным Институтом Стандартов и Технологий США.

А насчет тестирования. Маршруты графа - очень хорошая база для тестов. Количество тестов для данной функциональности должно быть как минимум равно цикломатической сложности. В идеале мы должны покрыть все пути тестами. Тогда вероятность попадания в краевой случай будет минимальна.

Stay well-designed. Stay cool.

