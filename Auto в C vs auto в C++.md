С и С++ имеют большое сродство друг с другом. Много вещей из С по наследству достались С++. В том числе и ключевые слова. И хотя большинство из них сохранили свою семантику в новом языке, сегодня мы поговорим об одном контрпримере. Ключевом слове auto.

Разберемся для начала, что оно значит в языке С. auto - один из storage-class specifiers, наряду с register, static и extern. Эти спецификаторы, которыми маркируются переменные и функции, определяют время жизни сущности и вид ее связывания. auto и register к тому же применимы только для переменных. Чтобы было понимание, приведу пример. static говорит, что переменная имеет статическое время жизни и внутреннее связывание. А auto говорит, что переменная имеет автоматическое время жизни и для отсутствует связывание. Первая часть предложения значит, что переменная аллоцируется на стеке и удаляется при выходе из скоупа. Вторая часть что переменная должна быть видна только в своем скоупе и никому другому она не нужна. Кого-то мне это напоминает....

Если 3.35 секунды подумать над этими вещами, то становится понятно, что все локальные переменные функции неявно помечаются как auto. То есть в этом ключевом слове нету особого смысла и никто им вообще не пользуется.

В таком виде оно перекочевало и в С++. Но разработчики 11-го стандарта подумали и решили поэксплуатировать бессмысленность и никомуненужность этого keyword. Так как им никто не пользуется, можно без опасений дать ему новое значение и не бояться гнева разъяренных разработчиков, пострадавших от отсутствия обратной совместимости. 

В С++ начиная с 11-го стандарта auto используется как указание компилятору, что мы не хотим сами указывать тип помеченного объекта и ему нужно его вывести самостоятельно. Эта фича позволила больше не запоминать, как из мапы получить тип ее итератора, и не писать эти простыни названий шаблонных типов. Можно теперь сказать auto и все для вас уже готово. Там не все так гладко с выводом типов, auto работает скорее по принципе выведения типов в шаблонах, и этот тип иногда отличается от того, что мы ожидаем. С вас 2 лайка и я расписываю эту тему подробнее(угадайте сколько на канале админов и ставят ли они лайки на посты).

Вот такие вот различия. Хотя в новом стандарте C23 auto теперь тоже может использоваться для вывода типов. Это не отменяет его роли в виде storage-class спецификатора, но вводит новый смысл в его использование.

Круто видеть, как два довольно древних языка развиваются и исправляют свои недочеты.

Fix your flaws. Stay cool.