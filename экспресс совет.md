Меня всегда бесило, что когда мне нужно беззнаковое 32-битное число, мне приходится писать это длинное unsigned. А если нужно большое беззнаковое - то вообще unsigned long long. Фу прям.
Да, size_t тоже представляет собой беззнаковое 64-битное число. Но я большой фанат семантики типов, а size_t обозначает размер чего-то. А не всегда числа представляют собой размер.

Но есть выход! Подключаете "stdint.h" и кайфуете с человеческим представлением типов
int8_t
uint8_t
int16_t
uint16_t
int32_t
uint32_t
int64_t
uint64_t
и еще несколько менее важных(потом обсудим)

Насколько же они прекрасны! И короткие, и сразу понятно, какого размера переменная. И не надо голову морочить: а вот сколько там на этой железяке бит в инте?? В самом типе есть ответ.

Почти всегда пользуюсь этими обозначениями и очень доволен процессом.
Особенно они незаменимы в каком-нибудь библиотечном коде с математическими функциями, когда много перегрузок под каждый тип.

В общем, кто пользуется - меня поддержит, кто еще нет - берите на заметку.

Stay laconic. Stay cool.