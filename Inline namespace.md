Насмотревшись на посты за последние недели, можно выяснить 2 вещи. Ключевое слово inline используется либо как подсказка компилятору для встраивания кода функции в место ее вызова, либо как средство обхода ODR. Применять его можно и к функциям, и к переменным(с с++17). Но есть еще одно интересное применение inline. Им мы можем пометить пространство имен. Я бы сказал, что судя по названию и уже усвоенной инфе, мы можем понять, что это значит. Но нет. Нихрена не понятно. Поэтому будем разбираться.

Контекст и использование встроенных неймспейсов совсем простой. Все, что объявлено внутри такого пространства имен, считается также членом внешнего неймспейса, которое содержит в себе даный inline namespace. То есть
```cpp
namespace trah {
	inline namespace tibedoh {
		template<typename T> class tibedoh{ /* ... */ };
	}
	template<typename T> void tenberg(T) { /* ... */ }
}
```


есть у нас вот такая иерархия. Неймспейс трах. У него есть шаблонная функция тенберг. И в него вложен встроеный неймспейс тибедох. В этом внутреннем неймспейсе шаблонный класс тибедох. И прикол в том, что вместо trah::tibedoh::tibedoh я могу написать просто trah::tibedoh и использовать вложенный класс наряду с функцией trah::tenberg.

То есть в общем и целом, этот механизм позволяющий автору кода сделать так, чтобы все объявления во вложенном неймспейсе выглядели и действовали, как объявления внешнего неймспейса. Более того, если есть несколько вложенных встроенных неймспейсов, то все объявления всех вложенных неймспейсов доступны в первом невстроенном пространстве имен. 

Для чего это нужно? По сути эта фича призвана решить одну единственную проблему - версионирование библиотеки. Глянем на прошлый пример. Библиотека trah активно развивается и, начиная с какой-то версии, в тей появился класс tibedoh, которого не было в предыдущей версии библиотеки. До появления с++11 это выглядело бы примерно так:
```cpp
namespace trah {
#  if __version == new
    using namespace tibedoh;
#  endif
	 namespace tibedoh {
		template<typename T> class tibedoh{ /* ... */ };
	}
	template<typename T> void tenberg(T) { /* ... */ }
}
```
В этом случае нам недоступен класс tibedoh, если мы не используем новую версию либы. А если используем, то using помогает нам не писать оператор разрешения имен и пользоваться классом tibedoh, как если бы он был членом неймспейса trah. То есть вот так trah::tibedoh. Вроде все круто и нет проблем. Но не все так просто.

Мне, как пользователю библиотеки, не желательно что-то объявлять в пространстве имен trah, по аналогии с std. Однако мне разрешается делать полную специализацию для шаблонов непосредственно в trah без последствий. Я, как автор своих классов, лучше знаю, как ими нужно оперировать, чтобы достичь максимального перфоманса. Зная API библиотеки, я думаю, что класс tibedoh объявлен в trah. Окей, пишу:
``` cpp
namespace trah {
	template <>
    class tibedoh<AbraKadabra> {
        // ...
    };

}
```
Но вот проблема. Мне позволяется полностью специализировать шаблоны именно в том пространстве имен, в котором шаблон объявлен. А на самом деле он объявлен во вложенном неймспейсе. Предыдущий пример мог бы сработать для неверсионированной либы, но в нашем случае будет просто ошибка компиляции.

Это не единственный пример, когда вложенное пространство имен становится видным пользовательскому коду. Например, ADL(кто знает, тот знает, раскрытие adl не влезет в этом пост) не следует директиве using и при поиске символа из вложенного неймспейса во внешнем ADL будет очень стараться, но так и не найдет нужный символ, который на самом деле спрятан во вложенном namespace.

Есть еще парочку примеров, но они излишни. inline namespace решает все эти проблемы и делает версионирование библиотек намного более простым занятием.

Make things simplier. Stay cool.

#cpp11 #cppcore
