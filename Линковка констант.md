Сегодня начнем затрагивать вопрос линковки константных переменных и тонкости этого процесса. Давайте предположим, что у нас есть некоторый набор констант. Пусть это будут тривиальные физические константы, типа скорости света, числа авагадро и тд. И мы хотим использовать эти константы в разных единицах трансляции. Очевидный вариант - вынести их в какой-нибудь хэдер и подключать его всякий раз при необходимости. Получаем что-то типа такого:

```
// constants.hpp
#pragma once

namespace constants 
{ 
constexpr unsigned light_speed { 299 792 458 }; 
constexpr double avogadro { 6.0221413e23 }; 
// ... other related constants }
```

Используем здесь constexpr для использования этих констант в compile-time вычислениях. 

Почему это вообще работает? Мы ведь здесь подключаем одно и то же определение в разные юниты трансляции. ODR должно нам запретить такое делать.

Дело в том, что все константы имеют по умолчанию внутреннее связывание. То же самое и для констэкспр. Внутреннее связывание гарантирует, что в каждом юните трансляции будет использоваться своя копия этих переменных и ни из какого другого юнита нельзя будет получить доступ к ним. То есть определение этих констант везде будет свое. И ODR не будет нарушаться. 

Если пометить константы как static, то ничего толком не изменится, потому что они и так неявно статические. То есть с внутренним связыванием.

У такого подхода есть проблемы.

Каждый раз, когда мы включаем заголовочный файл с константами в файл с кодом, каждая из этих переменных копируется в файл с кодом. Поэтому, если constants.hpp включается в 20 различных файлов кода, каждая из этих переменных дублируется 20 раз. Из этого следует следующее: 

1. Изменение одной константы потребует перекомпиляции каждого файла, использующего константы(даже если измененная константа там не используется!), что делает компиляцию долгой для крупных проектов. 
2. Если константы имеют большой размер и не могут быть оптимизированы, это приведёт к нежелательному расходу памяти.

Какое здесь решение? Подождать следующего поста, там будут объяснения)

Solve the problems. Stay cool.

#cppcore #compiler 


Линковка констант Ч2

Мы узнали один из вариантов, как можно подключать константы в свои файлы с кодом. Однако у него были проблемы, которые мы попытаемся решить сегодня.

Все проблемы прошлого варианта по сути сводится к последствиям внутренней линковки.

Если у нас будет только одно определение переменной и весь остальной код будет только ссылаться на него, то решится проблема с перекомпиляцией. Потому что задача подстановки символов будет решаться при линковке. Во всех единицах трансляции будет просто заглушка для этой константы. И реальное значение будет подставляться компановщиком. А значит ничего не нужно заново компилировать.

Одно определение также решит вопрос нежелательного расхода памяти, так как экземпляр константы будет один и занимать одну условную единицу памяти. Никакого дублирования не будет.

Как мы можем добиться, чтобы определение констант было всего одно?

Обеспечить им внешнее связывание. С помощью ключевого слова extern.

```
//constant.cpp
#include "constant.hpp"

namespace constants 
{ 
extern const unsigned light_speed { 299 792 458 }; 
extern const double avogadro { 6.0221413e23 }; 
// ... other related constants }
```

```
//constant.hpp
#pragma once

namespace constants 
{ 
extern const unsigned light_speed { 299 792 458 }; 
extern const double avogadro { 6.0221413e23 }; 
// ... other related constants }
```

Теперь константы будут создаваться только один раз (в constants.cpp), а не каждый раз при включении constants.h, и все использования будут просто ссылаться на версию в constants.cpp. Любые внесенные изменения в constants.cpp потребуют только перекомпиляции constants.cpp.  
Однако и у этого метода есть несколько недостатков(да штож такое). 

Во-первых, эти константы теперь могут считаться константами времени компиляции только в файле, в котором они фактически определены (constants.cpp), а не где-либо еще. Это означает, что вне constants.cpp они не могут быть использованы нигде, где требуются вычисления в compile-time. Печально.

Во-вторых, в принципе оптимизировать их использование компилятору сложнее, потому что он не имеет доступа к настоящему значению.

В-третьих, неудобно просто. Каждый раз нужно ходить в реализацию, чтобы удостовериться в значении константы - такое себе. Да, современные IDE могут решить этот вопрос. А могут и не решить. Плюс нужно или мышку наводить или кнопки какие-то нажимать. Слишком много действий!
Шучу конечно. Но намного удобнее определение держать в хэдере.

Учитывая вышеперечисленные недостатки, хочется определять константы в заголовочном файле. Наконец-то мы подбираемся к самой мякотке. Но об этом - в следующих постах)

Stay in touch. Stay cool.

#cppcore #compiler 

Inline переменные

Так, ну это уже перебор. inline для функций окей, можем встроить ее код в место вызова. Но что значит встроенная переменная? Мы же в месте, где используется переменная просто ссылаемся на оригинал переменной через указатель(адресом переменной для динамических объектов или отступом от регистра для локальных). Переменная - это же память. Не понятно, что значит встроить память в код. Это в принципе не имеет смысла. Разве что можно встроить какие-нибудь чиселки в непосредственное место их использования как один из операндов. Но компилятор уже это и так делает, без наших просьб. В чем тогда смысл?

Мы уже поговорили о том, что смысл ключевого слова inline для функций в современных реалиях С++ - это уже совсем не про inline expansion, а про обеспечение обхода ODR. Это позволяет определять функцию прямо в хэдере. При этом линкер не обидится на нас и даже прогарантирует, что объединит все определения в одно и тогда в места вызова функции будет даже один и тот же адрес подставляться. 

И вот именно эту семантику и перенимают переменные в С++17, которые теперь могут быть помечены ключевым словом inline. Какие конкретно преимущества теперь получают переменные?

Теперь мы прямо в заголовочнике можем определить значение для переменной, например, константы. Компоновщик просто потом объединит все определения в одно. То есть будет всего один оригинал переменной и гарантируется, что она будет создана только один раз и совместно будет использоваться во всех файлах с кодом.

Что это нам дает? 

Внешнее связывание inline дает нам преимущества компактности размера скомпилированного кода.

Компилятор может оптимизировать переменные как он хочет, потому что видит определение на момент компиляции.

По той же причине, все compile-time вычисления имеют место быть.

Нет перекомпиляции за неиспользованные переменные.

Определение находится в хэдере и это удобно смотреть.

Все проблемы решены!! Магия вне Хогвартса!

Фух. Теперь у нас с вами есть база понимания, что такое инлайн, какие у него смыслы, где его применять и какие из этого следуют плюшки. Это была довольно базированная серия постов, начали с оптимизаций, а пришли в компоновке. И все было рассказано на хорошем уровне. Даже я сам понял, как говорится. Надеюсь, вам тоже понравилось)

Stay satisfied. Stay cool.

#cppcore #compiler #cpp17

Нормальное определение статических полей класса

Здесь мы посмотрели на проблему, которая стоит перед нами, когда мы пытаемся определить статическое поле класса. А проблема такова, что статические поля класса имеют ВНЕШНЕЕ связывание. За объяснением этого утверждения можете перейти по ссылке на тот пост, а мы продолжим. 

Мы никак не можем обойти это ограничение вплоть до С++17. ODR требует, чтобы мы определяли статические поля вне класса и хэдера. Можно было бы поставить квалификатор const, но это уже другой разговор. Это не всегда нужно. Совершенно не подходит для случая, когда нам нужно изменять наш объект. Да и статические константные поля можно инициализировать внутри класса только если это тривиальные типы. 

Но! В C++17 завезли нам прекрасную фичу - inline переменные. Мы теперь можем определять символы с внешним связыванием во множестве единиц трансляции! И это как раз то, что нам нужно!

Мы просто берем и в хэдере определяем статическое поле, помечаем его inline и все готово. Никто на нас не ругается и все работает, как часы. Можем теперь как белые люди все писать в хэдерах. Это намного более удобно и не требует больших затрат. 8 дополнительных символов и Доби свободен!

Берите на заметку. Это прикольное и, главное, реально полезное приложение inline, которым вы будете довольно часто пользоваться.

Be free. Stay cool.
