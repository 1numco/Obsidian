
Попробуем новую рубрику на канале - #quiz. Мы задаем вопрос - а вы выбираете один из предоставленных ответов. Все обсуждения в комментах. А вечером выходит пост с подробными объяснениями. Погнали!

Допустим, я хочу сдвинуть 4-х байтное знаковое число на 31 бит вправо и вывести значение получившегося числа.

```cpp
int result = number >> 31;
std::cout << result << std::endl;
```

Для определенности предположим, что number = -12.

Знаю, знаю. Я не совсем больной ублюдок, чтобы заставлять вас отрицательные числа в бинарный формат хранения переводить. 

Считайте, что -12 представляется в памяти, как 1111 1111 1111 1111 1111 1111 1111 0100. Почти наверняка так и будет.

Что выведется в консоль в этом случае?

1
0
-1
2^32 - 1
Nobody knows....
"Hello, World!!!"

Ответ на вопрос выше не так уж и прост на самом деле. Начнем с того, что когда вы запустите этот код на своей машине, то получите ответ: -1.

Эм. Неожиданно! "Как так получается?" - спросите вы меня. "Ведь я же знаю, как работает бинарный сдвиг: берем да и сдвигаем биты вправо и позади оставляем нули. В итоге получатся все нолики и самый младший бит 1. А это 1, а не -1!".

Логика железная и с ней не поспоришь. Однако в этой цепочке есть одно неверное утверждение. Вы не знаете, как работает правый бинарный сдвиг! 

Заинтригованы?

Тогда мы идем к вам!

Рассуждения верные только для беззнаковых чисел. Для знаковых все определяется конкретной реализацией. А у нас как раз такой вариант. Так что правильный ответ: Nobody knows...

Почему я тогда утверждаю, что вы на своих машинах получите -1?

Потому что в большинстве реализаций правый битовый сдвиг для знаковых чисел работает с помощью так называемого "арифметического сдвига". Что это за акула такая.

Когда вы делаете правый сдвиг для беззнаковых чисел, то просто старшие разряды заполняете нулями. Арифметический же сдвиг заполняет старшие разряды не нулями, а знаковым битом. Таким образом, правый сдвиг любого 4-х байтного знакового числа оставит после себя либо 32 бита нулей (в случае положительного числа), либо 32 бита единичек(в случае отрицательного числа). А все единички в битах - это -1 для знаковых чисел.

Вот такой прикол. Надеюсь, что я многих удивил тем, как это работает)

Stay surprised. Stay cool.

![[Pasted image 20240313220544.png]]


Способы узнать знак целого числа

Иногда появляется необходимость узнать, является ли данное число отрицательным или нет. За примером далеко ходить не будем. В последней нашей задачке про переворачивание десятичных цифр числа один из подходов к решению таким: узнать, является ли число отрицательным, если да, то домножить его на -1 и оперировать им как положительным числом. После всех действий и проверок домножить число обратно на -1. 

И вот мне стало интересно. Сколько способов есть, чтобы узнать является ли число отрицательным? Давайте же узнаем!

1.Как в прошлом посте сдвинуть число вправо на 31/63 бита и привести все к инту. Если получился 0 - число положительное. Если 1 - отрицательное.

2.bool is_signed = number < 0; Один из самых очевидных и прямолинейных подходов. Просто проверяем число оператором меньше и все на этом. Скучно, попсово, но зато понятно и эффективно.

3.Использовать битовую маску. bool is_signed = number & 0x80000000; Здесь мы оставляем только знаковый бит на его месте. Затем приводим число к булевому значению. Положительное число превратится в нолик, а значит в true, а отрицательное - в false.

4.std::signbit(number);. Эта шаблонная функция вернет вам true, если number - отрицательное, и false в обратном случае. На мой взгляд, это больше по плюсовому и функция имеет человеческое название, поэтому читаться такой код будет намного проще, чем в предыдущих случаях.

На этом я застопорился. Никак больше не могу придумать других способов, которые бы не включали в себя предыдущие. Тут скорее мне интересно, какие вы варианты придумаете. Обязательно отпишитесь к комментах!

Generate a dozen of different solutions. Stay cool.

#fun #cppcore


std::signbit

В прошлом мы уже упоминали std::signbit в этом посте. Сегодня мы посмотрим на эту сущность по-подробнее.

По сути, это самый понятный и плюсовый чтоли способ узнать знаковый бит числа, который появился в нашем арсенале с приходом С++11. Причем не только целого, но и числа с плавающей точкой.

```cpp
bool signbit( float num );  
bool signbit( double num );  
bool signbit( long double num );
```

вот такие перегрузки мы имеем для floating-point чисел. А вот такую:

```cpp
template< class Integer >  
bool signbit( Integer num );
```

для целых. Последняя перегрузка является дополнительной. Это значит, что в имплементации стандартной библиотеки она не обязана выглядеть прям в точности так. Единственное требование - перегрузки должны быть достаточными, чтобы определить попадание интегрального типа в функцию.

В чем особенность целочисленной перегрузки. В том, что число, которое туда попадает трактуется, как double. Поэтому выражение std::signbit(num) эквивалентно std::signbit(static_cast<double>(num)).

Также эта функция детектирует наличие знакового бита у нулей, бесконечностей и NaN'ов. Да, да. У нуля есть знак. Так что 0.0 и -0.0 - не одно и то же.

Начиная с 23 стандарта функция становится constexpr, что не может не радовать любителей compile-time вычислений.

Для языка С тоже кстати есть похожая сущность. Только там это макрос

```c
#define signbit( arg ) /* implementation defined */
```

И для него гарантируется такое поведение: для положительных чисел возвращаем ноль, а для отрицательных - ненулевое целое число.

Мне прям эта функция очень нравится, поэтому всегда ее использую. Может быть и вам теперь понравится)

Look for signs in life. Stay cool.

#cpp23 #cpp11 #goodoldc

![[Pasted image 20240314110918.png]]