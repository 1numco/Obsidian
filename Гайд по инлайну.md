Всем доброго времени суток, дорогие читатели! Представляю вам гайд по inline сущностям! Сразу оговорю, что эта тема для более менее продвинутых программистов. Самые начинающие практически не увидят для себя пользы. Но уже начиная с джуновского уровня, такие вещи нужно знать и понимать, чтобы писать оптимальные и приятные глазу программы! Да, да. Здесь пойдет речь как про оптимизации и перформанс, так и про организацию кода и хорошие практики его написания. Настолько многообразна тема inline. Приятного чтения!

Начнем с базы. А именно, поймем для начала ориджин термина inline, который изначально имел отношение к функциям.

Самый оптимальный с точки зрения производительности код - это сплошной набор вычислительных инструкций от начала и до конца. Это может быть и быстро, но никто так не пишет код. Любую целостную функциональность пришлось бы заново писать самостоятельно или копировать. Это все увеличивает время разработки(которое иногда важнее времени выполнения кода) и количество ошибок на единицу объема кода. Это естественно всех не устраивало. 

Но в любой программе отчетливо просматривается группировка команд по смыслу. То есть определенная группа команд отвечает за выполнение какого-то комплексного действия. Это можно представить в виде графа, где вершины - эти группы, а ребра - переходы между ними. И оказалось очень удобным ввести сущность, отражающую во эту общность набора команд. Такая сущность называется функцией. 
Окей. Ввели мы функции, как отдельные независимые куски кода, с помощью которых выполняется какое-то комплексное действие. Теперь их как-то надо вызывать. То есть как-то передавать туда параметры и как-то получать оттуда возвращаемое значение.Так появился стек вызовов, calling conventions и так далее.

Что здесь важно знать. Чтобы выполнить функцию нужно сделать довольно много дополнительных действий. Положить значение base pointer'а на стек, через него же или через регистры передать аргументы, прыгнуть по адресу функции, сохранить возвращаемое значение функции, восстановить base pointer и прыгнуть обратно в вызывающий код. Может что-то забыл, но не суть. Суть в том, что дополнительные действия - дополнительные временные затраты на выполнение. Такой trade-off между перфомансом и удобством.

Для человека может быть очень удобно определить функцию сложения двух чисел. Семантически это действительно отдельная операция, которую удобно вынести в отдельную функцию и всегда ей пользоваться. Но с точки зрения машинного кода, затраты на вызов функции вносят значительный вклад в вычисление нужного значения. А вообще-то нам бы хотелось и рыбку съесть и на..., то есть перфоманс не потерять. И такой способ существует!

Называется инлайнинг. Для не очень сложных функций компилятор может просто взять и вставить код из функции в вызывающий код. Таким образом мы получаем преимущества организации кода по функциям и не просаживаем производительность. И еще дополнительно компилятор может сделать и другие оптимизации, которые невозможны были бы при вызове функции.

Для этих целей когда-то давно было придумано ключевое слово inline. Оно служило индикатором оптимизатору, что функцию, помеченную этим словом, нужно встроить. Эх, были времена, когда слово программиста имело вес...

Сейчас компилятор настолько преисполнился в своем познании, что может любую функцию сам встроить по своему хотению. А еще может просто проигнорировать вашу пометку inline и не встраивать функцию. Да и вообще, сейчас все методы, которые определены в объявлении класса неявно помечены как inline. С учетом наплевательского отношения компилятора к нашим пожеланиям, кажется, что вообще бессмысленно использовать ключевое слово inline для оптимизации кода. Единственное, что обязан сделать компилятор - проверить функцию на возможность встраивания. Но он и так это делает для всех остальных функций! При применении оптимизаций, конечно.

Кстати насчет этого. Здесь мы затрагиваем конкретно область оптимизаций компилятора и увеличения перформанса. Чтобы разрешить компилятору выполнять эти оптимизации, нужно перед компиляцией указать ему соответствующие параметры. Но о них мы поговорим позже, чтобы не сбивать ритм повествования.

Помимо бенефитов встраивания кода, у него есть и недостатки.

Из очевидного - увеличение размера бинаря. Код функции можно переиспользовать, а код заинлайненной функции будет располагаться в каждом ее вызове. Больше инструкций - больший размер бинаря.

Из неочевидного - встраивание функций может оказывать повышенное давление на кэш процессора. Например, если функция слишком большая, чтобы поместиться в L1, она может выполниться медленнее, чем при обычном выполнении function call. Для вызова функции CPU может заранее подгрузить ее инструкции и адрес возврата и выполнить ее быстрее. Или например, большое количество одного и того же встроенного кода может увеличить вероятность кэш-промаха и замедлить пайплайн процессора.

Все понятно. Есть плюсы и минусы у встраивания. Как и у любого явления. Но если компилятор теперь сам все проверяет и встраивает, какой вообще может быть смысл в использовании этого ключевого слова? Вооооооот. Это возможно самый главный и важный вопрос этого гайда. И ответ на него расскажет нам, для чего используется ключевое слово inline в современном программировании на С++.

Перед тем, как ответить на тот самый важный вопрос. Нам нужно сделать небольшое отступление. Но оно даст нам немного контекста, который будем использовать в будущем.

Определение функций

Допустим, что вам на работе задали задачку - реализовать функции перевода строки в ее hex представление и обратно. Назовем их BytesToHex и HexToBytes. Выглядеть они будут примерно так:

```cpp

std::string BytesToHex(const std::string& ordinary_string);

std::string HexToBytes(const std::string& hex_representation_string);
```

Нам нужно как-то их определить, чтобы ими можно было пользоваться и чтобы они не висели в кодовой базе такими болванками. Какие для этого у нас есть варианты?

1)Сделать отдельный хэдэр string_representation.hpp, в который мы поместим объявления функций. И отдельный файл исходного кода string_representation.cpp, в который мы и поместим определения этих функций. Ваще, обычно так и делают. Но вот что. Это НЕУДОБНО.

В 2 раза больше файлов становится. В 2 раза больше мест **повторения кода**. Это я про объявление и определение, в которых сигнатуры функций должны совпадать. Если захочешь изменить сигнатуру, то придется менять там и там. И полюбому в первый раз забудешь, компилятор тебя наругает, ты закатишь глаза и применишь изменения в хэдэре. Я уже не говорю про всякие CMakeLists. Сто процентов и туда забудешь добавить сорец в сборку. Да, это проблема на один раз. Но все же...

2)Определить функции просто в хэдэре. Проблема в том, что никто вам просто так не даст это сделать. Определив функции в хэдэре и включив этот хэдэр в несколько единиц трансляции, вы получите ситуацию, при которой у вас в одно и то же определение функции находится в нескольких единицах трансляции. Тем самым вы нарушаете ODR.

Маленькая справка по ODR. One Definition Rule. Правило одного определения. Оно говорит о том, что в C++ в пределах программы (или пределах единицы трансляции, если видимость определения находится только в рамках этой единицы) может быть только одно определение одной и той же сущности. В то же время объявления одной и той же сущности может многократно появляться в различных единицах трансляции. 

Это и понятно, так как реализация, например функции может быть только в одном экземпляре и находиться только в одной единице трансляции. Другие единицы трансляции будут использовать символ для связывания с этой сущностью. Во время линковки все единицы трансляции будут связаны в конечную программу используя эти символы (грубо говоря код будет сшит через эти символы в одно полотно, это и есть процесс линковки простым языком). Если реализация произойдет несколько раз в одной или нескольких единицах трансляции из-за многократного определения, то во время линковки произойдет ошибка многократного определения символа. Линковщик просто на просто не будет знать с каким из этих символов ему нужно слинковаться. И в самом деле, я могу в разных единицах трансляции определить две совершенно разные функции, но по невнимательности дать им одинаковое имя, было бы странно, если линковщик выбрал бы какое-то из них случайно и связал его.

Конец маленькой справке. Продолжаем разговор.

Определение функций в заголовочнике решило бы все проблемы из предыдущего пункта. Однако просто так нам это никто не даст сделать. Но все же пара выходов есть.

Можем пометить функции static или обернуть их в anonymous namespace. Оба способа изменяют тип линковки функций на внутреннюю. Это значит, что после включения этих функций в исходные файлы, у каждого из них будет своя внутренняя копия BytesToHex и HexToBytes. В каждой единице трансляции будет свой сгенерированный код для них и это приведет к увеличению объектного файла. Помимо этого есть еще негативные эффекты, о которых можете прочитать в посте про  [anonymous namespace](https://t.me/grokaemcpp/159). 

Так что нормальное, человеческое определение функций в хэдэрах если и существует, то где-то в другой вселенной. Или подождите....


Реальное предназначение inline

В чем прикол. Прикол в том, что для того, чтобы компилятор смог встроить функцию, ее определение ОБЯЗАНО быть видно в той единице трансляции, в которой она используется. Именно на этапе компиляции. Как можно встроить код, которого нет сейчас в доступе?

Почему это нельзя сделать на этапе линковки? Линкер резолвит проблему символов. Он сопоставляет имена с их содержимым. Линкер от слова link - связка. Для встраивания функции нужно иметь доступ к ее исходникам и информации вокруг вызова функции. Такого доступа у линкера нет. Да и задачи кодогенерации у него нет.

В современных реалиях два предыдущих абзаца несколько потеряли свою актуальность. Потому что появилась такая вещь как Link Time Code Generation или Link Time Optimization. Эта фича позволяет выполнять кодогенерацию во время линковки. Однако это compiler-specific оптимизация и не затрагивает стандарт. Фича появилась после стандартизации языка, когда уже было описано то, о чем я буду говорить ниже. Поэтому буду просто игнорировать существование LTCG и продолжу нашу сказку.

Что нужно, чтобы на этапе компиляции, компилятор видел определение функции? Ее можно определить в цппшнике, тогда все будет четко. Почти. Такую функцию нельзя переиспользовать. Она будет тупо скрыта от всех других единиц трансляции. Ее можно было бы переиспользовать. Тогда нужно было бы везде forward declaration вставлять, что очень неудобно. И она видна будет только во время линковки. Во время компиляции ни одна другая единица трансляции ее не увидит. Поэтому нам это не подходит. 

Тогда второй способ с потенциальной возможностью переиспользования: вынести определение в хэдер. Тогда всем единицам трансляции, которые подключают хэдер, будет доступно определение нашей функции. Но вот есть проблема - тогда во всех единицах трансляции будет определение нашей функции. А это нарушение ODR.

Как еще можно выйти из ситуации? Можно пометить функцию как static. Тогда в каждой единице трансляции будет своя копия функции. Это конечно решение проблемы и функцию будет видно во всех единицах трансляции на этапе компиляции. Но видно будет копии функции, а это ведет к дублированию кода и увеличению размера бинарника. Такое себе решение.

Но мы это все обсуждали.

Неужели больше никаких вариантов не остается? Что же делать?

Выходит, что у нас только одно решение. Создать свое правило! А именно, давайте разрешим inline функциям находиться в хэдерах и не нарушать ODR! Тогда нам нужны некоторые оговорки(ODR же придумывали не зря): мы разрешаем определению одной и той же inline функции быть в разных единицах трансляции, но тогда все эти определения должны быть идентичные. Потому что как бы предполагается, что они все определены в одном месте КОДА. Линкер потом объединяет все определения функции в одно(на самом деле выбирает одно из них, а другие откидывает). И вот у нас уже один экземпляр функции на всю программу. Получается, что, помечая функцию inline, мы будем обеспечивать ей внешнее связывание.

Конечно мы не можем такие сами взять да и добавить правило для обхода ODR. Но радость в том, что так в реальности и устроены inline функции и их обработка компилятором!

Что будет если мы случайно или специально добавим еще одно лишнее определение функции с такой же сигнатурой? Будет UB. Еще раз: если мы и нарушаем ODR, то надо это делать очень аккуратно. Линкер на самом деле не объединяет все определения функции в одно. Он просто выбирает рандомное из них и его оставляет в бинарнике. То есть, если мы добавим еще одно определение, то сами перед собой положим грабли зубьями наверх и черенком от нас. Линкер может выбрать любое понравившееся ему определение, а мы никак не можем повлиять на его вкус. Отсюда и неопределенное поведение.

И самое прекрасное вот что. Если мы помечаем функцию inline, то как бы рассчитываем, что компилятор ее встроит. И она будет обладать свойством, которое я описал выше. Причем будет обладать независимо от того встроится она по итогу или нет!

В общем, что мы имеем. Если раньше мы хотели поместить определение обычной функции в хэдэр, то боялись это делать, ибо знали, что нам настучит по башке линкер со своим multiple definition и мы уйдем грустные в закат. Но теперь у нас есть другой вид функций, которые как бы должны быть встроены, но никто этого не гарантирует, и которые можно определять в хэдерах. Такие функции могут быть встроены с той же вероятностью, что и все остальные, поэтому от этой части смысла никакого нет. Получается, что мы можем пометить нашу функцию inline и тогда ее просто можно будет определять в заголовочниках. Гениально!

Советую пару раз прочитать эту главу, чтобы хорошо все усвоить. Информация очень глубокая и фундаментальная, но скорее всего вы никогда не задумывались об этом.

Прочитали? Давайте немного практики.

Создадим 2 цппшника - source.cpp и main.cpp. Подключать они будут один и тот же хэдэр header.hpp.  В хэдэре я определю функцию VeryPopularFunction, которую предполагается часто будет использоваться во многих единицах трансляции. У нас их 2 и во всех будем ее использовать.

В файле source.cpp я определю другую функцию с обычным внешним связыванием - check_multiple_definition. И в ней я буду использовать нашу популярную функцию, подключенную из хэдэра.

В main.cpp я скомбинирую: вызову обе функции подряд. Таким образом определение инлайн функцииVeryPopularFunction находится во всех двух единицах трансляции.

Нагляднее посмотреть в код.
![[Pasted image 20240302173512.png]]

И при компиляции все пройдет хорошо и программа отработает, как и ожидалось.

Однако давайте кое-что изменим. Уберем inline из определения VeryPopularFunction и попробуем теперь скомпилировать программу. Получим что-то такое:
![[Pasted image 20240302184913.png]]

Вот мы и не прошли проверку на множественное определение.

Поэтому, если вы хотите определить свободную функцию в хэдэре, у вас есть 2 опции. 

1)Пометить функцию static или засунуть в anonymous namespace. Множественного определения не будет, но вылезут side effect'ы, о которых я говорил выше.

2)Пометить функцию inline и радоваться жизни!

Это и есть то, зачем inline используют в современных программах. Очень удобно определять функции в зоголовочниках, иметь один файл для любых изменений и иметь один итоговый экземпляр сгенерированного кода. Красота!


Теперь давайте еще одно отклонение от темы устроим. Поговорим немного про линковку констант. Казалось бы, причем здесь константы? Увидим дальше)

Давайте предположим, что у нас есть некоторый набор констант. Пусть это будут тривиальные физические константы, типа скорости света, числа авагадро и тд. И мы хотим использовать эти константы в разных единицах трансляции. Очевидный вариант - вынести их в какой-нибудь хэдер и подключать его всякий раз при необходимости. Получаем что-то типа такого:
```cpp
// constants.hpp
#pragma once

namespace constants 
{ 
constexpr unsigned light_speed { 299 792 458 }; 
constexpr double avogadro { 6.0221413e23 }; 
// ... other related constants 
}
```
Используем здесь constexpr для появления возможности использования этих констант в compile-time вычислениях.

Почему это вообще работает? Мы ведь здесь подключаем одно и то же определение в разные юниты трансляции. ODR должно нам запретить такое делать.

Дело в том, что все константы имеют по умолчанию внутреннее связывание. То же самое и для constexpr. Внутреннее связывание гарантирует, что в каждом юните трансляции будет использоваться своя копия этих переменных и ни из какого другого юнита нельзя будет получить доступ к ним. То есть определение этих констант везде будет свое. И ODR не будет нарушаться. Все как и с функциями

Если пометить константы как static, то ничего толком не изменится, потому что они и так неявно статические. То есть с внутренним связыванием.

У такого подхода есть проблемы.

Каждый раз, когда мы включаем заголовочный файл с константами в файл с кодом, каждая из этих переменных копируется в файл с кодом. Поэтому, если constants.hpp включается в 20 различных файлов кода, каждая из этих переменных дублируется 20 раз. Из этого следует следующее:

1️⃣ Изменение одной константы потребует перекомпиляции каждого файла, использующего константы(даже если измененная константа там не используется!), что делает компиляцию долгой для крупных проектов.

2️⃣ Если константы имеют большой размер и не могут быть оптимизированы, это приведёт к нежелательному расходу памяти.

Все эти проблемы  по сути сводятся к последствиям внутренней линковки.

Если у нас будет только одно определение переменной и весь остальной код будет только ссылаться на него, то решится проблема с перекомпиляцией. Потому что задача подстановки символов будет решаться при линковке. Во всех единицах трансляции будет просто заглушка для этой константы. И реальное значение будет подставляться компановщиком. А значит ничего не нужно заново компилировать.

Одно определение также решит вопрос нежелательного расхода памяти, так как экземпляр константы будет один и занимать одну условную единицу памяти. Никакого дублирования не будет.

Как мы можем добиться, чтобы определение констант было всего одно?

Обеспечить им внешнее связывание. С помощью ключевого слова extern.

```cpp
//constant.cpp
#include "constant.hpp"

namespace constants 
{ 
const unsigned light_speed { 299'792'458 }; 
const double avogadro { 6.0221413e23 }; 
// ... other related constants 
}
```

```cpp

//constant.hpp
#pragma once

namespace constants 
{ 
extern const unsigned light_speed;
extern const double avogadro; 
// ... other related constants 
}
```


Теперь константы будут создаваться только один раз (в единице трансляции соотвествующей constants.cpp), а не каждый раз при включении constants.h, и все использования будут просто ссылаться на версию в constants.cpp. Любые внесенные изменения в constants.cpp потребуют только перекомпиляции constants.cpp.  

Однако и у этого метода есть несколько недостатков(да штож такое).

1️⃣ Эти константы теперь могут считаться константами времени компиляции только в файле, в котором они фактически определены (constants.cpp), а не где-либо еще. Это означает, что вне constants.cpp они не могут быть использованы нигде, где требуются вычисления в compile-time. Печально.

2️⃣ В принципе оптимизировать их использование компилятору сложнее, потому что он не имеет доступа к настоящему значению.

3️⃣ Неудобно просто. Каждый раз нужно ходить в реализацию, чтобы удостовериться в значении константы - такое себе. Да, современные IDE могут решить этот вопрос. А могут и не решить. Плюс нужно или мышку наводить или кнопки какие-то нажимать. Слишком много действий!
Шучу конечно. Но намного удобнее определение держать в хэдере.

Учитывая вышеперечисленные недостатки, хочется определять константы в заголовочном файле.

И вообще. Вы чувствуете аналогии между проблемами определения функций и переменных? Может быть эти проблемы и решаются одинакого....

inline переменные

Так, ну это уже перебор. inline для функций окей, можем встроить ее код в место вызова. Но что значит встроенная переменная? Мы же в месте, где используется переменная просто ссылаемся на оригинал переменной через указатель(адресом переменной для динамических объектов или отступом от регистра для локальных). Переменная - это же память. Не понятно, что значит встроить память в код. Это в принципе не имеет смысла. Разве что можно встроить какие-нибудь чиселки в непосредственное место их использования как один из операндов. Но компилятор уже это и так делает, без наших просьб. В чем тогда смысл?

Мы уже поговорили о том, что смысл ключевого слова inline для функций в современных реалиях С++ - это уже совсем не про inline expansion, а про обеспечение обхода ODR. Это позволяет определять функцию прямо в хэдере. При этом линкер не обидится на нас и даже прогарантирует, что объединит все определения в одно и тогда в места вызова функции будет даже один и тот же адрес подставляться.

И вот именно эту семантику и перенимают переменные в С++17, которые теперь могут быть помечены ключевым словом inline. Какие конкретно преимущества теперь получают переменные?

Теперь мы прямо в заголовочнике можем определить значение для переменной, например, константы. Компоновщик просто потом объединит все определения в одно. То есть будет всего один оригинал переменной и гарантируется, что она будет создана только один раз и совместно будет использоваться во всех файлах с кодом.

Что это нам дает?

1️⃣ Внешнее связывание inline дает нам преимущества компактности размера скомпилированного кода.

2️⃣ Компилятор может оптимизировать переменные как он хочет, потому что видит определение на момент компиляции.

3️⃣ По той же причине, все compile-time вычисления имеют место быть.

4️⃣ Нет перекомпиляции за неиспользованные переменные.

5️⃣ Определение находится в хэдере и это удобно смотреть.

Все проблемы отсюда с линковкой констант решены!! Магия вне Хогвартса!

С новыми знаниями вот так нужно определять константы в хэдерах.

```cpp
// constants.hpp
#pragma once

namespace constants 
{ 
	inline constexpr unsigned light_speed { 299 792 458 }; 
	inline constexpr double avogadro { 6.0221413e23 }; 
// ... other related constants 
}
```


Теперь сделаем еще одно отступление(в последний раз, клянусь)

Определение статических полей класса

Если вы хоть раз пытались наивно инициализировать статический член класса внутри самого класса, то явно знаете, о чем речь пойдет. А для тех, кто не знает, скажу, что произойдет дальше. Компилятор выдаст ошибку типа: ISO C++ forbids in-class initialization of non-const static member. Стандарт запрещает неконстантным статическим полям инициализироваться внутри класса. Ранее стандартной практикой для решения этой проблемы был вынос определения этого поля в цпп файл. Типа такого:
![[Pasted image 20240302223732.png]]

Решение довольно неудобное, ибо каждый раз нужно лезть в файл реализации, чтобы посмотреть инициализатор. Да и писать это не очень удобно. В потенциале для такой инициализации нужно дополнительно написать в 1.5 раза больше букав, чем при удобной in-class инициализации. Если это так неудобно, то почему такое правило вообще введено?

Давайте небольшой рекап для статических членов. Статическое поле класса - по сути глобальный объект, который как бы присоединен к классу. Любой объект класса может получить доступ к одному и тому же инстансу статической переменной. Как и любой код, который может создать объект класса, сможет использовать его статический член через имя класса. Типа такого ClassType::static_field. То есть, несмотря на то, что поле объявлено как static, оно имеет внешнее связывание. То есть существует лишь один инстанс этого поля, который виден всему коду, имеющему доступ к классу. И для такой сущности применяется One Definition Rule(ODR), которое говорит, что у переменной или функции(за некоторыми исключениями) внутри ВСЕЙ программы может быть сколько угодно объявлений, но только одно определение. Ща поясню, к чему это приводит.

Вот у вас есть описание класса в каком-то хэдере. Как использовать этот класс? Заинклюдить этот хэдер в нужный файлик. А что делает иклюд? Правильно, на этапе препроцессора он просто заменяется на текст подключаемого файла. Поэтому если у вас определение статического поля находится в хэдере, значит у вас есть определение этого поля во всех единицах трансляции, куда попало описание класса. А это прямое нарушение ODR.

Описания классов обычно находятся в хэдэрах, поэтому проще просто запретить определять статические поля внутри классов.

Как меняет ситуацию определение поля вне класса в цпп файле? Это позволяет не нарушать ODR, все просто) Ну если чуть подробнее, то во всех единицах трансляции, куда мы подключили описание класса, будет только объявление нашего поля. И только одно определение будет браться из нашего цпп файлика.

Но подождите...

Мы же теперь знаем еще один способ определить переменную в хэдэре и не нарушать ODR.

Нормальное определение статических полей класса

Мы просто берем и в хэдере определяем статическое поле, помечаем его inline и все готово. Никто на нас не ругается и все работает, как часы. Можем теперь как белые люди все писать в хэдерах. Это намного более удобно и не требует больших затрат. 8 дополнительных символов и Доби свободен!

Берите на заметку. Это прикольное и, главное, реально полезное приложение inline, которым вы будете довольно часто пользоваться.


![[Pasted image 20240302220223.png]]

Все, что написано выше этой строчки - база про inline. От этого уже будем отталкиваться и перейдем к разбору интересных кейсов и комбинаций inline с другими ключевыми словами.

static inline

Мы с вами уже немного знаем про эти две вещи в отдельности. Но что будет, если соединить эти два ключевых слова? Как изменится поведение сущностей в таком случае?

И как это обычно бывает, все разделяется на кучу вариантов использования: в хэдере или в цппшнике, для переменной или функции, для поля класса или метода. 

Рассмотрим static inline свободные функции. inline говорит компилятору, что эту функцию неплохо бы встроить, и это дает ей внешнее связывание. Теперь функцию можно определять во всех единицах трансляции единожды. И итоге код для всех этих определений объединится и будет один экземпляр функции в бинарнике. А вот static говорит, что у функции теперь внутреннее связывание и в каждой единице трансляции будет своя копия функции.

Нихера не клеится. Эти ключевые слова задают практически противоположное поведение. Как же они будут сочетаться?

static победит. И в каждой единице трансляции будет своя копия функции. inline здесь будет всего лишь подсказкой к встраиванию функции.

Однако здесь есть один интересный момент. Лишь для статической функции компилятор может попробовать встроить все ее вызовы и вообще не генерировать код для нее. Потому что static - гарантия того, что за пределами юнита трансляции никто не будет пробовать вызвать эту функцию. А значит, если получится в текущем юните встроить все вызовы, то и код функции вообще генерировать не нужно. Он просто никому не понадобиться. Для функций с внешней линковкой такой трюк не провернуть. Компилятор обязан для них генерировать код, потому что линкер потом может сослаться на вызов этой функции. И придется делать call, который должен перепрыгивать в тело функции.

Для глобальных переменных применимо все то же самое, что и в предыдущем случае, за исключением возможности встраивания. inline переменные, введенные вместе с 17-м стандартом, повторяют только линковочную семантику inline функций, поэтому static inline переменная также будет иметь копии в каждой единице трансляции, куда она попала.

К тому же это все справедливо и для хэдеров, и для цппшников.

Теперь про методы класса. Для них static не имеет того же значения, что и для предыдущих случаев. Статические методы - это по факту обычные свободные функции с внешним связыванием, которые имеют доступ ко всем полям класса. Поэтому в этом случае добавление inline просто будет явным намеком компилятору, что метод можно встроить. Хотя смысла от этого намека немного, ибо при этом всем, все статические методы, определенные внутри описания класса, неявно помечены inline, чтобы иметь возможность определять такие методы сразу в хэдерах и обходить odr.

И для полей класса. Мы кстати разбирали уже этот случай выше. Пометив статическое поле inline, мы получаем возможность определять это поле внутри описания класса и не беспокоиться по поводу линкера и odr. Собственно, как и в случае с методами.


inline constexpr

Чуть выше мы уже обсуждали, что удобно определять константы в заголовочнике и помечать их inline constexpr. Сейчас я бы хотел поговорить в целом про два этих ключевых слова и рассмотреть, как они друг на друга влияют.

Как мы знаем, inline - теперь это больше про линковку.  Базово inline обеспечивает внешнее связывание и предоставляет компилятору партийный билет на нарушение odr, который дает право иметь по одному определению сущности на одну единицу трансляции, а не на всю программу, как обычные смертные.

Теперь нужно посмотреть, какие особенности линковки у constexpr сущностей, чтобы понять, как они с inline взаимодействуют.

У нас опять куча вариантов, какие сущности мы можем пометить constexpr. Но в разрезе линковки их всего 2, поэтому будет полегче.

Первая группа - спецификатор используется при определении объектов. В этом случае подразумевается, что эти объекты помечены const. А это уже значит, что они базово имеют внутреннюю линковку. Кстати, константы можно помечать extern, чтобы у них сменился вид линковки с внутренней на внешнюю. А вот constexpr объекты - нельзя. Потому что связка объявления символа с его значением при внешнем связывании происходит на этапе линковки. А constexpr требует, чтобы значение было известно на этапе компиляции.

Вторая группа - функции и статические члены класса. В этом случае подразумевается, что они неявно помечены inline. На это есть весьма веские причины(по-другому и не делается). Функции, которые могут выполнять вычисления в compile-time, должны быть видны на этом самом этапе компиляции всем единицам трансляции. Так что extern мы сразу отбрасываем, такого не может быть. Они могли бы помечаться static, но тогда потенциально будет дублироваться код функции во всех единицах трансляции. А inline решает все проблемы. Функцию видно во всех единицах трансляции, куда она подключается. А код на этапе линковки объединяется в одно определение и никакого дублирования.

Для статических полей класса похожая схема. Раз их определение должно быть видно всем единицам трансляции, которые видят этот класс, то их нужно определять внутри описания класса. А это(за исключением пары случаев) можно сделать только, если пометить статический член как inline.

Получается, что нет смысла писать inline constexpr для любого рода функций(которые в принципе могут быть constexpr) и для статических поле классов. Это можно сделать, чтобы подсветить эту конкретную особенность и намерение(?), но, на самом деле, непонятно, что это изменит.

А вот глобальные объекты есть смысл помечать inline. Чтобы избежать издержек внутренней линковки объектов. Но мы уже это проговаривали.

static inline constexpr

Настоящий Франкенштейн. Прошлая глава была про inline constexpr, поэтому нам осталось только добавить к этому всему немного статичности)

Как мы знаем, constexpr для статических методов и полей класса подразумевает inline. Следовательно в этих случаях static обозначает принадлежность свободной функции или глобальной переменной к классу, а не объекту, и внешнюю линковку. constexpr здесь отвечает за возможность использования сущности в вычислениях времени компиляции, а inline обеспечивает эту возможность. Чтобы все единицы трансляции получили определение сущности во время компиляции.

Далее свободные функции и методы класса. Для них constexpr тоже подразумевает inline. Если к методу класса приписать static, то он будет уже не методом, а статической функцией, кейс которой мы обсуждали выше. Если для свободной, по факту уже, inline constexpr функции дописать static, то static кинет на прогиб ваш inline и навяжет свои правила. Эту функцию также можно будет продолжать использовать для compile-time вычислений, но в каждой единице трансляции будет своя копия этой функции. То есть тип линковки изменится с внешней на внутренюю.

Ну и теперь глобальные переменные. С ними ситуация почти такая же, как и со свободными функциями. Только здесь constexpr раскрывается в просто const и дает внутреннее связывание. inline говорит, что нихера подобного, пусть все тебя видят. И дает внешнее связывание. Но приходит static и в честном, бесконтактном бою закидывает невидимыми энергоударами инлайн и побеждает его. Связывание будет внутренним.


Inline под капотом

Мы уже знаем, что inline позволяет находится определению одних и тех же сущностей в разных единицах трансляции. А потом на этапе линковки, компоновщик объединяет все эти определения в одно. Но как конкретно он это делает? Как устроен этот механизм в деталях? Очень важно разобраться во всех тонкостях этого вопроса, чтобы глубоко его понимать. Я поставил эту главу именно по завершению разговора про inline сущности, чтобы в начале вы сформировали понимание поведения этих сущностей и зачем они используются. А затем, понимая всю практическую сторону вопроса, копнуть его внутренности.

Вернемся к примеру с константами. Только уберем их константность, чтобы компилятор не подставлял их значения сразу по месту использования. И добавим static, чтобы на нас не ругался линкер.

Ну и обернем это все в какую-то программу, чтобы можно было немножко поиграться. А играться мы будем с ключевыми словами. В начале посмотрим, как будут себя вести static переменные, а зачем - inline.

![[Pasted image 20240302230243.png]]

Как будет выглядеть переменная light_speed в единице трансляции, соответствующей файлу first.cpp?
```
.data
.align 4
.type    _ZN9constantsL11light_speedE, @object
.size    _ZN9constantsL11light_speedE, 4
_ZN9constantsL11light_speedE:
.long    299792458
```

Рассмотрим по порядку, что здесь происходит. Начинается сегмент данных, которые выровнены на 4 байта. Говорим, что наш символ \_ZN9constantsL11light\_speedE - это объект с размером 4 байта. И определяем этом символ, говорим, что он типа long со значением 299792458.

И в результирующем бинарнике у нас будет 2 экземпляра семантически одной переменной в разных единицах трансляции.

0000000000004010 d \_ZN9constantsL11light\_speedE
0000000000004020 d \_ZN9constantsL11light\_speedE

Что конечно может хорошенько подпортить жизнь трудноотловимыми багами. Например, вы будет рассчитывать, что изменяете или читаете одну переменную, а на самом деле это будет ее клон. Не нужно объявлять в хэдерах изменяющиеся переменные как static. Но повторю, что это только учебный пример, чтобы показать интересности линковки inline. Много циферок - виртуальный адрес символа, а d значит, что символ инициализирован.

Теперь, что будет, если мы static заменим на inline.

```
.weak    _ZN9constants11light_speedE
.section     .data._ZN9constants11light_speedE,"awG",@progbits,_ZN9constants11light_speedE,comdat
.align 4
.type    _ZN9constants11light_speedE, @gnu_unique_object
.size    _ZN9constants11light_speedE, 4
_ZN9constants11light_speedE:
    .long    299792458
```

Здесь определяется слабый символ \_ZN9constants11light\_speedE(weak). Слабый символ может быть переписан другим определением. Дальше идет секция данных и очень много страшных букв, но нам важно только последнее слово "comdat". Оно значит: "Здарова братишка, компоновщик! Не в службу, а в дружбу, не конкатенируй определения для символа \_ZN9constants11light\_speedE, а просто выбери из них всех одно и вставь в финальный бинарь. Мое увожение!". Это и есть тот маркер, по которому линкер определяет inline сущности. Ну и это все идет с компании с типом @gnu\_unique\_object, который должен быть уникальным во всех программе и это предотвращает дупликацию кода. 

А когда компановщик выберет определение символа, он может переписать его в других единицах трансляции и сослать их на вот это единственное выбранное определение. 

Тогда в бинарнике будет только одна запись на эту переменную.

0000000000004018 u \_ZN9constants11light\_speedE

u здесь значит, что символ глобальный и уникальный для всей программы.

Конечно, здесь все описано в общих чертах. Но вот еще ниже вам вряд ли в этот вопрос когда-нибудь нужно будет погружаться. 

Флаги контроля за встраиванием

Так как мы имеем дело со встраиванием функции или inline expansion, что является оптимизацией компилятора, нам нужно знать, как именно заставить компилятор проводить эту оптимизацию. Делается это с помощью определенных флагов. Давайте же их и рассмотрим.

Оговорюсь, что буду вещать про флаги gcc, так как это самый популярный инструмент. Да и в шланге, думаю, будут те же самые флаги, чисто для совместмости и привычного использования. Погнали:

-fno-inline - запрещает какие-либо функции, за исключением тех, которые маркированы атрибутом alwaysinline. Этот режим стоит по дефолту, когда не подрублены оптимизации. И кстати, есть такой атрибут noinline, которым можно пометить отдельную функцию, и это запретит ее встраивать.

-finline-small-functions - разрешает встраивать функции в код их коллера, когда их тело меньше, чем тот код, который генерируется для вызова этих функций. Тогда размер всей программы будет меньше. У компилятора там есть свои эвристики, по которым он принимает решение, достаточно ли маленькая определенная функция. В этом случае компилятор может  применить инлайнинг ко всем функциям, даже к тем, которые не помечены ключевым словом inline. Применяется на уровнях оптимизации  -O2, -O3, -Os.

-finline-functions - разрешает рассматривать вообще все функции, как кандидатов на встраивание, даже если они не помечены как inline. Опять же компилятор у нас самостоятельный дядя и сам решает, когда и что встроить. Применяется на уровнях оптимизации  -O2, -O3, -Os.
Если все вызовы определенной функции встроены и она помечена static, то для нее вообще не генерируется ассемблер.

-findirect-inlining - разрешает встаивать также непрямые вызовы функции, например через указатель на функцию. Опция имеет смысл только, когда подключена хотя бы одна из двух предыдущих опций. Применяется на уровнях оптимизации  -O2, -O3, -Os.

-finline-functions-called-once - разрешает рассматривать для встраивания все статические функции, которые лишь однажды вызываются, даже если они не помечены как inline. Если инлайнинг удался, то для функции не генерируется ассемблер. Применяется почти на уровнях оптимизации  -O1, -O2, -O3, -Os, но не для -Og.

-finline-limit=n - по дефолту gcc ограничивает размер функций, которые могут быть встроены. Этот флаг позволяет грубо контролировать этот предел. n тут - это размер функции, измеряемый в псевдоинструкциях(знать бы еще что это такое).

-fkeep-inline-functions - оставляет ассемблер для всех встроенных функций. Даже для статических и встроенных во все свои вызовы.

-fpartial-inlining - разрешает встраивание частей функции. Это довольно агрессивная и опасная оптимизация, потому что не совсем понятно, как именно компилятор разбивает функцию на части и решает, какие из них встаивать. Опция имеет смысл только при включенных -finline-functions или -finline-small-functions. Применяется на уровнях оптимизации  -O2, -O3, -Os.

Это все основные флаги. Есть еще несколько, но они сложны в описании и понимании, поэтому не буду их упоминать. А в этом списке вроде все логично, понятно и практически применимо.

Самый простой способ разрешить инлайнинг и не париться по поводу опций - подрубить -O2. Тогда у вас автоматически подключаться все, что нужно.


Inline namespace

Наша финальная остановочка в этом гайде. Это очень специфическое применение ключевого слова inline, но без него гайд был бы неполный.

Ключевое слово inline используется либо как подсказка компилятору для встраивания кода функции в место ее вызова, либо как средство обхода ODR. Применять его можно и к функциям, и к переменным(с С++17). Но есть еще одно интересное применение inline. Им мы можем пометить пространство имен. Такая пометка неймспейсов доступна с С++11. Я бы сказал, что судя по названию и уже усвоенной инфе, мы можем понять, что это значит. Но нет. Нихрена не понятно. Поэтому будем разбираться.

Контекст и использование встроенных неймспейсов совсем простой, однако он отличается от поведения других inline сущностей. Все, что объявлено внутри такого пространства имен, считается также членом внешнего неймспейса, которое содержит в себе данный inline namespace. То есть
```cpp
namespace trah {
   inline namespace tibidoh {
       template<typename T> class tibidoh{ /* ... */ };
   }
   template<typename T> void tenberg(T) { /* ... */ }
}
```


есть у нас вот такая иерархия. Неймспейс трах. У него есть шаблонная функция тенберг. И в него вложен встроеный неймспейс тибедох. В этом внутреннем неймспейсе шаблонный класс тибедох. И прикол в том, что вместо trah::tibidoh::tibidoh я могу написать просто trah::tibidoh и использовать вложенный класс наряду с функцией trah::tenberg.

То есть в общем и целом, этот механизм позволяет автору кода сделать так, чтобы все объявления во вложенном неймспейсе выглядели и действовали, как объявления внешнего неймспейса. Более того, если есть несколько вложенных встроенных неймспейсов, то все объявления всех вложенных неймспейсов доступны в первом невстроенном пространстве имен.

Для чего это нужно? По сути эта фича призвана решить одну единственную проблему - версионирование библиотеки. Глянем на прошлый пример. Библиотека trah активно развивается и, начиная с какой-то версии, в ней появился класс tibedoh, которого не было в предыдущей версии библиотеки. До появления С++11 это выглядело бы примерно так:
```cpp
namespace trah {
#  if __version == new
  using namespace tibidoh;
#  endif
    namespace tibidoh {
       template<typename T> class tibidoh{ /* ... */ };
   }
   template<typename T> void tenberg(T) { /* ... */ }
}
```



В этом случае нам недоступен класс tibidoh, если мы не используем новую версию либы. А если используем, то using помогает нам не писать оператор разрешения имен и пользоваться классом tibidoh, как если бы он был членом неймспейса trah. То есть вот так trah::tibidoh. Вроде все круто и нет проблем. Но не все так просто.

Мне, как пользователю библиотеки, не желательно что-то объявлять в пространстве имен trah, по аналогии с std. Однако мне разрешается делать полную специализацию для шаблонов непосредственно в trah без последствий. Я, как автор своих классов, лучше знаю, как ими нужно оперировать, чтобы достичь максимального перфоманса. Зная API библиотеки, я думаю, что класс tibedoh объявлен в trah. Окей, пишу:
```cpp
namespace trah {
   template <>
  class tibidoh<AbraKadabra> {
      // ...
  };
}
```

Но вот проблема. Мне позволяется полностью специализировать шаблоны именно в том пространстве имен, в котором шаблон объявлен. А на самом деле он объявлен во вложенном неймспейсе. Предыдущий код мог бы сработать для неверсионированной либы, но в нашем случае будет просто ошибка компиляции.

Это не единственный пример, когда вложенное пространство имен становится видным пользовательскому коду. Например, ADL не следует директиве using и при поиске символа из вложенного неймспейса во внешнем. ADL будет очень стараться, но так и не найдет нужный символ, который на самом деле спрятан во вложенном namespace.

Есть еще парочку примеров, но они излишни. inline namespace решает все эти проблемы и делает версионирование библиотек намного более простым занятием. Теперь мы можем писать так:

```cpp
namespace trah {
#  if __version == new // только в новой версии библиотеки будет виден класс tibedoh и он будет как будто бы определен рядышком с функцией tenberg.
 inline
#  endif
   namespace tibidoh {
      template<typename T> class tibedoh{ /* ... */ };
  }
  template<typename T> void tenberg(T) { /* ... */ }
}
```

Фух. Теперь у нас с вами есть основные знания о том, что такое инлайн, какие у него смыслы, где его применять и какие из этого следуют плюшки. Это был довольно базированный гайд. Пока рассказывал, сам понял, как говорится. Надеюсь, вам тоже понравилось)

Спасибо, что уделили внимание моей писанине. Хорошего вам дня!!!

