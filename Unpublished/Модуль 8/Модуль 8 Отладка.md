
Оры:

- понимает устройство отладчика верхнеуровнево
- применяет gdb для отлаживания программы и поиска ошибок

Структура:

- (если уж мы говорим про gdb или lldb, то скорее всего речь идет о Unix-системах. Тогда я буду рассказывать про unix-специфичные вещи.)
- отлаживать программы по машинному коду - непростая задача. компилятор делает кучу оптимизаций и в итоговом бинарнике мы не сможем адекватно сопоставить код программы с машинным кодом. Поэтому для отладки есть специальная опция компиляции, которая вместе с бинарным файлом кладет информацию для отладки. В unix системах это формат dwarf.
- коротко описываю на коротких примерах из чего состоит dwarf и например, как из него с помощью readelf достать адреса строчек программы.
- dwarf позволяет по машинному коду понимать, где мы сейчас находится по оригинальному тексту программы.
- На unix-системах есть 2 дебагера gdb и lldb. Примеры и принципы будем рассматривать для gdb.
- Это в некотором роде интерактивная среда взаимодействия с программой. 
- Квиз 1
- Программу можно запустить в ней с помощью run или start и начать инспектировать.
- Основные команды, которые предоставляет любой дебаггер - установить точку останова, показать стек вызовов, шагнуть вперед по исполнению и вывести на экран значение переменной
- основной инструмент дебага - это breakpoint точка останова. Рассказываем в общих чертах про программные прерывания.
- backtrace - показывает стек вызовов. Коротко рассказываю про фреймы и адреса возврата.
- любой шаг по программе(next, step, finish)- это скрытая точка останова, на которой в следующий раз остановится исполнение.
- print - для вывода переменной на консоль. 
- на примере одной программы с ошибкой попробуем найти где проблема.
- Квиз 2

## Введение

Программисты проводят до 30% времени выполнения задачи в отладке кода, поэтому важно овладеть навыками использования инструментов отладки, чтобы сократить это время. Сегодня вы узнаете:

- как правильно собрать программу, чтобы в ней была доступна отладочная информация.
- что представляет из себя отладочная информация и причем здесь дворфы и эльфы.
- какой основной инструмент отладки на unix-системах.
- какие основные команды управлением отладчиком и как они работают.

## Отладка кода

Отладка сегодня – неотъемлемый этап разработки ПО.

Как можно отлаживать программы? Это можно делать, вставляя код, который печатает значения выбранных переменных. В некоторых ситуациях, например при отладке кода скриптовых языков, этот метод может оказаться предпочтительным. Не нужны никакие дополнительные инструменты, запустил – увидел, где косяк – исправил – снова запустил. 

Но намного проще использовать отладчик на уровне исходного кода, который позволяет вам проходить исходный код программы, устанавливать точки останова, печатать значения переменных, находясь в отладчике. Проблема заключается в том, как скоординировать две совершенно разные программы, компилятор и отладчик, чтобы программу можно было отлаживать.

Процесс компиляции программы из удобочитаемой формы в двоичную форму, которую выполняет процессор, по существу состоит в том, чтобы взять исходный код С++ программы и преобразовать его в эффективный, но непонятный человеку машинный язык.

![[Pasted image 20250727214111.png]]

Отлаживать программы по чистому машинному коду - непростая задача. Компилятор делает кучу оптимизаций: может инлайнить вызовы функций, переставлять местами инструкции и выкидывать ненужные строчки кода. В итоговом бинарнике мы не сможем адекватно сопоставить код программы с машинным кодом.

Нужно отключить все оптимизации, чтобы машинный код максимально соответствовал исходному.

Но даже этого мало. Нужно еще как-то поместить описание исполняемой программы и ее связи с исходным кодом достаточно подробно, чтобы позволить отладчику предоставить программисту полезную информацию. В то же время описание должно быть достаточно кратким.

Все это делается с помощью опций компиляции. Чтобы правильно скомпилировать программу для отладки, нужно

- явно убрать все опции для оптимизаций c помощью флага `-O0`.
- указать дополнительную опцию компиляции `-g`.

В этому случае машинный код программы будет максимально соответствовать исходному коду программы, а в бинарном файле окажется отладочная информация.

Но как она выглядит?

##  DWARF

Она представляется в виде стандартного формата отладки DWARF: это компактное представление отношений между исполняемой программой и исходным кодом таким образом, который достаточно эффективен для обработки отладчиком.

Большинство современных языков программирования имеют блочную структуру: каждая сущность (например, определение класса или функция) содержится внутри другой сущности. Например:

```cpp
#include <iostream>
#include <memory>

class Shape {
public:
    virtual double Area() const = 0;
    virtual ~Shape() = default;
};

class Circle : public Shape {
    double radius;
public:
    Circle(double r) : radius(r) {}
    double Area() const override {
        return 3.14 * radius * radius;
    }
};

class Square : public Shape {
    double side;
public:
    Square(double s) : side(s) {}
    double Area() const override {
        return side * side;
    }
};

int main() {
    std::unique_ptr<Shape> shapes[] = {std::make_unique<Circle>(5), std::make_unique<Square>(4)};
    
    for (const auto& shape : shapes) {
        std::cout << "Area: " << shape->Area() << "\n";
    }
}
```

Четко видны блоки, и их отношения друг с другом и вложенность. Чтобы найти определение определенного символа в программе, вы сначала просматриваете текущую область видимости, а затем — последовательно поднимаетесь по областям видимости, пока не найдете символ.

![[Pasted image 20250727221718.png]]

![[Pasted image 20250813211704.png]]
Поэтому компиляторы очень естественно представляют программу внутренне в виде дерева. DWARF следует этой модели в том смысле, что описание программы DWARF представляет собой древовидную структуру, аналогичную внутреннему дереву компилятора, где каждый узел может иметь дочерние элементы или братьев и сестер. Узлы могут представлять типы, переменные или функции.

Помимо этого dwarf хранит информацию об адресам инструкций и о соответствующих им номерах строк исходного кода программы .

Структура dwarf выглядит примерно так:

```
.debug_info (основная секция)
│
├─ Compilation Unit 1 (CU) <-- Начало компиляционной единицы
│  ├─ DW_TAG_compile_unit
│  │  ├─ DW_AT_name: "main.cpp"       <-- Исходный файл
│  │  ├─ DW_AT_language: DW_LANG_CPP  <-- Язык
│  │  └─ DW_AT_low_pc: 0x4004a0     <-- Адрес начала
│  │
│  ├─ DW_TAG_subprogram            <-- Функция
│  │  ├─ DW_AT_name: "main"
│  │  ├─ DW_AT_type: DW_TAG_int
│  │  └─ DW_AT_low_pc: 0x4004a0
│  │
│  └─ DW_TAG_variable             <-- Переменная
│     ├─ DW_AT_name: "counter"
│     └─ DW_AT_type: DW_TAG_int
│
├─ .debug_abbrev  <-- Таблица сокращений
├─ .debug_line    <-- Соответствие строк кода и адресов
│  └─ Line Number Program:
│     0x4004a0  main.c:5
│     0x4004a4  main.c:6
│
├─ .debug_str     <-- Пулы строк
├─ .debug_loc     <-- Информация о локациях переменных
└─ .debug_frame   <-- Данные о стековых фреймах
```


На верхнем слое разполагаются различные секции, которые хранят разную информацию о программе(адреса строк, информацию о стековых фреймах и тд). В секции debug_info находит дерево элементов для каждой единицы трансляции: в начале информаци о том, как скомпилирован файл, затем отдельные узлы для каждой функции и переменной.

Вы можете сами исследовать детали отладочной информации. Возьмите простую программу:

```cpp
#include <stdio.h>

int main() {
	int i = 5;
	printf("Hello, World! %d\n", i);
}
```

Скомпилируйте ее с помощью команды: `g++ main.cpp -std=c++23 -g -O0`. Получите исполняемый файл a.out. Это файл формата ELF(Executable and Linkable Format) и для просмотра его внутренностей есть утилита readelf.

Чтобы посмотреть, как устроена отладочная информация в этом файле, запустите команду `readelf --debug-dump=info a.out `. 

Чтобы посмотреть информацию о соответствии адресов машинного кода и строк программы, запустите команду `readelf --debug-dump=decodedline a.out `.

То есть отладочная информация помогает отладчику установить тесную и четкую связь между исходным кодом программы и машинными инструкциями.

## GDB

В unix-системах есть 2 основных дебаггера: gdb(GNU Debugger) и lldb(LLVM Debugger). gdb реализован с полной совместимостью с gcc, самым популярным компилятором, поэтому все дальнейшие примеры будем рассматривать с ним. 

Чтобы запустить отладчик, нужно ввести команду в теминал: `gdb <имя бинарного файла>`.
После этого у вас откроется интерактивная оболочка gdb, где вы можете управлять поведением программы.

Самое простое, что можно сделать - запустить программу с помощью команды `run`.  Если вам нужно передать какие-то аргументы в программу, выполните `run <arg1> <arg2>`.

Для того, чтобы управлять ходом программы, существуются следующий базовые команды:
- установка программных точек останова
- показ стека вызовов
- проход по программе
- вывод значения переменных на экран
## Точки останова

Точки останова(breakpoint, брейкпоинт) позволяют вам останавливать выполнение программы там, где вы захотите.  Брейкпоинт можно установить:

- по имени функции: `break <func_name>`. Например, `break main` установит брейкпоинт в функции main.
- по номеру строки: `break <file>:<line>`. Например, `file.cpp:42` установит брейкпоинт в файле file.cpp на 42 строке.

Также есть команды, управляющие точками останова в программе:

- `info break`  - Получаем пронумерованный список всех точек.
- `disable N`  - Отключить точку под номером N.
- `enable N` -  Включить точку под номером N.
- `delete N` - Удалить точку под номером N.

После установки брейкпоинта исполнение программы, запущенной через команду `run`, прервется при достижении строчки кода, на которой установлен соответствующий брейкпоинт.

## Стек вызовов

Как только вы остановили выполнение кода, можно посмотреть, в какой точке программы вы остановились и какой набор вызовов функций вас привел в эту точку. Команда `backtrace` покажет вам текущий стек вызовов функций. Примерный вывод:

```
  
#0  functionA() at file.c:10
#1  0x12345678 in functionB() at file.c:25
#2  0x87654321 in main() at main.c:5

По столбцам:
1. Номер фрейма (`#0`, `#1`, etc.):
    - `#0` — текущая функция (где программа остановилась).
    - `#1` и далее — цепочка вызовов (кто вызвал текущую функцию).
        
2. Адрес в памяти (`0x12345678`):
    - Адрес возврата (куда перейдет выполнение после завершения текущей функции).
        
3. Имя функции и исходный файл:
    - `functionA() at file.c:10` — имя функции и строка в коде.
```
## Проход по программе

Отлично, вы остановились и посмотрели, как вас занесло в эту точку программы. Но хочется посмотреть конкретную строчку кода и ее окружение. Для этого есть команда `list`, возвращающая 10 строчек исходного кода: 5 выше текущей точки, 5 ниже.

Вы также можете перемещаться по программе от одной строчки к другой.

Чтобы перейти к следующей строчке программы, введите команду `next`.

Однако на следующей строчке может оказаться вызов функции и вы захотите зайти в нее и посмотреть, что в ней происходит. В этом случае вам нужна команда `step`.
Если вы вдруг понимаете, что инспектировать текущую функцию вам уже не нужно, вы можете перейти к точке, сразу после окончания выполнения функции. Для этого вам понадобится команда `finish`.

Для продолжения исполнения программы до следующей точки останова, выполните команду `continue`.

## Печать значений

Вы научились останавливаться, осматриваться и ходить по программе. Осталось только уметь выводить значения переменных на экран!

Для печати текущего значения переменной введите команду: `print <variable_name>`.

Команда `print` - очень мощный инструмент. Она понимает синтаксис С++, может вызывать функции и методы у объектов. Например, если переменная `vec` - это вектор, то `print vec.size()` выведет размер этого вектора.

Иногда нужно на каждом шаге следить за изменением отдельной переменной. Чтобы gdb выводил значение конкретной переменной на каждом шаге, введите команду `display <variable_name>`.

## GDB Server

Отладчик gdb обычно используется для отладки процесса, работающего на том же компьютере. 

Но с помощью gdb также может отлаживать процессы, запущенные на другом устройстве. Для этого gdb определяет протокол (то есть набор пакетов запроса и ответа), который облегчает выборку значений памяти или регистров, установку точек останова и т.д. gdbserver является реализацией этого протокола «удаленной отладки gdb». Для отладки процесса, запущенного на удаленном компьютере, на стороне удаленного компьютера должен работать gdbserver. gdbserver - это намного более легковесная программа, чем полноценный gdb, поэтому может быть запущена на устройствах с ограниченными ресурсами, например на микроконтроллерах.

Чтобы отлаживать программу на целевой машине с помощью удаленного хоста нужно:

1. Установить gdbserver на целевой машине или убедиться в его наличии
2. Убедиться в наличии программы на целевой машине и хосте для корректной работы
3. Запустить: `gdbserver :<myport> myprogram` на целевой машине. После этого gdbserver выведет pid процесса и порт(myport), который он слушает. Пример: `gdbserver :9999 myprogram`
4. Запустить gdb с файлом программы хост машине: `gdb myprogram`
5. Скомандовать` target remote <target_ip>:<myport>`. Указать айпи целевой машины и порт, который слушает gdbserver.

После этого можете на хост машине внутри оболочки gdb писать команды, а отладчик будет их отправлять на целевую машину и обрабатывать ответ.

## Полезные материалы

В рамках данного урока невозможно рассказать про все возможности gdb, поэтому приведем несколько полезных ссылок.

Подборка большинства нужных команд gdb - https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf.

Как писать свои расширения для отладчика с помощью gdb api - https://undo.io/resources/gdb-watchpoint/here-quick-way-pretty-print-structures-gdb/.

Как использовать удобный пользовательский интерфейс gdb - https://undo.io/resources/enhance-gdb-with-tui/.


**Кнопка**: К итогам!

## Итоги

В этом уроке вы узнали:

- Для комфортной отладки программа должна быть собрана с флагами: `-O0 -g`

- DWARF - это формат отладочной информации, которая вшивается в бинарный ELF файл.
- Этот формат представляет сущности программы в виде дерева, а также сохраняет информацию о соответствии адресов машинных инструкций и исходного кода
- gdb - основной отладчик на unix-системах.
- Основными командами является: установка точек останова(`break`), показ стека вызовов(`backtrace`), показ текущего местоположения(`list`), проход по программе(`step`, `next`, `finish`, `continue`) и печать значений(`print`).
- gdbserver помогает удаленно отлаживать приложения.

