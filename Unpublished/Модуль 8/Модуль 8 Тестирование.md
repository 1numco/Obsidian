Оры:
- применяет разнообразные виды утверждений и тестовые фикстуры для тестирования программ
- применяет типизированные и параметрические тесты для тестирования программ.
- применяет мокирование интерфейсов для тестирования программ.
- применяет фаззи тестирование для поиска нетривиальных ошибок

Структура:

- юнит тесты - база, без них невозможно разрабатывать безопасное ПО
- чтобы не городить своих фреймворков тестирования, можно использовать gtest. Это мощный фреймворк, предоставляющий широкий спект инструментов тестирования.
- Простые тесты на ассерты и проверки на равенство. Сравнение float(УДАЛИТЬ В УРОКЕ)
- Ожидание исключений
- Фикстуры. SetUp для каждого теста или для всех тестов фикстуры
- Запуск тестов и написание main
- Сниппет
- Типизированные тесты
- Параметрические тесты.
- Сниппет


## Введение

Тестирование кода - не менее важная часть разработки, чем само написание кода. Сегодня вы узнаете:

- какой фреймворк является де-факто стандартом при модульном тестировании кода.
- какие инструменты есть для различных проверок результатов работы кода.
- что такое тестовые фикстуры.
- как писать параметрические и типизированные тесты.

## Юнит-тесты

Хорошей практикой разработки ПО является написание тестов. Они могут быть разных видов: модульные, компонентные, интеграционные, функциональные, перфоманс и тд. В этом уроке мы будем рассматривать только модульные тесты, так как это база, без которой невозможны остальные тесты.

![[Pasted image 20250813115847.png]]

Unit-тесты(или модульные, или юнит тесты) -  это автоматические проверки для отдельных "кусочков" кода(функций, классов, методов), с помощью которых можно убедиться, что эти кусочки работают правильно.

Эта базовая практика разработки. Большой и сложный код всегда состоит из более простых частей. Гарантия того, что эти части работают корректно, повышают качество и безопасность всей большой системы. Даже сам факт того, что код будет тестироваться, заставляет программистов глубже задумываться над архитектурой кода и применять хорошие практики. Непросто достичь того, чтобы каждая логическая единица кода могла тестироваться отдельно. Однако это помогает уменьшать связность кода и в будущем уменьшать время внесения доработок.

## GTest

Юнит тесты можно писать с помощью большого спектра инструментов. Но большой зоопарк инструментария негативно сказывается на скорости разработки: программистам приходится привыкать к разным тестирующим фреймворкам. Поэтому для большой универсализации кода в коммьюнити принято пользоваться фреймворком GoogleTest или сокращенно gtest. И не зря именно им: gtest позволяет писать самые различные тесты на любой возможный код и предоставляет широкий спектр инструментов для этого.

## Простые тесты

Начнем с простого: у нас есть функция, которая вычисляет факториал:

```cpp
int Factorial(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    if (n < 0) {
        throw std::invalid_argument("Factorial is not defined for negative numbers");
    }
    if (n > 12) { // 13! > INT_MAX для 32-bit int
        throw std::overflow_error("Integer overflow for n > 12");
    }
    return n * Factorial(n - 1);
}
```

Для работы с gtest необходимо подключить хэдэр gtest/gtest.h.

Чтобы создать тест: 
- используйте макрос TEST() для определения и имени тестовой функции. Это обычные функции C++, которые не возвращают значение. 
- В этой функции, наряду с любыми допустимыми операциями C++, используйте различные утверждения GoogleTest для проверки значений. 
- Результат теста определяется утверждениями: если какое-либо утверждение в тесте дает сбой (фатальный или нефатальный) или если код в тесте крашится, весь тест считается проваленным. В противном случае он завершается успешно. 

```cpp
TEST(TestSuiteName, TestName) { ... тело теста ... }
```

Аргументы TEST() идут от общего к частному. Первый аргумент — это имя тестового набора, а второй аргумент — имя теста в тестовом наборе. Оба имени должны быть допустимыми идентификаторами C++ и не должны содержать подчеркиваний (\_). Полное имя теста состоит из содержащего его тестового набора и его индивидуального имени. Тесты из разных тестовых наборов могут иметь одинаковое индивидуальное имя.

Для полного тестирования функции хорошо бы проверить все возможные входные значения. Но это избыточно: достаточно проверить несколько happy path сценариев и краевые случаи.

Начнем с happy path:

```cpp
#include <gtest/gtest.h>

TEST(FactorialTest, HappyPath) {
	EXPECT_EQ(Factorial(1), 1);
	EXPECT_EQ(Factorial(1), 1);
	EXPECT_EQ(Factorial(2), 2);
	EXPECT_EQ(Factorial(3), 6);
	EXPECT_EQ(Factorial(8), 40320);
}
```

Здесь мы определили тест HappyPath из тестового набора FactorialTest. В нем с помощью утверждений EXPECT_EQ мы ожидаем, что правые и левые части утверждения равны. EXPECT_EQ - это макрос, осуществляющий проверку.

Существует большое количество утверждений, которые разделяются на две большие категории префиксами ASSERT_ и EXPECT_.  В случае сбоя макросы EXPECT_ генерируют нефатальные сбои и позволяют текущей тестовой функции продолжить выполнение, в то время как макросы ASSERT_ генерируют фатальные сбои и прерывают выполнение текущей функции. 

Примеры макросов-утвержений:

- EXPECT_EQ(val1, val2), ASSERT_EQ(val1, val2) - проверка двух операндов на равенство.
- EXPECT_NE(val1, val2),  ASSERT_NE(val1, val2) - проверка двух операндов на неравенство.
- EXPECT_TRUE(expr), ASSERT_TRUE(expr) - проверка выражения на истинность.
- EXPECT_FALSE(expr), ASSERT_FALSE(expr) - проверка выражения на ложность.
- EXPECT_FLOAT_EQ(val1, val2), ASSERT_FLOAT_EQ(val1, val2) - проверка на равенство двух float значений.
- EXPECT_DOUBLE_EQ(val1, val2), ASSERT_DOUBLE_EQ(val1, val2) - проверка на равенство двух double значений.
- EXPECT_NEAR(val1, val2, abs_error), ASSERT_NEAR(val1, val2, abs_error) - проверка того, что абсолютная разница между двумя значениями не превышает abs_error.

Вернемся в факториалу. Помимо благоприятных сценариев, у нас есть граничные случаи. Это выброс исключения, если аргумент меньше нуля или больше 12. gtest позволяет проверить, вылетит ли из функции исключение определенного типа с помощью утверждения EXPECT_THROW:

```cpp
TEST(FactorialTest, CornerCases) {
	EXPECT_THROW(Factorial(-1), std::invalid_argument);
	EXPECT_THROW(Factorial(13), std::overflow_error);
}
```

## Фикстуры

Если вам нужно написать два или более теста, которые работают с похожими данными, вы можете использовать фикстуру теста. Она позволяет повторно использовать одну и ту же конфигурацию объектов для нескольких тестов.

Для создания фикстуры нужно:

1. Создать класс, унаследованный от `testing::Test`. Все члены этого класса должны быть `protected:`, так как мы хотим получить доступ к членам фикстуры из подклассов.
2. Внутри класса объявить все объекты, которые планируете использовать.
3. При необходимости написать:
    - Конструктор по умолчанию или метод `SetUp()` для подготовки объектов перед каждым тестом.
    - Деструктор или метод `TearDown()` для освобождения ресурсов, выделенных в `SetUp()`.
    - Не забудьте добавить ключевое слово override, так как это виртуальные методы 
4. При необходимости определить вспомогательные функции для использования в тестах.

Теперь рассмотрим, как определять конкретные тест-кейсы.

Вместо `TEST()` используйте `TEST_F()`, так как это позволяет получить доступ к объектам и функциям фикстуры:

```cpp
TEST_F(ИмяКлассаФикстуры, ИмяТеста) {
  // тело теста
}
```

В отличие от `TEST()`, в `TEST_F()` первый аргумент должен быть именем класса фикстуры. Суффикс `_F` означает "Fixture".

Важные замечания:
- Нельзя использовать один макрос для обоих типов тестов
- Класс фикстуры должен быть определён до использования в `TEST_F()`


Для каждого теста, определённого с помощью `TEST_F()`, Google Test:

1. Создаёт новую фикстуру
2. Инициализирует её через `SetUp()`
3. Запускает тест
4. Очищает через `TearDown()`
5. Удаляет фикстуру

**Важно:** Разные тесты в одном наборе используют разные объекты фикстур. Изменения, сделанные в одном тесте, не влияют на другие.

Давайте перейдем к примеру.

Допустим, у нас есть класс очереди:

```cpp
template <typename E>
class Queue {
 public:
  Queue();
  void Enqueue(const E& element);
  std::optional<E> Dequeue();  // Возвращает nullopt, если очередь пуста
  size_t size() const;
  // ...
};
```

Создаём фикстуру (по негласному соглашению называем её `[ИмяКласса]Test`):

```cpp
// тестовая фикстура
class QueueTest : public testing::Test {
 protected:
  QueueTest() {
     // q0_ остаётся пустой
     q1_.Enqueue(1);
     q2_.Enqueue(2);
     q2_.Enqueue(3);
  }

  Queue<int> q0_;
  Queue<int> q1_;
  Queue<int> q2_;
};
```

В этом случае нам не нужно определять деструктор или `TearDown()`, так как компилятор сгенерирует подходящий деструктор.

Пишем тесты с использованием `TEST_F()`:

```cpp
TEST_F(QueueTest, IsEmptyInitially) {
  EXPECT_EQ(q0_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
	// проверка первой очереди
	auto elem = q0_.Dequeue();
	EXPECT_FALSE(elem.has_value());
	// проверки над второй очередью
	elem = q1_.Dequeue();
	ASSERT_TRUE(elem.has_value());
	EXPECT_EQ(*elem, 1);
	EXPECT_EQ(q1_.size(), 0);
	// проверки над третьей очередью
	elem = q2_.Dequeue();
	ASSERT_TRUE(elem.has_value());
	EXPECT_EQ(*elem, 2);
	EXPECT_EQ(q2_.size(), 1);
}
```

Обратите внимание, что в примере используется ASSERT_TRUE. Это важно, потому что разыменование пустого std::optional приводит к UB. Поэтому если проверка на has_value не проходит, дальнейший код нельзя выполнять и тест надо считать провальным.

## main()

Хорошо, вы написали код. Но надо его еще запустить. Для этого нужно написать функцию main(), являющуюся базовой точкой входа в программу.

По итогу ваш тест может выглядеть так:

```cpp
// file factorial.hpp
inline int Factorial(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    if (n < 0) {
        throw std::invalid_argument("Factorial is not defined for negative numbers");
    }
    if (n > 12) { // 13! > INT_MAX для 32-bit int
        throw std::overflow_error("Integer overflow for n > 12");
    }
    return n * Factorial(n - 1);
}

// file test_factorial.cpp
#include "factorial.hpp"
#include <gtest/gtest.h>

TEST(FactorialTest, HappyPath) {
	EXPECT_EQ(Factorial(1), 1);
	EXPECT_EQ(Factorial(1), 1);
	EXPECT_EQ(Factorial(2), 2);
	EXPECT_EQ(Factorial(3), 6);
	EXPECT_EQ(Factorial(8), 40320);
}

TEST(FactorialTest, CornerCases) {
	EXPECT_THROW(Factorial(-1), std::invalid_argument);
	EXPECT_THROW(Factorial(13), std::overflow_error);
}

int main(int argc, char **argv) {
	testing::InitGoogleTest(&argc, argv);
	return RUN_ALL_TESTS();
}
```

Такая функция main универсальна для практически любых тестов, написанных с помощью gtest. Поэтому фреймворк позаботился о нас и предоставил нам эту базовую реализацию main в библиотеке gtest_main. Это библиотеку нужно лишь прилинковать к тесту и можно не беспокоится о написании main.

## Типизированные тесты

Когда у вас есть несколько реализаций одного интерфейса или разные типы данных, которые должны работать одинаково, вы можете использовать типизированные тесты. Они позволяют:

1. Проверять общие требования для разных типов
2. Избегать дублирования кода тестов
3. Легко добавлять новые типы для тестирования

Без типизированных тестов пришлось бы писать отдельный тест для каждой комбинации (тест × тип), что неэффективно.

Вернемся к нашему классу очереди:

```cpp
template <typename E>
class Queue {
public:
    Queue();
    void Enqueue(const E& element);
    std::optional<E> Dequeue();  // Возвращает nullopt, если очередь пуста
    size_t size() const;
};
```

Она шаблонная и мы хотим проверить, что очередь корректно работает с разными типами данных.

Сначала создаём шаблон класса фикстуры и не забываем наследовать ее от testing::Test

```cpp
template <typename T>
class QueueTest : public testing::Test {
protected:
    void SetUp() override {
        // Добавляем тестовые данные в очередь
        queue_.Enqueue(T{1});
        queue_.Enqueue(T{2});
    }

    Queue<T> queue_;  // Тестируемая очередь
    Queue<T> empty_queue_;  // Пустая очередь для тестов
};
```

Далее определяем типы, которые будем тестировать и связываем эти типы с тестовой фикстурой:
    

```cpp
using TestTypes = testing::Types<int, double, float>;
TYPED_TEST_SUITE(QueueTest, TestTypes);
```

При написании собственно самих тест-кейсов используем TYPED_TEST вместо TEST_F. А внутри теста:
- `TypeParam` - тип параметра
- Доступ к членам фикстуры через `this->`

```cpp

TYPED_TEST(QueueTest, StartsEmpty) {
    EXPECT_EQ(this->empty_queue_.size(), 0);
}

TYPED_TEST(QueueTest, EnqueueIncreasesSize) {
    this->queue_.Enqueue(TypeParam{3});
    EXPECT_EQ(this->queue_.size(), 3);
}

TYPED_TEST(QueueTest, DequeueReturnsValuesInOrder) {
    auto first = this->queue_.Dequeue();
    auto second = this->queue_.Dequeue();
    
    ASSERT_TRUE(first.has_value());
    ASSERT_TRUE(second.has_value());
    
    EXPECT_EQ(first.value(), TypeParam{1});
    EXPECT_EQ(second.value(), TypeParam{2});
    EXPECT_EQ(this->queue_.size(), 0);
}

TYPED_TEST(QueueTest, DequeueEmptyReturnsNullopt) {
    auto result = this->empty_queue_.Dequeue();
    EXPECT_FALSE(result.has_value());
}
```

Такой подход особенно полезен для:
- Контейнеров
- Алгоритмов, работающих с разными типами
- Шаблонных классов, которые должны поддерживать различные типы данных
- Реализаций интерфейсов

## Параметрические тесты

Вернемся к функции факториала. В прошлый раз мы написали для нее тест вот так:

```cpp
TEST(FactorialTest, HappyPath) {
	EXPECT_EQ(Factorial(1), 1);
	EXPECT_EQ(Factorial(1), 1);
	EXPECT_EQ(Factorial(2), 2);
	EXPECT_EQ(Factorial(3), 6);
	EXPECT_EQ(Factorial(8), 40320);
}
```

Весь код проверок повторяется за исключением входных и ожидаемых значений. Чтобы убрать повторение кода можно использовать параметрические тесты.

Пройдем по шагам, что нужно сделать для написания параметрического юнит теста.

Для начала определим тестовую фикстуру:

```cpp
class HappyPathFactorialTest : public testing::TestWithParam<std::pair<int, int>> {};
```

Необходимо наследовать ее от testing::TestWithParam и в шаблонном параметре этого класса указать тип данных, которым мы будем параметризировать тест. HappyPath тесту нужны только два числа - input и expected. Поэтому параметризировать будем парой интов.

Далее определяем сам тест-кейс:

```cpp
TEST_P(HappyPathFactorialTest, ComputesCorrectValue) {
	auto [input, expected] = GetParam();
	EXPECT_EQ(Factorial(input), expected);
}
```

Для параметрических тестов нужно использовать макрос TEST_P, у которого первым аргументом идет имя тестовой фикстуры, а вторым - название конкретного тест-кейса. Значение параметра можно получить с помощью вызова функции GetParam().

И, наконец, необходимо инстанцировать тест с разными значениями параметров:

```cpp
INSTANTIATE_TEST_SUITE_P(ValidInputs, HappyPathFactorialTest,
                         testing::Values(std::pair(0, 1), 
                                         std::pair(1, 1), 
                                         std::pair(2, 2),
                                         std::pair(3, 6), 
                                         std::pair(5, 120)));
```

Получаем простой и расширяемый тест без копипасты.

Более подробно про работу с gtest вы можете прочитать [здесь](https://google.github.io/googletest/) 

**Кнопка**: К итогам!

## Итоги

В этом уроке вы узнали:

- gtest в текущих реалиях является самым популярным фреймворком тестирования и де-факто стандартом при написании тестов.
- gtest предоставляет различные виды утверждений для проверки результатов операций: ассерты, ожидания, ожидания исключений и тд.
- тестовые фикстуры - это классы, которые инкапсулируют в себе работу с одним тестовым объектом. Это позволяет лучше группировать связанные тесты, убирать повторы кода.
- типизированные тесты нужны для проверки работы одного и того же кода на корректность работы с разными типами данных.
- параметрические тесты для проверки работы одного и того же кода на корректность работы с разными значениями данных.





Оры:
- применяет мокирование интерфейсов для тестирования программ.
- применяет фаззи тестирование для поиска нетривиальных ошибок

Структура:
- Мокирование интерфейсов и тестирование бизнес-логики.
- Сниппет
- Фаззи тестирование
- Сниппет


## Введение

Сегодня мы рассмотрим несколько продвинутых техник тестирования. Вы узнаете:
- как тестировать бизнес-логику приложений.
- зачем тестировать код рандомными значениями.

##  Мокирование интерфейсов и тестирование бизнес-логики

Бизнес-логика — это часть программы, которая реализует реальные правила и процессы предметной области, а не технические детали. Это "мозг" приложения, где происходят ключевые решения.

Простой пример. Для ПО банкомата бизнес-логика - это проверка баланса, начисление комиссии, проверка лимитов снятия. Как именно данные хранятся в БД или отображаются на экране - это вопросы за гранью бизнес-логики.

Бизнес-логика не зависит от конкретной реализации, она зависит лишь от интерфейсов. Например, возьмем класс RateLimiter:

```cpp
class IRateLimiterCache {
public:
    virtual ~IRateLimiterCache() = default;
    
    // Добавляет запись о запросе с текущим временем
    virtual void AddRequest(const std::string& key, 
                          std::chrono::system_clock::time_point timestamp,
                          std::chrono::seconds window) = 0;
    
    // Возвращает количество запросов в последнем окне
    virtual int GetRequestCount(const std::string& key,
                              std::chrono::system_clock::time_point now,
                              std::chrono::seconds window) = 0;
};

class RateLimiter {
public:
    RateLimiter(std::unique_ptr<IRateLimiterCache> cache, 
               int max_requests, 
               std::chrono::seconds window)
        : cache_(std::move(cache)), 
          max_requests_(max_requests), 
          window_(window) {}

    bool AllowRequest(const std::string& user_id) {
        auto now = std::chrono::system_clock::now();
        std::string key = "rate_limit:" + user_id;

        // Получаем количество запросов в текущем окне
        int count = cache_->GetRequestCount(key, now, window_);
        
        if (count >= max_requests_) {
            return false;
        }

        // Добавляем запись о текущем запросе
        cache_->AddRequest(key, now, window_);
        return true;
    }

private:
    std::unique_ptr<IRateLimiterCache> cache_;
    int max_requests_;
    std::chrono::seconds window_;
};
```

Для каждого запроса конкретного пользователя он определяет, не совершил ли он слишком много запросов в единицу времени. И в зависимости от этого позволяет обрабатывать запрос или нет.

Информация о том, когда пользователь сделал свои запросы, хранится в кэшэ, который определяется интерфейсом IRateLimiterCache. У него есть метод получения количества запросов данного клиента за определенное время и метод добавления запроса в кэш.

Кэш может быть реализован по-разному. В различных сценариях это может быть самописаный in-memory кэш, Redis или Postgres. Но RateLimiter'у не важно, где конкретно хранится информация о запросах. Он фокусируется на функциональности продотвращения ddos атак.

Как правильно писать тесты на такой класс?

Ведь реализаций кэшей может быть много, и не у всех из них просто добиться в тестах какого-то нестандартного поведения. Плюс нам бы хотелось протестировать функциональность лимитера отдельно от реализаций, чтобы разграничить проверки и четко понимать, где проблема.

Тестировать бизнес-логику отдельно можно с помощью мокирования интерфейсов и gmock.

Мок интерфейса - это его наследник, для методов которого можно задать ожидания того, с какими значениями вызовется метод или какое значение он будет возвращать.

Таким образом, мокируя интерфейс, мы можем воспроизводить любые возможные ситуации и корнер-кейсы и тестировать бизнес-логику в самых необычных обстоятельствах.

Давайте замокируем интерфейс IRateLimiterCache:

```cpp
#include <gmock/gmock.h>

class MockRateLimiterCache : public IRateLimiterCache {
public:
    MOCK_METHOD(void, AddRequest, 
               (const std::string&, 
                std::chrono::system_clock::time_point,
                std::chrono::seconds), (override));
    
    MOCK_METHOD(int, GetRequestCount,
               (const std::string&,
                std::chrono::system_clock::time_point,
                std::chrono::seconds), (override));
};
```

Давайте на нашем примере посмотрим, какие шаги нужно сделать, чтобы написать мок-интерфейс:

1. Создайте класс `MockRateLimiterCache`, унаследованный от `IRateLimiterCache`.
2. Возьмите виртуальную функцию из `IRateLimiterCache` .
3. В секции `public:` дочернего класса напишите макрос `MOCK_METHOD()`.
4. Самое интересное: возьмите сигнатуру функции, скопируйте её в макрос и добавьте запятые между именем функции, ее возвращаемым значением и списком аргументов
5. Для const-методов добавьте 4-й параметр `(const)` (скобки обязательны).
6. Рекомендуется добавить ключевое слово `override`:
    - Для const-методов: `(const, override)`
	- Для не-const методов: `(override)`  
7. Повторите для всех виртуальных функций, которые нужно замокать.  
    (Само собой, все pure virtual методы абстрактного класса должны быть либо замоканы, либо переопределены.)

Реализация мока должна лежать в проекте в том же месте, где хранятся реальные реализации интерфейсов.

Как только вы замокали интерфейс, пора переходить к написанию теста:

1. Создайте мок-объект.
2. Установите ожидания (expectations) на этот объект:  
	- Сколько раз будет вызван метод?  
	- С какими аргументами?  
	- Что он должен вернуть?  
3. Выполните тестируемый код, использующий моки; при необходимости проверьте результат с помощью утверждений (assertions) из Google Test. Если метод мока вызывается чаще, чем ожидалось, или с неправильными аргументами, вы сразу получите ошибку.
4. Когда мок-объект уничтожается, gMock автоматически проверит, выполнены ли все установленные на него ожидания.

```cpp
using ::testing::Return;

TEST(RateLimiterTest, FirstRequestAllowed) {
    // 1. Подготовка
    RateLimiter limiter(std::make_unique<MockRateLimiterCache>(), 10, std::chrono::seconds(60));
    
    auto test_time = std::chrono::system_clock::now();
    
    // 2. Ожидания (expectations)
    EXPECT_CALL(cache, GetRequestCount("rate_limit:user1", test_time, std::chrono::seconds(60)))
        .WillOnce(Return(0)); // Возвращаем 0 запросов
        
    EXPECT_CALL(cache, AddRequest("rate_limit:user1", test_time, std::chrono::seconds(60)));
    
    // 3. Действие + проверка
    EXPECT_TRUE(limiter.AllowRequest("user1"));
}
```

В примере мы ожидаем, что вызов метода лимитера `limiter.AllowRequest("user1")` приведет к вызову метода мока GetRequestCount с аргументами "rate_limit:user1", test_time, std::chrono::seconds(60). Если это ожидание оправдается, что мы говорим, чтобы мок единожды вернул 0. Также мы ожидаем, что обновится информация в кэше с помощью вызова метода AddRequest с определенным набором аргументов.


В gMock мы используем макрос `EXPECT_CALL()`, чтобы задать ожидание для метода mock-объекта. Его следует интерпретировать как ожидание будущего вызова, а не как проверку уже произошедшего вызова. Вы устанавливаете то, как вы ожидаете бизнес-логика будет вызывать интерфейсные методы и, потенциально, задаете этим вызовам нужные вам возвращаемые значения. Общий синтаксис выглядит так:

```cpp
EXPECT_CALL(mock_object, method(matchers))
    .Times(cardinality)
    .WillOnce(action)
    .WillRepeatedly(action);
```

Макрос принимает два аргумента: сначала mock-объект, а затем метод и его аргументы. Обратите внимание, что они разделены запятой (`,`), а не точкой (`.`)  Если метод не перегружен, макрос можно вызвать без матчеров:

```cpp
EXPECT_CALL(mock_object, non-overloaded-method)
    .Times(cardinality)
    .WillOnce(action)
    .WillRepeatedly(action);
```

Такой синтаксис позволяет тестировщику указать «вызов с любыми аргументами», не задавая их количество или типы явно. Чтобы избежать неоднозначности, этот синтаксис можно использовать только для методов, которые не перегружены.

Этот синтаксис разработан так, чтобы ожидание читалось как обычное предложение. Например, вы наверняка догадаетесь, что

```cpp
using ::testing::Return;

EXPECT_CALL(object, GetX())
    .Times(5)
    .WillOnce(Return(100))
    .WillOnce(Return(150))
    .WillRepeatedly(Return(200));
```
означает, что метод `GetX()` объекта `object` будет вызван пять раз: первый раз вернёт `100`, второй — `150`, а затем при каждом следующем вызове — `200`. Некоторые называют такой стиль синтаксиса _предметно-ориентированным языком_ (DSL, Domain-Specific Language).

Любая из форм макроса может сопровождаться необязательными уточнениями, которые дают дополнительную информацию об ожидании. 

```cpp
EXPECT_CALL(cache, GetRequestCount);
```

В этом случае говорит, что просто ожидается вызов метода GetRequestCount, причем неважно с какими аргументами.

```cpp
EXPECT_CALL(cache, GetRequestCount);
```

В этом случае говорит, что просто ожидается вызов метода GetRequestCount, причем неважно с какими аргументами.

Также можно только для конкретных параметров указать ожидаемые значения, а остальные неважно какими будут:

```cpp
using ::testing::_;
EXPECT_CALL(cache, GetRequestCount("rate_limit:user1", _, _)); // неважно с каким текущим временем и размером окна вызван метод, главное, чтобы ключ совпадал.
```

Можно задавать и более экзотические ограничения:

```cpp
using ::testing::Ge;
EXPECT_CALL(cache, GetRequestCount("rate_limit:user1", _, Ge(std::chrono::seconds(50)))); // третий аргумент должен быть боле чем 50 секунд
```

Давайте посмотрим на еще несколько тестов лимитера:

```cpp
using ::testing::Throw;

TEST(RateLimiterTest, DeniesRequestWhenOverLimit) {
    MockRateLimiterCache cache;
    RateLimiter limiter(&cache, 10, std::chrono::seconds(60));
    
    auto test_time = std::chrono::system_clock::now();
    
    // Возвращаем количество запросов, равное лимиту
    EXPECT_CALL(cache, GetRequestCount("rate_limit:user1", _, _))
        .WillOnce(Return(10));
        
    // Не должно быть вызова AddRequest
    EXPECT_CALL(cache, AddRequest).Times(0);
    
    EXPECT_FALSE(limiter.AllowRequest("user1"));
}

TEST(RateLimiterTest, HandlesCacheFailureGracefully) {
    MockRateLimiterCache cache;
    RateLimiter limiter(&cache, 10, std::chrono::seconds(60));
    
    // Эмулируем сбой при получении количества запросов
    EXPECT_CALL(cache, GetRequestCount(_, _, _))
        .WillOnce(Throw(std::runtime_error("Cache unavailable")));
    
    // получаем то же исключение, потому что не обрабатываем исключения
    EXPECT_THROW(limiter.AllowRequest("user1"), std::runtime_error);
}
```

Видно, что gmock в сочетании с gtest - очень мощная связка для полноценного тестирования бизнес-логики.

Более подробно про мокирование вы можете прочитать [здесь](https://google.github.io/googletest/reference/mocking.html) 

## Fuzz тестирование

Фаззинг-тестирование — это не просто ещё одна методика QA, а принципиально иной подход к обеспечению надёжности программного обеспечения. В отличие от традиционного тестирования, где разработчик проверяет заранее определённые сценарии, фаззинг имитирует действия злоумышленника или хаотичное воздействие среды на программу.

Почему это критически важно в современной разработке?

Современные системы стали настолько сложными, что человек физически не может предугадать все возможные состояния системы

Плюс ко всему классические unit-тесты часто проверяют "как должно быть", а не "что может пойти не так".

Фаззинг решает эти проблемы через три фундаментальных принципа:
1. Автоматическая генерация входных данных (случайных и не полностью случайных)
2. Непрерывное выполнение (часы и дни работы вместо ручных проверок)
3. Обратная связь через покрытие (умные фаззеры генерируют такие данные, чтобы были покрыты все ветки кода)

Посмотрим, как проводить фаззи-тестирование с помощью библиотеки libFuzzer.

Для начала нам нужна проблемная функция:

```cpp
// Уязвимая функция с переполнением буфера
void buffer_overflow(uint8_t* input, size_t size) {
    char buffer[16];  // Фиксированный буфер
    
    // УЯЗВИМОСТЬ: Копирование без проверки размера
    for (size_t i = 0; i < size; ++i) {
        buffer[i] = input[i];  // Переполнение при size > 16
    }
}
```

В ней есть ряд серьезных проблем, которые мы попробуем найти с помощью libFuzzer.

LibFuzzer полностью контролирует:
- Генерацию тестовых данных— автоматически создаёт различные входные данные (случайные, но не полностью случайные)
- Цикл выполнения — многократно вызывает вашу функцию (тысячи или миллионы раз)
- Остановку — завершает процесс при обнаружении краша или по таймауту

Для того чтобы использовать эту библиотеку достаточно написать примерно такой код:

```cpp
// Точка входа для libFuzzer
extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
    buffer_overflow(const_cast<uint8_t*>(data), size);  // Явный краш при size > 16
    return 0;
}
```

Для каждого вызова `LLVMFuzzerTestOneInput` libFuzzer мутирует предыдущие "удачные" входные данные (те, что дали новое покрытие кода), подбирает размер(size) — начиная с 1 байта и постепенно увеличивает, оптимизирует данные на основе покрытия кода.

libFuzzer плотно взаимодействует с санитайзерами. От SanitizerCoverage он получает информацию о покрытии кода, а через ASAN/UBSAN - информацию о проблемах в коде.

Для минимального запуска нашего примера нужно скомпилировать и запустить программу с функцией LLVMFuzzerTestOneInput так:

```
clang -g -fsanitize=fuzzer,address fuzz_test.cpp -o fuzzer
./fuzzer -max_total_time=10 -rss_limit_mb=256 -max_len=100
```

libFuzzer работает только с clang и предоставлется через санитайзер fuzzer. Для поиска ошибок работы с памятью, мы дополнительно используем  address sanitizer.

При запуске теста вы указываете максимальное время работы теста, максимальное количество занимаемой оперативной памяти и максимальную длину входных строк. После этого fuzzer начинает генерировать большое количество рандомных строк и  проверять работу кода с помощью этих строк.

В результате вы можете увидеть такой вывод:

```
==1468224==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x76d22801e4f0 at pc 0x5e2e52b9fe8e bp 0x7ffe9f3ebd50 sp 0x7ffe9f3ebd48
WRITE of size 1 at 0x76d22801e4f0 thread T0
#0 0x5e2e52b9fe8d in buffer_overflow(unsigned char*, unsigned long) fuzz_test.cpp:11:19
    #1 0x5e2e52b9ff80 in LLVMFuzzerTestOneInput fuzz_test.cpp:17:5
    #2 0x5e2e52aa457a in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) 
// далее стек вызовов
```

AddressSanitizer точно указал на проблему в функции buffer_overflow при выходе за границы массива.



**Кнопка**: К итогам!

## Итоги

В этом уроке вы узнали:

- gmock позволяет изолировано тестировать бизнес-логику модулей приложения с помощью мокирования интерефейсов и определения ожиданий при вызове методов мока в тестах.
- фаззи-тестирование помогает выявлять нетривиальные проблемы в коде за счет большого количества случайных входных данных. Его можно проводить с помощью libFuzzer, который работает с сочетании с санитайзерами.