
ОРы:
- понимает как устроен мьютекс изнутри
- понимает мотивацию к std::atomic
- понимает что такое spinlock
- понимает ситуации взаимных блокировок livelocks

- применяет std::atomic для реализации спинлока


Структура:

- Показываем базовый пример защиты данных мьютексом. Говорим, что в начале поток получает эксклюзивный доступ, а затем потоки, которые хотят захватить занятый лок, отправляются спать . В этом уроке будем говорить про получение эксклюзивного доступа.
- Пробуем написать получение эксклюзивного доступа с помощью обычной переменной. Показываем пример, как можно зашедулить потоки, чтобы оба потока получили доступ к локу.
- Вся проблема в том, что в любой момент исполнение текущего потока может прерваться и другой поток может нарушить логику последовательного исполнения команд.
- Нужна такая инструкция, которая бы одновременно читала изменяла и записывала бы значения в переменную, чтобы другие потоки не смогли "увидеть" промежуточное состояние. Это можно сделать с помощью атомиков и конкретно std::atomic_exchange.
- Если мы не отправляем потоки спать, до использовав в функции получения эксклюзивного доступа std::atomic_exchange, мы получим полноценный механизм взаимного исключения - спинлок. Особенность спинлоков - активное ожидание и активное использование cpu.
- У спинлоков, как и у мьютексов тоже могут быть проблемы при попытке блокировать нескольких замков. Показываем пример, когда потоки берут по одному спинлоку, пытаются взять второй и при неудачной попытке - освобождают свои спинлоки. Таким образом потоки не перестают работать, но исполнение программы никуда не продвигается. Такая ситуация называется спинлок.

## Введение

В одном из прошлых уроков вы уже изучили, что std::mutex может помочь синхронизировать доступ потоков к общему ресурсу. Сегодня мы посмотрим, что лежит под капотом std::mutex. Вы узнаете:

- как устроен std::mutex изнутри
- что такое атомарные операции и какая у них роль в реализации мьютекса
- что такое спинлок и как он позволяет организовать взаимное исключение потоков
- какая проблема может возникнуть при использовании спинлоков.

Контент

## Эксклюзивный доступ

Посмотрим еще раз на то, как можно использовать std::mutex. Напишем упрощенную версию потокобезопасной std::map:

```cpp
template<Key, Value>
class ThreadSafeMap {
	std::mutex mtx;
	std::map<Key, Value> map;
public:
	void Insert(const Key& key, const Value& value) {
		std::lock_guard lg{mtx};
		map.insert(key, value);
	}

	Value& Get(const Key& key) {
		std::lock_guard lg{mtx};
		return map[key];
	}
};

ThreadSafeMap map;
std::vector<std:thread> vec;
for (int i = 0; i < 4; i++) {
	vec.emplace_back(&ThreadSafeMap::Insert, &map, std::to_string(i), i);
}
```

Вызов каждого метода мапы ограждается с помощью мьютекса. И когда мы пытаемся в нескольких потоках вставить значения в мапу, эти вставки происходят строго упорядоченно: только один поток в один момент времени производит вставку элемента в мапу. Вот вкратце, как мьютекс ограничивает доступ к ресурсу:

- Несколько поток пытаются одновременно захватить мьютекс, но получается это только у одного потока. Этот поток получает эксклюзивный доступ к ресурсу.
- Исполнение остальных потоков приостанавливается(блокируются) до тех пор, пока мьютекс не будет освобожден.

В этом уроке нас будет интересовать детали процесса, в результате которого поток получает эксклюзивный доступ к ресурсу. 

Давайте попробуем написать свою функцию блокирования lock:

```cpp
bool locked;  
void lock() {  
	while(locked){  
		// здесь каким-то образом блокируем потоки..  
	}  
	// Точка А
	locked = true;  
}
```

Все просто и логично: если флаг locked поднят, то поток уходит внутрь цикла и блокируется. Если флаг опущен, то поток захватывает мьютекс.

Есть ли в этом коде проблема?

*Практикум* Есть ли в этом коде проблема?

*Студент* Хочу узнать ответ.

Предположим, что locked == false, поток A вызвал lock(), пропустил цикл и прервал свое выполнение в точке А(см. код), не дойдя до конца функции. Сразу после этого поток B вызвал lock(), также проверяет переменную locked, поскольку она равна false, он устанавливает locked = true. Затем поток В прерывается и управление возвращается к потоку A. Поскольку мы были заблокированы на строке A, он возобновляет работу со строки A и устанавливает locked = true. 

Получили большую проблему. Теперь у нас есть два потока, удерживающих блокировку!

Мы пытались избежать гонки данных с помощью мьютекса, но в итоге сам мьютекс реализовали с гонкой данных.

Конечно же такого не должно быть. Реализация блокировки мьютекса должна учитывать то, что потоки могут в любой момент прерываться.  Нужно даже более сильное требование: так как исполнение каждого потока независимо от других потоков, нужно, чтобы ни один поток не видел результаты промежуточных вычислений других потоков. В этом случае нам каким-то образом нужно одновременно читать, изменять и записывать значение переменной. 

*Студент* Разве такие инструкции есть?

*Практикум* Есть!

## Атомарные операции

В С++ существуют так называемые атомарные переменные и атомарные операции. Атомарная операция - это операция, у которой нет промежуточных результатов. Такие операции реализуются с помощью специальных инструкций процессора. Существует множество атомарных операций и атомарных типов, мы их будем подробно разбирать в будущих уроках. Сейчас сфокусируемся на решении проблемы эксклюзивного доступа.

Мы затребовали операцию, которая бы одновременно читать, изменять и записывать значение булевого поля locked.

Для этого нам нужно сделать 2 вещи:

1. Вместо типа bool нужно использовать std::atomic\<bool>. Вкратце std::atomic - это шаблонный класс-обертка для стандратных тривиальных типов, которая позволяет выполнять над ними атомарные операции.
2. Использовать read-modify-write операцию-метод класса std::atomic exchange. Этот метод заменяет старое значение переменной на новое и возвращает старое значение. 

Применим эти изменения в коде:

```cpp
// используем атомарный тип
std::atomic<bool> locked = false;

void lock() { 
	// используем ead-modify-write операцию exchange
	while (locked.exchange(true)) {
		// здесь каким-то образом блокируем потоки.. 
	} 
}
```

Посмотрим, что в этом случае будет происходить:

1. Первый поток заходит в функцию и за раз устанавливает значение переменной locked так, что ни один поток, даже вошедший в lock на мгновение позже, не сможет захватить ресурс. За счет того, что exchange возвращает предыдущее значение переменной, условие входа в цикл для первого потока не выполняется и он успешно выходит из функции.
2. Все остальные потоки, вошедшие в lock, входят в цикл, так как exchange(true) возвращает true, если locked уже занят другим потоком.
3. Только после того, как основной поток установит значение locked в false, другие потоки смогут побороться за владение ресурсом.

При таком раскладе гонки данных нет и доступ к ресурсам корректно синхронизирован.

## Spinlock

В наших реализациях блокировок мы предполагаем, что потоки каким-то образом блокируются и уходят в сон. Однако, что будет, если потоки не будут блокироваться? Оставим предыдущий пример кода совсем без тела цикла:

```cpp
std::atomic<bool> locked = false;

void lock() { 
	while (locked.exchange(true));
}
```

Поздравляем, вы научились писать spinlock(спинлок).

Спинлок - это примитив синхронизации, который так же, как мьютекс, обеспечивает механизм взаимного исключения. Однако вместо того, чтобы ждущие потоки блокировались, они постоянно крутятся в цикле и не засыпают. В этом случае они активно тратят ресурс cpu до тех пор, пока блокировка не освободится.

Спинлок можно функционально использовать вместо мьютекса:

```cpp
class Spinlock{...};

template<Key, Value>
class ThreadSafeMap {
	Spinlock sl;
	std::map<Key, Value> map;
public:
	void Insert(const Key& key, const Value& value) {
		std::lock_guard lg{sl};
		map.insert(key, value);
	}

	Value& Get(const Key& key) {
		std::lock_guard lg{sl};
		return map[key];
	}
};

ThreadSafeMap map;
std::vector<std:thread> vec;
for (int i = 0; i < 4; i++) {
	vec.emplace_back(&ThreadSafeMap::Insert, &map, std::to_string(i), i);
}
```

Однако нужно быть осторожными при использовании спинлоков, так как это заметно может отразится на производительности приложения и в целом хост-машины. Если у вас будет много потоков крутится в горячем цикле(цикл, итерации которого выполняются очень часто), ваше приложение не будет делать полезную работу и будет мешать другим приложениям на той же машине выполнять свою работу.

Поэтому спинлоки используют тогда, когда временные затраты на блокирование потока и его пробуждение ощутимо ниже, чем ожидание в горячем цикле.

## Livelock

Но пустая трата процессорного времени на ожидание может принимать причудливые формы. Давайте рассмотрим код, в котором 2 потока пытаются захватить 2 спинлока. В обычном исполнении это приводит к дедлоку, поэтому в случае, если потоку не удалось захватить второй спинлок, он отпускает уже захваченный лок:

```cpp
#include <atomic>
#include <chrono>
#include <iostream>
#include <thread>
#include <print>

std::atomic<bool> lock1 = false;
std::atomic<bool> lock2 = false;

// Поток 1: захватывает lock1, затем пытается захватить lock2
void thread1_work() {
	while (true) {
		// Захватываем lock1
		while (lock1.exchange(true));
		std::println("Thread 1 has acquired lock1, try to acquire lock2...");
		// Пытаемся захватить lock2
		if (!lock2.exchange(true)) {
			// Успешно захватили оба лока!
			std::println("Thread 1 has acquired both locks!");
			lock2 = false;
			lock1 = false;
			break;
		} else {
			// Не получилось, отпускаем lock1 и пробуем снова
			std::println("Thread 1 failed to acquire lock2, release lock1...");
			lock1 = false;
		}
	}
}

// Поток 2: захватывает lock2, затем пытается захватить lock1
void thread2_work() {
	while (true) {
		// Захватываем lock2
		while (lock2.exchange(true));
		std::println("Thread 2 has acquired lock2, try to acquire lock1...");
		// Пытаемся захватить lock1
		if (!lock1.exchange(true)) {
			// Успешно захватили оба лока!
			std::println("Thread 2 has acquired both locks!");
			lock1 = false;
			lock2 = false;
			break;
		} else {
			// Не получилось, отпускаем lock2 и пробуем снова
			std::println("Thread 2 failed to acquire lock1, release lock2...");
			lock2 = false;
		}
	}
}

int main() {
	std::jthread t1(thread1_work);	
	std::jthread t2(thread2_work);
}
```

Попробуйте несколько раз запустить этот код на своей машине. Результат может зависеть от вашей конкретной машины и случайных факторов шедулинга потоков. Но вы можете заметить одну особенность: какое-то время потоки пытаются захватить оба спинлока, у них не получается, отпускают первый лок и так много-много раз по кругу. То есть потоки активно исполняют код, тратят ресурс cpu, но по факту в программе никакого прогресса не происходит. Такая ситуация, при которой потоки активно исполняют код, но прогресса в программе не происходит, называется livelock. То есть это такая блокировка, при которой потоки не "умерли", а продолжают активно жить, но при этом ничего полезного не происходит.

Нужно помнить об этой проблеме при использовании спинлоков и, в целом, атомарных операций и проектировать код так, чтобы минимизировать вероятность появления livelock'ов.

**Кнопка**: К итогам!

## Итоги


В этом уроке вы узнали:

- внутри std::mutex используются атомарные операции, чтобы обеспечить корректную синхронизацию данных между потоками при получении ими эксклюзивного доступа к ресурсу.
- атомарные операции обладают свойством неделимости: ни один поток не может увидеть промежуточный результат такой операции. Существует атомарная операция, которая может одновременно читать, модифицировать и записывать значение атомарной переменной - exchange.
- спинлок - примитив синхронизации, который обеспечивает свойство взаимного исключения.
- спинлок отличается от мьютекса тем, что ожидающие потоки не блокируются, а активно крутятся в цикле ожидания.
- при использовании спинлоков и атомарных переменных может возникнуть livelock - ситуация, при которой потоки активно совершают какую-то работу, но никакого прогресса в них не происходит. 




