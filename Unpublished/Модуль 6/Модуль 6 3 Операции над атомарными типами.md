
ОРы:
- применяет функции стандартной библиотеки для работы с атомарными целыми типами данных

Структура:

Довольно короткий урок получается, который нужен больше, чтобы познакомить студентов с большим количеством read-modify-write операций. Плюс показать, что для всех методов атомиков существуют свободные атомарные функции.

- второй важный тип инстанциаций std::atomic - атомарные числа.
- повторяем методы store, load, exchange, compare_exchange
- для чисел также появляются новые rmw методы - fetch_add и fetch_sub. Они читают, изменяют значение атомика на переданную величину и записывают результат в атомик.
- В С++26 появились fetch_max и fetch_min, которые записывают в атомик результат std::max и std::min от значения атомика и аргумента.
- В стандартной библиотеке также есть свободные функции для работы с атомарными переменными. Они полностью повторяют методы класса std::atomic и нужны для совместимости с сишными свободными функциями. Приводим примеры для операций, которые есть в базовом шаблоне, и для операций над числовыми типами.


## Введение

В прошлом уроке мы рассмотрели атомарные булевы переменные. Сегодня черед атомарных целочисленных переменных. Вы узнаете:

- какие дополнительные методы класса std::atomic есть для целочисленных типов.
- какие свободные функции для работы с атомарными переменными есть в стандартной библиотеке.

## Целочисленные атомарные переменные

В качестве атомарных переменных обычно используют не так много типов. Целочисленные переменные занимают важное место в этом списке.

Все, что мы будем обсуждать в этом уроке верно для любых целочисленных типов: char, signed, unsigned, size_t и тд. Однако для простоты все примеры мы будем рассматривать для `std::atomic<int>`.

Кратко пройдемся по известным нам операциям над std::atomic применительно к типу int:

```cpp
std::atomic<int> value{0}; // обязательна инициализация, так как по умолчанию инициализируется в неопределенное состояние

assert(value.is_lock_free() == true); // на большинстве популярных платформ неблокирующие опереации для int возможны

assert(value.load() == 0); // читаем значение переменной с помощью метода load

value.store(42); // записываем значение с помощью store

assert(value == 42); // у каждой инстанциации std::atomic определен оператор приведения к типу шаблонного параметра, благодаря которому можно читать значение и не использовать явно метод load

value = 100500; // также перегружен оператор присваивания, который позволяет записывать значения в атомик с помощью привычного синтаксиса

assert(value.exchange(69) == 100500); // метод exchange заменяет старое значение на новое и возвращает старое
assert(value == 69);

value = 10;
int expected = 10;

// Пытаемся заменить 10 на 20
bool success = value.compare_exchange_strong(expected, 20); // методы вида compare_exchange_* сравнивают текущее значение переменной с ожидаемым значением и возвращают результат проверки. Если условие выполняется, методы подменяют текущее значение на новое значение. В обратном случае записывают в ожидаемое значение текущее значение переменной
  
assert(success = true); // так как expected совпадает с текущим значением value, сравнение и замена проходят успешно
assert(value.load() == 20); // замена прошла успешно
assert(expected == 10); // в этом случае ожидаемое значение не меняется

expected = 30; // ставим ожидаемое значение не такое, как текущее значение value

success = value.compare_exchange_strong(expected, 40); // пытаемся заменить значение атомика, когда expected не совпадает с текущим значением

assert(success == false); // сравнение завершилось неудачей
assert(value.load() == 20); // значит текущее значение value осталось неизменным
assert(expected == 20); // однако изменилось значение expected
```

- load и operator int возвращают текущее значение переменной.
- store и operator= присваивают переменной указанное значение.
- exchange заменяет текущее значение переменной на указанное и возвращает старое значение.
- compare_exchange условно заменяет текущее значение переменной и записывает старое значение в expected


## Дополнительные методы

У std::atomic есть методы, которые специализированы только для целочисленных типов. Все методы, которые мы будем перечислять в этом блоке можно использовать и для `std::atomic<bool>`, так как bool считается по стандарту целочисленными типом. В прошлом уроке мы решили о них не рассказывать, чтобы сразу не нагружать большим количеством информации. Да и некоторые методы не совсем актуальны для использования с типом bool.

Вы можете увиличивать или уменьшать значение атомика с помощью методов fetch_add и fetch_sub:

```cpp
std::atomic<int> value{0};

assert(value.fetch_add(5) == 0); // fetch_add увеличивает значение переменной и возвращает старое значение
assert(value.load() == 5);

assert(value.fetch_sub(5) == 5); // fetch_sub уменьшает значение переменной и возвращает старое значение
assert(value.load() == 0);
```

Операции fetch_add и fetch_sub считаются read-modify-write операциями, так как они одновременно читают переменную, изменяют и записывают ей новое значение.

Вы можете инкрементировать и декрементировать значение атомика с помощью привычных операторов:

```cpp
std::atomic<int> value{0};
assert(value++ == 0); // постинкремент возвращает старое значение и увеличивает текущее значение на единицу
assert(value == 1);

assert(++value == 2); // преинкремент увеличивает старое значение на единицу и возвращает новое значение
assert(value == 2);

assert(value-- == 2); // постдекремент возвращает старое значение и уменьшает текущее значение на единицу
assert(value == 1);

assert(--value == 0); // предекремент уменьшает старое значение на единицу и возвращает новое значение
assert(value == 0);
```

Они тоже считаются RMW операциями.

Также есть бинарные RMW операции: fetch_and, fetch_or, fetch_xor.

```cpp
std::atomic<int> value{0};

assert(value.fetch_or(5) == 0); // fetch_or выполняет побитовую операцию | и возвращает старое значение
assert(value == 5);
assert(value.fetch_or(12) == 5);
assert(value == 13); // 5 | 12 == 0101 | 1100 == 1101 == 13

assert(value.fetch_and(6) == 13); // fetch_and выполняет побитовую операцию & и возвращает старое значение
assert(value == 4); // 13 & 6 == 1101 & 0110 == 0100 == 4

assert(value.fetch_xor(15) == 4); // fetch_xor выполняет побитовую операцию ^ и возвращает старое значение
assert(value == 11); // 15 ^ 4 == 1111 ^ 0100 == 1011 == 11
```


В С++26 также добавили методы fetch_max и fetch_min, которые могут атомарно заменять текущее значение переменной на результат std::max и std::min с переданными значениями. Возвращают они также предыдущее значение:

```cpp
std::atomic<int> value{0};

assert(value.fetch_max(100) == 0); // fetch_max присваивает старому значению атомика результат std::max от старого и переданного значения и возвращает старое значение

assert(value.fetch_max(10) == 100);
assert(value == 100);

assert(value.fetch_min(0) == 100); // fetch_min присваивает старому значению атомика результат std::min от старого и переданного значения и возвращает старое значение

assert(value.fetch_min(10) == 0);
assert(value == 0);
```

Не забываем про методы нотификации и ожидания:

```cpp
std::std::atomic<int> data{0};

void producer() {
	data.store(42);
	data.notify_one(); // уведомляем ждущий поток об изменении данных
}

void consumer() {
	data.wait(0); // ждем уведомления
	assert(data == 42); // после пробуждения увидим новое значение
}
```


## Свободные атомарные функции

Помимо методов класса std::atomic, выполнять атомарные операции вы можете с помощью свободных функций, имеющих такую форму названий std::atomic_{метод_класса_std::atomic}.

Каждая такая функция полностью повторяет семантику соответствующего метода из класса std::atomic. В стандартную библиотеку они были введены для совместимости с аналогичными функциями из С стандарта. Так как в С нет классов и оперировать структурами можно только через функции, каждая свободная функция для выполнения атомарных операций в С имеет функцию-брата с тем же названием в С++.

Коротко применим несколько этих функций, так как по функционалу они ничем не отличаются от методов std::atomic. Основное отличие - первым аргументом передается указатель атомарной переменной.

```cpp
std::atomic<int> value(42);

// Атомарно загружаем значение
assert(std::atomic_load(&value) == 42);  // Аналог value.load()

// Атомарно записываем новое значение
std::atomic_store(&value, 100);  // Аналог value.store(100)
assert(std::atomic_load(&value) == 42);

// Атомарно добавляем 5
assert(std::atomic_fetch_add(&value, 5) == 42);  // Аналог counter.fetch_add(5)

// Атомарно заменяем значение и возвращаем старое
assert(std::atomic_exchange(&value, 50) == 47);  // Аналог value.exchange(50)
assert(std::atomic_load(&value) == 50);

int expected = 30; // ставим ожидаемое значение не такое, как текущее значение value
bool success = std::atomic_compare_exchange_strong(&value, &expected, 40); // Аналог value.compare_exchange_strong(50), expected передается по указателю, а не по ссылке, для С совместимости
assert(success == false);
assert(expected == 50);

void producer() {
	std::atomic_store(&value, 42);
	std::atomic_notify_one(&value); // уведомляем ждущий поток об изменении данных
}

void consumer() {
	std::atomic_wait(&data, 0); // ждем уведомления
	assert(std::atomic_load(&value) == 42); // после пробуждения увидим новое значение
}
```

У всех функций вида std::atomic_{метод_класса_std::atomic} есть функции-"дублеры" `std::atomic_{метод_класса_std::atomic}_explicit`, которые выполняют ту же самую работу. С одним отличием. В них можно передать std::memory_order. Например:

```cpp
template< class T >
void atomic_store_explicit( std::atomic<T>* obj, typename std::atomic<T>::value_type desired, std::memory_order order) noexcept;
```

А разговор о том, что такое std::memory_order, мы начнем в следующем уроке вместе с погружением в пучину модели памяти С++.


**Кнопка**: К итогам!

## Итоги


В этом уроке вы узнали:

- для std::atomic с целочисленными шаблонными параметрами есть дополнительные методы для работы с числами: fetch_add, fetch_sub, fetch_max, fetch_min, fetch_or, fetch_and, fetch_xor, операторы инкремента и декремента.
- для каждого метода std::atomic существует свободная функция-аналог, которая делает ту же самую работу, только в качестве свободной функции. Они были добавлены в стандартную библиотеку для совместимости с С стандартом, в котором тоже есть функции, выполняющие атомарные операции.