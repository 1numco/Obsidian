Перейдите на раскрывающиеся чипы

- применяет `std::atomic<T>` для моделирования атомарности собственных типов
- применяет `std::atomic<std::shared_ptr>` для моделирования разделяемого владения атомарным образом

Структура:

- Говорим, что можно использовать атомарный шаблон с кастомными типами. Приводим короткий пример, рассказываем про ограничения в интерфейсе. Скорее всего такая инстанциация не будет атомарной, поэтому атомарные кастомные типы редко используются. (Ор: применяет `std::atomic<T>` для моделирования атомарности собственных типов)
- - Сниппет 1 отрисовка координат робота
- Проблема сложных типов в том, что их невозможно атомарно менять. Процессор в большинстве случаев имеет возможность атомарно оперировать только 8-мью байтами. А сложные типы и занимают больше места и даже банальные операции присваивания не могут происходить за один раз. (Ор: применяет `std::atomic<std::shared_ptr>` для моделирования разделяемого владения атомарным образом)
- Из этой ситуации есть выход - можно использовать атомарные указатели shared_ptr.
- В базовом варианте std::shared_ptr имеет только атомарный счетчик ссылок, то есть можно потокобезопасно читать, копировать и перемещать объект умного указателя. Однако изменение объекта - это непотокобезопасная операция.(Ор: применяет `std::atomic<std::shared_ptr>` для моделирования разделяемого владения атомарным образом)
- С этим помогает атомарный std::shared_ptr. Он позволяет целиком за раз подменить объект умного указателя, а вместе с ним и сам объект. Это возможно, потому что shared_ptr - это всего 2 указателя. Мы можем создать объект данных и завернуть его в std::shared_ptr и заменить глобальный указатель на указатель на этот новый объект. Это важный строительный блок lock-free структур данных, а которых будем говорить в следующем уроке.(Ор: применяет `std::atomic<std::shared_ptr>` для моделирования разделяемого владения атомарным образом)
- Сниппет 2 Атомарное обновление конфига.


## Введение

Шаблон атомарного типа можно использовать не только с фундаментальными типами, но и с кастомными. Сегодня вы узнаете:

- Какие ограничения накладываются на тип шаблонного параметра std::atomic
- Как какие ограничения на атомарность операций есть у кастомных типов
- Как обойти эти ограничения с помощью атомарного std::shared_ptr.


## Атомарные кастомные типы

std::atomic - это шаблон, поэтому его можно инстанцировать со множеством типов. Все фундаментальные типы входят в этот список. Но для кастомных типов есть определенные ограничения:
- они должны иметь конструктор копирования и копирующий оператор присваивания.
- эти и любые другие специальные методы должны быть тривиальными, то есть сгенерированы компилятором, а не предоставлены пользователем.
- все поля класса должны рекурсивно удовлетворять первым двум пунктам.

Это сокращает список кандидатов для формирования атомарных типов до простых структур, состоящих из фундаментальных типов.

```cpp
struct SimpleStruct {
	double float_number;
	int int_number;
	char character;
	
	auto operator<=>(const SimpleStruct& other) const = default;
};

SimpleStruct init{3.14, 42, 'a'};
std::atomic<SimpleStruct> a{init};

SimpleStruct expected{0.33, 15, 'z'};

assert(a.load() == init);

a.store(expected);
assert(a.load() == expected);

assert(a.exchange(init) == expected);

SimpleStruct new_value{2.71, 69, 'y'};
assert(!a.compare_exchange_strong(expected, new_value));
assert(a.load() == init);
assert(expected == init);

assert(a.compare_exchange_strong(expected, new_value));
assert(a.load() == new_value);
```

Конечно, для произвольного типа std::atomic будет предоставлять только базовый набор методов: is_lock_free, load, store, exchange, compare_exchange_weak, compare_exchange_strong, wait, notify_one, notify_all. Никаких методов `fetch_*`, которые подразумевают работу с числами.

В программировании без блокировок атомарные кастомные классы не получили широкого распространения. Основная причина - операции над такими типами 100% не будут неблокирующими. То есть в реализации этих операций будут использоваться различного рода блокировки, включая мьютексы.

Однако нам не обязатально менять сам объект класса атомарно.

## Атомарные указатели

Мы можем определить атомарный указатель и атомарно менять значение этого указателя, тем самым перенаправляя его на разные объекты. std::atomic можно инстанцировать с указателем любого типа и операции над этим указателем на современных платформах будут неблокирующими:

```cpp
std::atomic<int*> ptr = nullptr;

int a = 42;
int b = 100500;

ptr.store(&a);
assert(ptr.load() == &a);

assert(ptr.exchange(&b) == &a);
assert(ptr.exchange(&b) == &a);

// Можно использовать указатели на кастомные классы

SimpleStruct value1{3.14, 42, 'a'};
SimpleStruct value2{0.33, 15, 'z'};

std::atomic<SimpleStruct> struct_ptr{nullptr};

struct_ptr.store(&value1);
struct_ptr.exchange(&value2);
```

Но работая с указателями, вы неизбежно столкнетесь с динамическими аллокациями. 
Значит вам нужно следить за временем жизни объекта.

```cpp
std::atomic<SimpleStruct> struct_ptr{nullptr};

struct_ptr.store(new SimpleStruct{3.14, 42, 'a'});

auto old_ptr = struct_ptr.exchange(new SimpleStruct{0.33, 15, 'z'});
delete old_ptr;
```

Но что делать, если у нас много потоков могут читать атомарный указатель? Кто из них должен удалять объект? В какой момент времени этот кто-то может удалить объект?

На эти вопросы нет адекватного ответа в рамках обычных указателей.

## std::shared_ptr

В современном С++ проблема сложности отслеживания времени жизни объекта решается с помощью умных указателей. А в многопоточной среде выбор упадет на std::shared_ptr, который подразумевает разделенное владение объектом. Объект разрушится ровно в тот момент времени, когда на него не будет ссылок.

Можем ли мы безопасно пользоваться обычным std::shared_ptr в многопоточной среде?

Как вы помните, внутри `std::shared_ptr` находится контрольный блок с атомарными переменными для подсчёта сильных и слабых ссылок на объект:

```cpp
_Atomic_word use_count;   // #shared
_Atomic_word weak_count;  // #weak + (#shared != 0)
```

А сам объект std::shared_ptr состоит из двух указателей: на разделяемый объект и на контрольный блок:

```cpp
element_type * obj_ptr;             // Указатель на объект
shared_ref_count *  refcount;       // Указатель на счётчик ссылок
```

Подумайте, в каких случаях std::shared_ptr можно безопасно использовать в многопоточной среде?

**КНОПКА:** Покажи ответ

`std::shared_ptr` позволяет безопасно копировать и читать данные из разных потоков:

![[Pasted image 20250626203917.png]]

**Студент:** Практикум, объясни почему

**Практикум:** Копировать и читать данные из разных потоков безопасно по двум причинам:

---

1. Счётчики ссылок — атомарные переменные, поэтому создание и удаление `std::shared_ptr` не потребует дополнительной синхронизации, а значит, безопасны. Например, если два потока попытаются одновременно создать дополнительные экземпляры `std::shared_ptr`, придётся синхронизировать доступ к счётчику ссылок с помощью атомарных переменных.
2. Одновременное чтение данных из разных потоков не приводит к UB, поэтому `std::shared_ptr` не повлечёт использования атомарных переменных, мьютексов и других инструментов синхронизаци для чтения в многопоточной среде.

```c
auto ptr = std::make_shared<int>();

for (auto i = 0; i < 100; i++) {
    // Захватываем `ptr` по ссылке
    std::thread([&ptr] {
        auto safeOperation = ptr;  // Просто увеличение счётчика ссылок — безопасная операция
    }).detach();
}
```

Но если данные будут изменяться без синхронизации, то, согласно стандарту, это приведёт к гонке данных и UB:

```c
auto ptr = std::make_shared<int>();

for (auto i = 0; i < 100; i++) {
    // Захватываем `ptr` по ссылке
    std::thread([&ptr] {
        ptr = std::make_shared<int>();  // Одновременная запись в переменную из разных потоков — UB
    }).detach();
}
```

## std::atomic<std::shared_ptr>

Вышеизложенное касается обычного std::shared_ptr. Если обычные операции приводят к гонке данных, то атомарные операции решают эту проблему.

И в С++20 появилась отдельная специализация std::atomic для std::shared_ptr. Как конкретно в ней работают атомарные операции - это отдельная и сложная тема. Главное - возможно в неблокирующем режиме проводить атомарные операции над std::shared_ptr.

Эта специализации предоставляет весь базовый интерфейс std::atomic, но сейчас разберем сам принцип работы атомарного std::shared_ptr на примере методов чтения и записи. С их помощью можно потокобезопасно управлять атомиком шареного указателя:

- `std::shared_ptr load()` — создаёт объект класса `std::shared_ptr`, который можно использовать для чтения данных;
- `void store(std::shared_ptr newPtr)` — безопасно меняет указатель на счётчик ссылок и данные с текущего на `newPtr`. Это единственный способ безопасно обновить данные в атомарном умном указателе без использования `std::mutex` и других «долгих» инструментов.

```cpp
std::atomic<std::shared_ptr<const int>> atomicPtr = std::make_shared<int>();  // Создаём атомарный `shared_ptr`

for (auto i = 0; i < 100; i++) {
    // Захватываем `atomicPtr` по ссылке
    std::thread([&atomicPtr] {
        // Атомарно загружаем данные - безопасная операция
        auto safeOperation = atomicPtr.load();

        // *safeOperation =  5; - Такое изменение внутренних данных после чтения - небезопасная операция, приводящая к
        // UB в многопоточной среде

        // Безопасное обновление `atomicPtr`, поскольку внутри метода `store` доступ к данным будет синхронизирован
        atomicPtr.store(std::make_shared<int>());
    }).detach();
}
```

![[Pasted image 20250626205223.png]]
На схеме видно, что атомарным является именно указатель на контрольный блок и данные. То есть вы можете безопасно менять счётчики ссылок или читать данные по указателю, но изменять сами данные разрешено только с помощью метода `store()`. В противном случае получите UB, ведь никто не синхронизирует одновременный доступ к данным.

Таким образом, используя атомарный std::shared_ptr, вы:

- имеете возможность потокобезопасно изменять объекты кастомных классов, с помощью создания и сохранения нового объекта в указатель
- не беспокоитесь об цикле жизни объекта, он сам разрушится, когда больше не будет существовать ни одного потока, который имеет экземпляр std::shared_ptr, указывающий на этот объект.


**Кнопка**: К итогам!

## Заключение

В этом уроке вы узнали:

- Чтобы использовать кастомный тип, как шаблонный параметр std::atomic, он должен быть тривиально копируемым. Это ограничивает пулл типов до обычных структур.
- Хоть операции над такими типами будут атомарными, но они не будут неблокирующими.
- Можно использовать атомарные указатели на объекты кастомных типов. Операции над этими указателями будут атомарными и вы сможете подменять сами адреса объектов и таким образом атомарно изменять данные.
- С обычными атомарными указателями есть принципиальная проблема. Невозможно подобрать правильный момент для разрушения объекта и освобождения памяти.
- В С++ есть std::shared_ptr, который помогает не заботится о времени жизни объекта. К тому же эти умные указатели можно потокобезопасно копировать и читать из них данные. Однако присвоение нового указателя или изменения данных разделяемого объекта приводит к неопределенному поведению.
- Эту проблему решает атомарный std::shared_ptr, который может в неблокирующем режиме подменять указатели на контрольный блок и разделяемый объект. Таким образом мы имеем возможность атомарно управлять сложными объектами в многопоточной среде.