# Модуль 6 Проектная работа
# Финальный проект модуля — разработка диспетчера задач с приоритетами

- Модуль: 6 - Многопоточность и параллелизм
- Навык: умеет в многопоточном режиме исполнять задачи с различными приоритетами
- Проверяемые ОРы:
	- понимает ситуацию гонки данных между потоками(Весь проект)
	- применяет std::jthread для создания автоматически присоединяющегося потока (Реализация пула потоков)
	- применяет std::mutex для блокировки доступа к разделяемому ресурсу(реализация очередей)
	- применяет std::lock_guard для реализации RAII с мьютексом (реализация очередей)
	- применяет пул потоков для оптимизации программы (реализация пула потоков)
	- реализовывает многопоточную неограниченную очередь используя std::lock_guard (реализация неограниченной очереди)
	- реализовывает многопоточную ограниченную очередь, используя std::mutex вместе  с условными переменными / std::counting_semaphore   для ожидания доступа (реализация ограниченной очереди)
	- применяет std::atomic\<bool> для моделирования атомарного флага (реализация очереди с приоритетом)
	- применяет методы класса std::atomic для работы с атомарными целыми типами данных (реализация очереди с приоритетом)
	- дополнительное задание: - применяет слабые порядки на атомиках (реализация очереди с приоритетом)


## Контент

Поздравляем, вы изучили тему «Многопоточность и параллелизм». Чтобы проверить полученные знания на практике, предлагаем вам выполнить проектную работу, в процессе которой вам предстоит:

1. Разработать систему диспетчеризации задач, которая в многопоточном режиме выполняет независимые задачи с разными приоритетами. Более важные задачи исполняются первыми, менее важные - после того, как больше не осталось более важных задач ; 
2. Покрыть тестами каждый модуль проекта  с помощью фреймворка `GTest`.
3. Применить систему к логированию сообщений различной важности.


## План реализации проекта TaskDispatcher

1. Подготовьтесь к работе:
   - Откройте [шаблон проекта TaskDispatcher](https://github.com/Yandex-Practicum/cpp-middle-project-sprint-6){target="_blank"}.
   - Выполните инструкции в разделе `Начало работы`.
   - Соберите проект и запустите приложение по шагам в разделе `Сборка проекта и запуск тестов`.

2. Изучите файл include/types.hpp:
- В нем определено перечисление TaskPriority, с помощью которого задается приоритет задач. В текущей системе будет всего 2 приоритета: высокий и обычный.

3. Изучите файл include/queue/queue.hpp:
- В нем определен интерфейс IQueue - абстрактной очереди, в которую можно класть задачи и попытаться достать из нее задачи.
- Также в нем определена структура QueueOptions, с помощью которой может передаваться информация о виде очереди: ограниченная она или нет, и если да, то каков ее размер.
- Систему диспетчеризации задач можно будет конфигурировать так, чтобы задачи каждого уникального приоритета хранились в очереди с гибкой конфигурацией. Так, например, важные задачи будут храниться в ограниченной очереди, а обычные - в неограниченной очереди.

4. Реализуйте класс BoundedQueue:
- В файле include/queue/bounded_queue.hpp дополните описание класса BoundedQueue необходимыми для реализации полями.
- В файле-заготовке src/queue/bounded_queue.cpp напишите реализацию всех методов.

5. Реализуйте класс UnboundedQueue:
- В файле include/queue/unbounded_queue.hpp дополните описание класса UnboundedQueue необходимыми для реализации полями.
- В файле-заготовке src/queue/unbounded_queue.cpp напишите реализацию всех методов.

6. Реализуйте класс PriorityQueue:
- В файле include/queue/priority_queue.hpp дополните описание класса PriorityQueue необходимыми для реализации полями.
- Реализуйте конструктор, который принимает отображение перечисления TaskPriority на конфигурацию очереди QueueOptions, создает объекты очередей в соответствии с конфигурациями и сохраняет упорядоченное отображение приоритета на объекты очередей.
- Реализуйте метод `push`, который кладет задачу в соответствующую ее приоритету очередь.
- Реализуйте метод `pop`, который возвращает объект задачи. Первыми извлекаются задачи из очереди с более высоким приоритетом. Задачи с нормальным приоритетом извлекаются только если нет задач в очереди с высоким приоритетом. Исполнение должно блокироваться, если во всех очередях нет задач. Поток, заснувший на методе pop, должен проснуться при поступлении новых задач.
- Реализуйте метод `shutdown`. Он должен сигнализировать PriorityQueue о том, что больше не нужно блокироваться на методе `pop`, и, в случае отсутствия задач, из `pop` нужно возвращать std::nullopt.

7. Реализуйте класс пула потоков ThreadPool:
   - В файле include/thread_pool/thread_pool.hpp добавьте необходимые для реализации поля класса.
   - Объявите конструктор, который принимает `std::shared_ptr<PriorityQueue>` и количество потоков в пуле.
   - Объявите деструктор.
   - Объявите приватный метод, который будут запускать все рабочие потоки. Так как задачи независимы, то нет смысла использовать примитивы синхронизации при выполнении задач.
   - После вызова деструктора потоки должны исполнять задач, пока из приоритетной очереди не вернется std::nullopt.
   - В файле src/thread_pool/thread_pool.cpp определите эти методы.

8. Реализуйте класс TaskDispatcher:
- В файле include/task_dispatcher.hpp добавьте необходимые для реализации поля класса.
- Объявите конструктор класса так, чтобы, помимо количества потоков-воркеров, он принимал еще и конфигурацию класса PriorityQueue. Установите конфигурацию по умолчанию такой: для задач высокого приоритета - ограниченная 1000 элементами очередь, для задач обычного приоритета - неограниченная очередь.
-  В файле src/task_dispatcher.cpp реализуйт методы класса.

9. Протестируйте функционал очередей:
- в директории tests/queue/ в файлах-заготовках реализуйте модульные тесты для каждого класса очереди.

10. Протестируйте функционал диспетчера задач:
- в директории tests/ в файле-заготовке реализуйте модульные тесты для класса TaskDispatcher.

11. Изучите класс include/logger.hpp:
- Это синглтон, в котором для записи строки на стандарт поток вывода используются функции языка С.
- По POSIX стандарту такие функции, как fprintf или fwrite сами по себе потокобезопасные. Однако по умолчанию эти функции используют внутри себя буфер, для уменьшения количества системных вызовов. Этот буфер, доступ к которому есть у всех потоков, уже не обладает свойством потокобезопасности. Попытки записи из разных потоков в этот буфер могут привести к смешиванию строк.
- Но буферизацию можно отключить мануально. Тогда получится потокобезопасный логгер без использования явных средств синхронизации.

12. Изучите файл main.cpp:
- В нем запускается несколько потоков, которые в цикле назначают диспетчеру выполнить логирование нескольких сообщений. В начале итерации цикле назначаются задачи обычного приоритета, зачем задачи высокого приоритета

13. Улучшите обработку ошибок:
-  Реализуйте обработку ошибок при выполнении задачи с помощью перехвата исключений.

14.  Финализируйте работу:
- Протестируйте систему диспетчеризации в main.cpp на задачах логирования, раскомментировав несколько строчек в корневом CMakeLists.txt.


## Требования к результатам работы для студента

### Общие требования к проекту
1. Должно быть создана система диспетчеризации задач с разными уровнями приоритета. 
2. В разработке должны применяться современные возможности C++, изученные возможности стандартной библиотеки поддержки Concurrency С++ и библиотеки `GTest`.
3. Система должна корректно выполнять запланированные задачи. Приоритет исполнения должен быть у задач высокой важности.

### Ключевые функциональные требования
В системе должны быть реализованы:
1. Ограниченная и неограниченная очереди.
2. Очередь, хранящая задачи по приоритетам.
3. Пул потоков.
4. Диспетчер задач.

### Технические требования
В системе должны применяться:
- Стандартные потоки С++.
- Примитивы синхронизации стандартной библиотеки.
- Корректная обработка ошибок и исключительных ситуаций.
- Unit-тесты для проверки функциональности.

## Чек-лист 

### Обязательные требования

- **Реализация очередей**
  - [ ] В директории include/queue во всех файлах заготовках объявлены соответствующие классы очередей со всеми необходимыми методами и полями.
  - [ ] В директории src/queue во всех файлах заготовках определены методы соответствующих классов очередей.

- **Реализация пула потоков**
  - [ ] В файле include/thread_pool/thread_pool.hpp объявлен класс ThreadPool со всеми необходимыми методами и полями.
  - [ ] В файле src/thread_pool/thread_pool.сpp определены все методы класса ThreadPool.

- **Реализация диспетчера задач
  - [ ] В файле include/task_dispatcher.hpp объявлен класс TaskDispatcher со всеми необходимыми методами и полями.
  - [ ] В файле src/task_dispatcher.cpp определены все методы класса TaskDispatcher.
  - [ ] При однопоточном диспетчере задач при выполнении задач должен сохраняться тот же порядок, в котором задачи были помещены в диспетчер. За исключением того, что в начале должны выполниться все задачи высокого приоритета, а затем - нормального.

- **Корректное завершение работы**:
- [ ] Все задачи, помещенные в диспетчер, должны выполниться, даже если был вызван деструктор объекта.

- **Применение диспетчера задач в логировании**:
  - [ ] Из файла main.cpp корректно собирается исполняемый файл dispatcher, в котором происходит исполнение задач логирования.
  - [ ] Сообщения от всех задач должны быть выведены на экран, строчка за строчкой без наложений.
  - [ ] Конкретный результат невозможно предсказать, потому что потоки планируются операционной системой недетерминированно. Но картина должна быть примерно такая: в начале выводятся на экран несколько сообщений от задач обычного приоритета(1-4), дальше практически все разом сообщения от задач высокого приоритета(возможны редкие прерывания последовательности сообщениями нормального приоритета), в конце выводятся сообщения нормального приоритета(возможны редкие прерывания последовательности сообщениями высокого приоритета).

- **Обработка ошибок и безопасность**
  - [ ] Корректная обработка нештатных ситуаций с помощью исключений

- **Архитектура и код**
  - [ ] Используются стандартные примитивы синхронизации: std::atomic, std::mutex, std::condition_variable.
  - [ ] Отсутствуют гонки данных.

- **Тестирование**
  - [ ] Написано 5 unit-тестов для каждого класса очереди и диспетчера задач .
  - [ ] Тесты покрывают основные сценарии использования.

### Опциональные требования

- **Атомарные операции**
  - [ ] Везде при использовании атомарных операций явно расставлены подходящие std::memory_order.
  - [ ] Вместо условных переменных использованы семафоры.

- **Архитектура и код**.
  - [ ] Код соответствует современным стандартам C++.

- **Тестирование**
  - [ ] Написано не меньше 8 unit-тестов для всех очередей и диспетчера задач.
  - [ ] Тесты покрывают кейсы завершения обработки задач.