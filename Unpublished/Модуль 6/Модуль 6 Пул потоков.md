
Оры:
- понимает преимущества использования пула потоков
- применяет пул потоков для оптимизации программы
- применяет инструменты для реализации пула потоков


Структура:

- аналогия с рестораном, посетителями и официантами. Выгодно ли на каждого посетителя выделять своего официанта? Посетителю да, ведь у него сразу примут заказ. Но это не поможет принести еду быстрее. У кухни ограниченный ресурс. А заведению невыгодно будет содержать столько официатов. Большую часть времени они будут простаивать, неэффективно использовать свое время, мешать друг другу и зазря проедать зарплату. Правильный подход, который и реализован везде - небольшая группа официантов обслуживает всех посетителей. Официант взял заказ - отдал заказ на кухню - пошел к другому клиенту брать заказ. И так далее. Это повышает эффективность одного официанта, он эффективно использует время. 
- Точно также и задачами. Приходит к нам по сети запрос, который нужно обработать. Можно для каждого запроса запускать свой поток исполнения. И это будет работать, если запросов мало. При большом количестве запросов затраты на создание, завершение и управление потоками будут превышать их полезную работу. Поэтому удобно иметь фиксированный набор потоков, которые будут исполнять все наши запросы. Это называется пул потоков или thread pool.
- Квиз 1
- Однако в ресторане кухня не может обрабатывать заказы всех клиентов одновременно. Все заказы выстраиваются в очередь, одновременно готовится только небольшое подмножество заказов и как только повар освобождается, он берет новый заказ и готовит для него блюда.
- Также и в программировании. Ограниченный набор потоков может одновременно выполнять неограниченное число задач. Поэтому пул потоков обязательно должен работать в сочетании с потокобезопасной очередью. 
- То есть тредпул выглядит снаружи просто как один метод push, который предназначен для вставки задачи в очередь. Внутри пула существует набор потоков, которые только и делают, что берут задачу -> выполняют ее -> берут следующую задачу и тд. Вам не гарантируется, что задачи выполнятся в тот же момент, в который вы положили их в очередь, и не гарантируется, что они выполнятся в том же порядке, в котором вы их поместили в очередь. Единственная гарантия - задача рано или поздно выполнится.
- Сниппет 1
- Показываем и рассказываем базовую реализацию тред пула из Уильямса, но немножко с отсылкой к уроку про многопоточные очереди, что очередь должна быть такая, что потоки блокировались при отсутствии задач. Также при разрушении пула игнорируем оставшиеся в очереди задачи.
- Сниппет 2


## Введение

Пул потоков (thread pool) - это механизм, который позволяет эффективно управлять и переиспользовать потоки для выполнения задач. Сегодня вы узнаете:

- почему неэффективно на каждую задачу заводить свой поток.
- как пул потоков позволяет эффективнее распоряжаться ресурсами программы.
- какие компоненты необходимы для реализации thread pool.

## Параллельная обработка задач

Представьте себе ресторан. В нем есть официанты, кухня, повара и 50 столиков. Пусть в заведение приходит посетитель. Как организовать официантов для обслуживания клиента?

Наивная стратегия - на каждого посетителя выделить отдельного официанта. Это прекрасное решение на первый взгляд: у клиента сразу же подходят брать заказ, официант подходит в нему по первому требованию. 

Но эта стратегия только на первый взгляд хороша. На самом деле в ней много неприятных нюансов:
- она не поможет принести еду быстрее. У кухни ограниченный ресурс, она не может одновременно готовить 50 блюд. А когда в ресторане полная посадка, то официанты будут друг другу мешать, отдавая и забирая заказы с кухни. Возможно будет такое, что еда до потребителя будет доходить дольше.
- при полной посадке 50 официантов одновременно могут обслуживать клиентов. Ничего плохого не произойдет, пока они принимают заказ. Но при передвижениях по залу и кухне они будут сильно друг другу мешать.
- большую часть времени официанты будут простаивать без дела. Всего-то требуется раз в несколько минут подносить блюда. С точки зрения бизнеса, в такой ситуации официанты будут неэффективно использовать свое рабочее время. А расходы на их подбор, оплату труда и социальные взносы одинаковые.

Неудивительно, что такой стратегией никто не пользуется в реальном мире. Реализован другой подход.

Создается штат небольшого количества официантов, каждый из которых может обслуживать несколько клиентов. Какие здесь плюсы:
- Официант взял заказ, затем отдал заказ на кухню, после пошел к другому клиенту брать заказ. И так по круг. Это повышает эффективность одного официанта, он эффективнее использует время и не простаивает. 
- Затраты создание небольшого штата сотрудников и управление им меньше.
- Официанты меньше мешают и сталкиваются друг с другом.

Надо понимать, что этот подход не гарантирует уменьшения время выдачи заказа. Кухня также имеет ограниченный ресурс и может выдавать X блюд в единицу времени. При большой нагрузке и полной посадке время выдачи будет увеличиваться. Он лишь позволяет снизить издержки бизнеса и клиентов от большого числа официантов.

Точно также и задачами. Приходит к нам по сети запрос, который нужно обработать. Можно для каждого запроса запускать свой поток исполнения. И это будет работать, если запросов мало. При большом количестве запросов затраты на создание, завершение и управление потоками будут превышать их полезную работу. Поэтому удобно иметь фиксированный набор потоков, которые будут исполнять все наши запросы. 

Это называется пул потоков или thread pool.

## Пул потоков

В ресторане кухня не может обрабатывать заказы всех клиентов одновременно. Официанты их относят на кухню и все заказы выстраиваются в очередь. Одновременно готовится только небольшое подмножество заказов и как только повар освобождается, он берет новый заказ и готовит для него блюда.

Также и в программировании. Каждая входящая задача попадает в очередь. Рабочие потоки(воркеры) в цикле достают из очереди задачи, исполняют их и переходят к следующей задаче. Одна очередь, а пользуются ей много потоков. Поэтому thread pool обязательно должен работать в сочетании с потокобезопасной очередью. 

Еще один немаловажный аспект - выбор количества рабочих потоков. Это зависит от конкретной ситуации, но в основном количество потоков определяется максимально возможным количество одновременно исполняемых задач за счет аппаратного параллелизма на компьютере, чтобы максимально эффективно использовать ресурсы железа. Это число возвращается с помощью статического метода класса потока std::thread::hardware_concurrency().

То есть thread pool выглядит снаружи просто как один метод вставки задачи в очередь. Внутри пула существует фиксированный набор потоков, которые только и делают, что берут задачу -> выполняют ее -> берут следующую задачу и тд. Вам не гарантируется, что задачи выполнятся в тот же момент, в который вы положили их в очередь, и не гарантируется, что они выполнятся в том же порядке, в котором вы их поместили в очередь. Единственная гарантия - задача рано или поздно выполнится.

![[Pasted image 20250713200540.png]]

## Пишем пул потоков

Мы готовы написать свой простой пул потоков. Это базовая реализация, которая может исполнять любые задачи, из которых можно создать std::function<void()>, то есть задачи, у которых нет конечного возвращаемого результата исполнения.

Публичный интерфейс класса ThreadPool будет состоять из конструктора, деструктора и метода Push. Приватный - из метода Worker, который будут запускать рабочие потоки.

Приватными членами класса будет вектор потоков, потокобезопасная очередь и атомарный флаг done. Атомарный флаг служит индикатором начала разрушения объекта пула и остановки воркеров.

```cpp
struct ThreadPool
{
	explicit ThreadPool(size_t num_threads = std::thread::hardware_concurrency());

	void Push(std::function<void()> f);

	~ThreadPool();

private:
	void Worker();

	std::atomic<bool> done;
	ThreadSafeQueue<std::function<void()>> queue;
	std::vector<std::jthread> workers;
};
```

Посмотрим на конструктор:

```cpp
explicit ThreadPool(size_t num_threads = std::thread::hardware_concurrency()) {
	workers.reserve(num_threads);
	for (size_t i = 0; i < num_threads; ++i) {
		// специальный синтаксис для запуска потоков с помощью метода класса
		workers.emplace_back(&ThreadPool::Worker, this);
	}
}
```

Резервируем в векторе рабочих потоков `num_threads` элементов и в цикле запускаем столько же потоков.

Метод Push:

```cpp
void Push(std::function<void()> f) {
	queue.push(std::move(f));
}
```

Все, что нам нужно, чтобы добавить задачу в пул - поместить ее в потокобезопасную очередь, обслуживающую thread pool.

Деструктор:

```cpp
~ThreadPool() {
	stop = true;
	for (auto &worker : workers_) {
		if (worker.joinable()) {
			worker.join();
		}
	}
}
```

В нем мы выставляем флаг остановки вычислений и ждем присоединения потоков. Они еще какое-то время будут работать, так как должны выполнится задачи, уже взятые в работу.

Метод рабочих потоков:

```cpp
void Worker() {
	while (!stop) {
		std::optional<std::function<void>> task = queue.TryPop();
		if (task.has_value()) {
			task();
		} else {
			std::this_thread::yield();
		}		
	}
}
```

В цикле пытаемся взять очередную задачу из очереди. Если она там есть, то выполняем ее. Если нет, то выходим из исполнения текущего потока с помощью std::this_thread::yield() и даем другим потокам время на выполнение, чтобы не крутится в горячем цикле.

Это очень важно: потоки пула не должны понапрасну крутиться и жечь CPU. Необходимо организовать исполнение задач так, чтобы в их отсутствии, потоки большую часть времени спали.

Потоки крутятся в цикле пока мы не начнем разрушать объект пула и не выставится атомарный флаг stop в true. Тогда потоки завершат выполнение текущей задачи, но на следующей круг не пойдут и завершатся.

Собираем все вместе:

```cpp
struct ThreadPool
{
	explicit ThreadPool(size_t num_threads = std::thread::hardware_concurrency()) {
		workers.reserve(num_threads);
		for (size_t i = 0; i < num_threads; ++i) {
			// специальный синтаксис для запуска потоков с помощью метода класса
			workers.emplace_back(&ThreadPool::Worker, this);
		}
	}

	void Push(std::function<void()> f) {
		queue.push(std::move(f));
	}

	~ThreadPool() {
		stop = true;
	}

private:
	void Worker() {
		while (!stop) {
			std::optional<std::function<void>> task = queue.TryPop();
			if (task.has_value()) {
				task();
			} else {
				std::this_thread::yield();
			}		
		}
	}

	std::atomic<bool> done;
	ThreadSafeQueue<std::function<void()>> queue;
	std::vector<std::jthread> workers;
};
```


**Кнопка**: К итогам!

## Заключение

В этом уроке вы узнали:

- подход с созданием на каждую задачу нового потока неоптимальный: потоки тратят на создание и управление ресурсы компьютера. При большом количестве задач в системе эти затраты могут ощутимо влиять на полезную часть работы программы.
- есть другой подход: складывать задачи в очередь и обрабатывать их фиксированным числом потоков. В этом случае снижаются накладные расходы на создание и управление потоками.
- для реализации пула потоков необходима потокобезопасная очередь, в которой будут хранится ожидающие исполнения задачи, и массив потоков, которые будут эти задачи исполнять.