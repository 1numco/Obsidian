
ОРы:
- применяет std::atomic_flag для моделирования атомарного флага
- применяет std::atomic\<bool> для моделирования атомарного флага

Структура:

- атомарные переменные позволяют без явного использования мьютексов избежать гонки данных, так как каждая операция над такими переменными выполняется атомарно и ни один поток не может увидеть промежуточное состояние вычислений.
- Очень важно понимать, что есть семантическая и безблокировочная атомарность. Если вы защитили мьютексом операции в критической секции, то в правильно синхронизированной программе другие потоки тоже не могут увидеть промежуточные вычисления. Безблокировочная атомарность же достигается за счет специальных процессорных инструкций. 
- Стандартная библиотека предоставляет 2 класса для работы с атомарными переменными: std::atomic_flag и std::atomic, которые принципиально отличаются в контексте гарантированного использования определенного вида атомарности.
- std::atomic_flag - единственный тип, который по стандарту гарантирует безблокировочную атомарность. Рассказываем про его методы и новые методы из С++20 для блокирующего ожидания.
- Сниппет 1 воркер и graceful shutdown.
- std::atomic уже не гарантирует безблокировочной атомарности, однако на современных десктопных процессорах для некоторых типов операции над этим типом будут безблокировочными. Перечисляем методы и новые методы из С++20 для блокирующего ожидания.
- Сниппет 2 мьютекс с блокирующим ожиданием wait+notify


## Введение

Атомарные переменные позволяют без использования других примитивов синхронизации предотвратить гонку данных при одновременном доступе к ним нескольких поток. Сегодня вы узнаете:

- какие бывают виды атомарности.
- какие атомарные типы есть в стандартной библиотеке.
- чем отличаются std::atomic_flag и std::atomic.
- как с помощью атомарных типов можно моделировать атомарный флаг.


## Атомарные операции

Атомарные переменные - это объекты специальных типов, каждая операция над которыми выполняется атомарно. Атомарно в том смысле, что ни один поток не может увидеть промежуточный результат вычислений таких операций. Благодаря этому в любой момент времени любой поток видит валидные состояния атомарной переменной. 

То есть если вы используете вместо обычной переменной атомарную, вам не нужно беспокоиться о ее дополнительной синхронизации. Вы гарантировано предотвратите гонку данных.

Однако свойства атомарности - отсутствия видимого промежуточного результата вычислений - можно достичь разными средствами. 

В правильно синхронизированной программе ни один поток увидеть промежуточные операции в критической секции. Мьютекс предоставляет эксклюзивный доступ одному потоку, а исполнение других потоков он блокирует. Поток, захвативший замок в следующий раз, увидит только завершенные результаты вычислений критической секции предыдущего потока. 

```cpp
// вставка элемента в стек
void ThreadSafeStack::push(T new_value) {
	std::lock_guard<std::mutex> lock(m_);
	// в критической секции несколько машинных инструкций, но ни один поток не видит результатов промежуточных вычислений
	data.push(std::move(new_value));
}

// изымание элемента из стека
void ThreadSafeStack::pop(T& value) {
	std::lock_guard<std::mutex> lock(m_);
	// в критической секции несколько машинных инструкций, но ни один поток не видит результатов промежуточных вычислений
	if(data.empty()) throw empty_stack();
	value=data.top();
	data.pop();
}
```

Но физически в критической секции находится множество инструкций и неправильно в неправильно синхронизированной программе можно увидеть объекты в невалидном состоянии. Поэтому такая атомарность в правильно синхронизированной программе называется семантической. То есть она по смыслу   атомарная, но все же чисто технически в машинном коде мы может выделить отдельные инструкции.

А можно использовать специальные инструкции процессора, которые за нас будут обеспечивать свойство атомарности. Это одиночные инструкции за один свой вызов атомарно изменяют переменную. Такую атомарность можно назвать неблокирующей, так как в этом случае не используются мьютексы для блокировки потоков. 

```cpp
std::atomic<bool> locked = false;

void lock() { 
	// читаем, изменяем и записываем locked за одну физическую инструкцию
	while (locked.exchange(true));
}
```
Да, в этом случае мы за одну операцию можем сделать не так много, как в критической секции, защищенной мьютексом. Но это позволяет избежать накладных расходов, связанных с блокировкой потоков, и потенциально увеличить скорость работы программы.

Получается, что есть 2 типа атомарности операций: семантическая и неблокирующая.

Стандартная библиотека предоставляет 2 класса для работы с атомарными переменными std::atomic_flag и std::atomic, которые принципиально отличаются в контексте гарантированного использования определенного вида атомарности.

## std::atomic_flag

std::atomic_flag - единственный тип, для операций которого стандарт гарантирует использование неблокирующей атомарности и требует от реализаций стандартной библиотеки обеспечить это свойство. То есть если даже на самой экзотической архитектуре процессора существует компилятор С++, поддерживающий 11 стандарт, вы можете быть уверены, что этот тип не будет использовать никакие блокировки в реализации своих операций.

Создать и проициализировать объект std::atomic_flag можно так:

```cpp
std::atomic_flag f = ATOMIC_FLAG_INIT; // до С++20

std::atomic_flag f1{}; // после С++20
```

До С++20 конструктор по умолчанию инициализировал флаг в неопределенное состояние, поэтому необходимо было использовать макрос ATOMIC_FLAG_INIT. С++20 внес очевидное исправление: теперь конструктор по умолчанию инициализирует флаг в опущенное состояние.

Есть всего 3 основных метода работы с этим флагом: clear, test и test_and_set:

```cpp
std::atomic_flag f{};
assert(f.test() == false); // метод test возвращает состояние флага в виде bool

assert(f.test_and_set() == false); // метод test_and_set устанавливает флаг в поднятое состояние и возвращает передыдущее состояние флага
assert(f.test() == true);
assert(f.test_and_set() == true); // так как флаг был уже в поднятом состоянии, метод вернул true

f.clear(); // опускает флаг
assert(f.test() == false);
```

- clear() опускает флаг. Можно считать аналогом записи нуля в bool переменную.
- test() возвращает текущее состояние флага в виде bool. Флаг поднят - возвращается true, флаг опущен - false.
- test_and_set - это read-modify-write операция, которая меняет состояние флага на поднятое и возвращает предыдущее состояние флага в виде bool.

Обычного метода установления флага у этого класса нет, вместо него используется test_and_set.

В С++20 также появилось несколько методов, которые могут превратить атомарный флаг в условную переменную без использования мьютексов!

```cpp
std::atomic_flag f{};
int data;

void producer() {
	data = 42;
	f.test_and_set();
	f.notify_one();
}

void consumer() {
	f.wait(false);
	std::println("{}", data);
}
```

Метод wait принимает состояние флага, при котором нужно заблокировать и в цикле выполняет следующие действия:
- сравнивает результат this->test() с переданным состоянием флага.
- если они равны, то блокируется, пока на этом же объекте  не вызовется один из методов notify_one или notify_all.
- иначе return.

В этом случае нам не нужен горячий цикл:

```cpp
while(!f.test());
```

Поток будет спать и проснется, когда атомарную переменную уведомили о готовности данных.


## std::atomic

std::atomic - это шаблонный класс, в который можно оборачивать любые тривиально копируемые типы, которые можно копировать и перемещать. 

В отличии от std::atomic_flag, для этого класса не гарантируется неблокирующая атомарность. Хотя для фундаментальных типов реализации стандартных библиотек под большинство десктопных и серверных процессоров предоставлют неблокирующую атомарность. Для остальных типов атомарность скорее всего будет реализована с помощью использования мьютексов. Убедиться в том, являются ли неблокирующими атомарные операции под вашу архитектуру, можно с помощью метода is_lock_free(). Его можно вызвать на std::atomic с любым типом.

std::atomic может работать с множеством типов, но в этом уроке мы сконцентрируемся на `std::atomic<bool>`.

Эта инстанциация шаблона по функционалу идентична atomic_flag с тем только отличием, что имеет более привычный интерфейс. 

```cpp
std::atomic<bool> f{false};
std::atomic_bool f1{false}; // стандартный алиас
assert(f.load() == false); // метод load возвращает состояние перемеенной

f.store(true); // метод store присваивает переменной указанное значение
assert(f.load() == true);

f = false; // есть также более удобный оператор присваивания
assert(f == false); // и более удобный оператор приведения к типу bool, чтобы читать переменную

assert(f.exchange(true) == false); // метод exchange заменяет текущее значение переменной на указанное в скобках и возвращает старое значение.
assert(f.load() == true);
```
- load и operator bool возвращают текущее значение переменной.
- store и operator= присваивают переменной указанное значение.
- exchange заменяет текущее значение переменной на указанное и возвращает старое значение.

Также базово std::atomic предоставляет методы. compare_exchange_weak и compare_exchange_strong. Эти методы сравнивают текущее значение переменной с ожидаемым значением и возвращают результат проверки. Если условие выполняется,  методы подменяют текущее значение на новое значение. В обратном случае записывают в ожидаемое значение текущее значение переменной. По сути, это условный exchange.

```cpp
std::atomic<bool> value = false;
bool expected = false;
// Пытаемся заменить false на true

bool success = value.compare_exchange_strong(expected, true);

assert(success = true); // так как expected совпадает с текущим значением value, сравнение и замена проходят успешно
assert(value.load() == true); // замена прошла успешно
assert(expected == false); // в этом случае ожидаемое значение не меняется

success = value.compare_exchange_strong(expected, false); // теперь ожидаемое значение не такое, как текущее значение value

assert(success == false); // сравнение завершилось неудачей
assert(value.load() == true); // значит текущее значение value осталось неизменным
assert(expected == true); // однако изменилось значение expected
```

Коротко эти две операции называют CAS(Compare And Exchange). Это ключевой строительный блок большинства lock-free алгоритмов.

lock-free алгоритмы работают так, что много потоков в один и тот же момент времени могут изменять разделяемые данные. Это приводит к тому, что любая информация о состоянии разделяемых данных потенциально устаревает уже в следующий момент времени, после получения информации. Операция CAS признавана дать потоку знать, что в данный момент у него есть актуальная информация о переменной. 

Обычно CAS применяют в цикле, чтобы в случае неверного ожидаемого значения получить актуальное значение и пойти проверять дальше. А в случае, если поток имеет корректное представление о текущем значении переменной, тут же заменить это значение на нужное:

```cpp
std::atomic<bool> shared{false};
void foo() {
	bool expected = false;
	// ждем, пока значение shared станет ложным и сразу же меняем его на истину
	while (!shared.compare_exchange_strong(expected, true)) {
		expected = false; // после неудачного сравнения expected станет равен true
	}
}

```

Отличие compare_exchange_strong от compare_exchange_weak - compare_exchange_weak может привирать и возвращать false, даже если текущее и ожидаемые значения равны. В этом случае использовании цикла потребуется больше итераций, чтобы заменить значение на желаемое. Однако эти затраты могут оправдаться, потому что на некоторых платформах compare_exchange_weak показывает лучшую производительность, по сравнению с compare_exchange_strong

Эти операции будут более актуальны в будущих уроках.

В С++20 в std::atomic также добавили методы wait, notify_one и notify_all. Семантика у них такая же, как мы рассматривали для std::atomic_flag:

```cpp
std::std::atomic<bool> f{false};
int data;

void producer() {
	data = 42;
	f.store(true);
	f.notify_one();
}

void consumer() {
	f.wait(false);
	std::println("{}", data);
}
```


Оба этих класса могут быть использованы для моделирования атомарного флага - булевой переменной, которая может сигнализировать о появлении какого-то события другим потокам. При появлении события флаг поднимается(или в переменную записывается true), а читатель ждет этого события либо в активном цикле с использованием test|load, либо в заблокированном состоянии в методе wait, пока этот атомик не уведомят о появлении события с помощью методов notify_one|notify_all.

**Кнопка**: К итогам!

## Итоги


В этом уроке вы узнали:

- есть 2 типа атомарности: семантическая и неблокирующая.
- семантическая атомарность достигается с помощью мьютексов, неблокирующая - за счет специальных инструкций процессора.
- для std::atomic_flag стандартом гарантируется использование неблокирующей атомарности.
- для std::atomic такой гарантии нет, однако на большинстве современных десктопных и серверных процессорах инстанциации std::atomiс от фундаментальных типов будут неблокирующими.
- для моделирования атомарного флага можно использовать 2 класса: std::atomic_flag и std::atomic<bool>.
 