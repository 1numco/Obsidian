
- понимает семантические категории операций
- понимает отношения порядка: расположено раньше, синхронизированно с, произошло раньше
- понимает устройство модели памяти 


Структура:

- существуют приниципиальные препятствия к тому, чтобы код программы выполнялся в соответствии с ее кодом на С++: компилятор может переупорядочивать инструкции и процессор может переупорядочить инструкции. Немного говорим про кэш процессора. (Ор: понимает необходимость модели памяти)
- компиляторы и процессоры - это не С++ сущности, мы как программисты не контролируем их поведение. Поэтому непонятно, как писать корректные программы.(Ор: понимает необходимость модели памяти)
- благо в С++11 появилась стандартная поддержка многопоточности и модель памяти в языке С++. Эта модель отвечает на вопрос: в каком порядке выполняются чтения и записи в разделяемых ячейках памяти из разных потоков? Модель памяти описывает как программист может гарантировать, чтобы прочитанное значение переменной было таким, как этого ожидает программист.(Ор: понимает необходимость модели памяти)
- Квиз 1
- Первая модель памяти, которая приходит в голову - программа выполняется потоками строго последовательно. Тогда никаких проблем с переупорядочиванием не будет и поведение программы будет ожидаемым. Однако это потребует частой синхронизации кэшей, а значит, это такая модель не очень эффективна. Однако нам и не нужна последовательность выполнения абсолютно всех инструкций. Достаточно гарантировать последовательность исполнения к нужных точках программы - в критических секциях при доступе к разделяемым ячейкам памяти. В С++ это делает программист. Он пишет программу так, чтобы с помощью определенных инструментов гарантировать последовательное исполнение в нужных местах кода и таким образом избавить программа от гонок данных. Такая модель памяти концептуально называется Sequential Consistency for Data-Race-Free Programs. Если программист написал правильно синхронизированную программу, то стандарт языка гарантирует правильность чтений. Если он написал плохую программу, язык перестает что-либо гарантировать и вы получаете UB. Это были общие слова, теперь конкретика. (Ор: понимает устройство модели памяти)
- Модель памяти С++ вводит понятие объекта и ячейки памяти. (Ор: понимает устройство модели памяти)
- Проблемы возникают когда 2 потока хотят получить доступ к одной ячейке памяти и по крайней мере один из них на запись. (Ор: понимает устройство модели памяти)
- Эти проблемы актуальны только для ячеек памяти, в которых находятся синхронизирующие переменные. (Ор: понимает устройство модели памяти)
- Наша задача - определить отношения порядка между доступами к этой ячейке. Именно порядок отвечает за то, чтобы все потоки видели одинаковые результаты чтений и записи одной переменной. (Ор: понимает отношения порядка: упорядочено раньше, синхронизированно с, произошло раньше)
- Такой порядок можно задать для атомарных переменных. Для них есть всего 3 типа операций: store, load, read-modify-write. В прошлом уроке мы узнали, что промежуточные результаты операций над ними никто не видит. Но это актуально скорее для read-modify-write. У атомарных операций есть еще одна особенность: если происходит запись в атомик, то другие потоки при следующем чтении прочитают именно эту запись. (Ор: понимает семантические категории операций)
- Квиз 2
- Но этого мало: нужно чтобы все обращения ко всем синхронизирующим переменным были глобально упорядочены и этот порядок был согласован с кодом программы
- вспоминаем пример с записью и чтением последовательно двух переменных(в случае появления синхронизирующего порядка не можем прочитать 0 и 0 в одном из примеров). (Ор: понимает отношения порядка: упорядочено раньше, синхронизированно с, произошло раньше)
- пример с переменной ready_data и записью и чтением в буфер. Нужно чтобы при записи в ready_data другой поток мог прочитать данные из буфера. В С++ это возможно, но нам нужно ввести 2 частичных порядка. (Ор: понимает отношения порядка: упорядочено раньше, синхронизированно с, произошло раньше)
- Synchronized-With - store+load на атомике - inter-thread relation. (Ор: понимает отношения порядка: упорядочено раньше, синхронизированно с, произошло раньше)
- Sequenced-Before - порядок инструкций в программе - intra-thread relation. (Ор: понимает отношения порядка: упорядочено раньше, синхронизированно с, произошло раньше)
- Happens-Before - транзитивное Synchronized-With + Sequenced-Before. (Ор: понимает отношения порядка: упорядочено раньше, синхронизированно с, произошло до)
- Happens-Before - самый важный частичный порядок, потому что именно за счет него в разные потоки в критических секциях видят изменения, которые сделали другие потоки. Каждое чтение неатомика должно читать последнюю Happens-Before запись. (Ор: понимает отношения порядка: упорядочено раньше, синхронизированно с, произошло раньше)
- Квиз 3
- Определение гонки через Happens-Before. (Ор: понимает устройство модели памяти)
- Квиз 4


## Введение

Когда мы спускаемся на такой низкий уровень, чтобы использовать атомарные переменные, нам нужно очень хорошо понимать, как в С++ в деталях устроена модель памяти. Сегодня вы узнаете:

- почему инструкции программы выполняются не всегда по порядку.
- за что отвечает модель памяти С++.
- почему не эффективно гарантировать упорядоченное выполнение всех инструкций.
- в каких случаях можно гарантировать упорядоченное выполнение определенного набора инструкций и при чем здесь атомарные переменные.
- какие отношения порядка существуют в С++.


## Программа может исполняться не построчно

Как бы мы того не хотели, программа на С++ не гарантирует, что код будет исполняться построчно, как код Python. И на это есть две серьезные причины. И чтобы их разобрать, нам нужно открыть капот С++ и посмотреть, как там все работает на низком уровне.

## Переупорядочивание инструкций компилятором


Первая причина - это компилятор. Современные С++ компиляторы очень круто оптимизируют наши программы, благодаря чему мы можем писать высокоуровневый код, который будет исполняться быстро. Отдельно взятый программист может писать не самый оптимальный код и компилятор заботится о том, чтобы даже такой код работал быстро. Но у этого есть свои последствия.

Компилятор не думает о том, что в вашей программе много потоков. Он анализирует вашу программу так, как будто бы она однопоточная. И единственное, о чем он беспокоится при оптимизациях - видимое исполнение однопоточной программы не должно изменится. Давайте посмотрим на пример:

```cpp
int A, B;
void foo()
{
	A = B + 1; // 1 инструкция
	B = 0; // 2 инструкция
}
```

Если его скомпилировать без оптимизаций, то получится следующий x86-64 ассемблер:

```asm
foo():
	pushq %rbp
	movq %rsp, %rbp
	movl B(%rip), %eax  // начинается 1 инструкция
	addl $1, %eax
	movl %eax, A(%rip)
	movl $0, B(%rip) // 2 инструкция
	nop
	popq %rbp
	ret
```

А если скомпилировать с -O3 оптимизациями, то получим другой код:
```asm
foo():
	movl B(%rip), %eax // начинается 1 инструкция
	movl $0, B(%rip) // в середину влезает 2 инструкция
	addl $1, %eax // продолжается 1 инструкция
	movl %eax, A(%rip)
	ret
```

Однако поведение однопоточной программы не изменится.

Но есть мы работаем в многопоточной среде, то можно только представить какие специэффекты возникнут, если одна инструкция будет выполняться по середине другой.

## Переупорядочивание инструкций процессором

Компилятором дело не ограничивается. Мы же можем поставить уровень оптимизации -O0. Да, программа будет работать медленно, но хотя бы будет работать верно. Поможет ли это программе исполняться последовательно?

С этим тоже есть проблемы. Программы выполняются на процессоре, которые в современном мире давно многоядерные. И например, в документации интеловского процессора честно говорят, что он может переупорядочивать инструкции:

[![Dekker algorithm on X86 | CodyWu's Blog](https://codywu2010.wordpress.com/wp-content/uploads/2014/10/intel_reorder.jpg)![Dekker algorithm on X86 | CodyWu's Blog](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSUe4HFPeb_pNvh_GjkZhmB1zOhhDxjDR8h9Q&s)](https://www.google.com/url?sa=i&url=https%3A%2F%2Fcodywu2010.wordpress.com%2F2014%2F10%2F05%2Fdekker-algorithm-on-x86%2F&psig=AOvVaw2DkUJ_Uu44X6ZBeSlO_JRL&ust=1750346539125000&source=images&cd=vfe&opi=89978449&ved=0CBQQjRxqFwoTCLjDwI-j-40DFQAAAAAdAAAAABAE)

![[Pasted image 20250619195313.png]]
Если перевести это в термины С++, выйдет что-то такое:

```cpp
int x, y, r1, r2;
void foo() {
	x = 1;
	r1 = y;
}

void bar() {
	y = 1;
	r2 = x;
}

int main() {
	std::thread th1{foo}, th2{bar};
	th1.join();
	th2.join();
	std::println("r1 = {}, r2 = {}", r1, r2);
}
```

Существует возможное исполнение этой программы, при котором на консоли появится подпись:

`r1 = 0, r2 = 0`

Хотя при последовательном исполнении инструкций такое просто невозможно. Какой-то из потоков будет первый и установит переменную `x` или `y` в единицу. Однако результат 0, 0 возможен из-за переупорядочивания инструкций на уровне процессора.

Это переупорядочивание следует из сложного устройства современных процессоров. Процессор состоит из нескольких ядер, которые имеют доступ к общей памяти. Однако напрямую работать с памятью - медленно, поэтому в ядрах есть несколько уровней кэшей:

![[Pasted image 20250618185200.png]]

Чтобы сделать запись в какую-то переменную, ядро должно захватить соотвествующую кэш-линию в монопольное пользование. Для этого этому ядру нужно пообщаться с кэшами других ядер и инвалидировать их кэш-линии, в которых содержатся данные нужной переменной. И ядро может писать в соответсвующую переменную только тогда, когда получит подтверждение об инвалидации кэш-линий других ядер.

На это требуется какое-то время, в которое ядро простаивает без дела. Процессор не хочет простаивать без дела и пытается сэкономить время исполнения программы, используя разные оптимизации.

Одна из таких оптимизаций называется Store Buffering:

![[Pasted image 20250618190424.png]]

Мы уже поняли, что для записи в переменную ядру нужно пообщаться с другими ядрами. Ядро CPU1 смотрит в свой кэш L1 и не находит там кэш-линии с Х. Значит точно нужно синхронизароваться с другими ядрами. Это долго и ядро пытается отсрочить этот момент. Оно записывает новое значение переменной X в свой локальный буфер с расчетом на то, что когда-нибудь это значение все-таки попадет в кэш. А переменная Y находится в кэше CPU1 и оно беспретятственно читает Y.

Зеркальная ситуация с CPU2.

Именно store buffering'ом можно объяснить, как в программе выше может получить пару нулей.

Не то, чтобы процессор поменял местами инструкции. Но в видимом исполнении программы как будто бы именно это происходит.

Естественно, выше описана неполная и довольно прощенная картина всего того, что происходит в процессоре. Важно здесь то, что последовательное исполнение инструкций С++ кода в принципе невозможно без синхронизации.

## Модель памяти

Компиляторы и процессоры - это не С++ сущности, мы как программисты не контролируем их поведение. Единственное, что мы можем контролировать - это код на С++.

До С++11 на С++ было невозможно писать платформонезависимые многопоточные программы. В стандарте языка не было не слово про потоки.

Но в С++11 появилась стандартная поддержка многопоточности и модель памяти. 

Так как можем наблюдать только косвенное поведение программы по чтениям переменных, то модель памяти отвечает на главный вопрос: в каком порядке выполняются чтения и записи в разделяемых ячейках памяти из разных потоков? В более прикладном смысле модель памяти описывает, как программист может гарантировать, чтобы прочитанное значение переменной было именно таким, как он этого ожидает.

В этом смысле самая простая модель памяти должна гарантировать последовательное выполнение всех инструкций. Тогда никаких проблем с переупорядочиванием не будет и поведение программы будет ожидаемым. Однако это потребует частой синхронизации кэшей и запрета определенных оптимизаций компилятора, а значит, это такая модель не очень эффективна.

Однако нам и не нужна последовательность выполнения абсолютно всех инструкций. Основная часть кода выполняется в рамках одного потока исполнения. Достаточно гарантировать последовательность исполнения к самых чувствительных точках программы - в критических секциях при доступе к разделяемым ячейкам памяти.

По умолчанию С++ не предоставляет таких гарантий. Однако он предоставляет инструменты, с помощью которых программист может гарантировать последовательное исполнение программы в определенных местах кода и таким образом избавить программу от проблем с переупорядочиванием.

 Такая модель памяти концептуально называется Sequential Consistency for Data-Race-Free Programs. Если программист написал правильно синхронизированную программу, то стандарт языка гарантирует ожидаемое поведение программы в терминах чтений. Если он написал плохую программу, язык перестает что-либо гарантировать и программа ведет себя неопределенным образом.

Модель памяти описывает 2 аспекта программ: структурные и concurrency аспекты. Структурные аспекты отвечают за то, как объекты располагаются в памяти.

## Структурные аспекты модели памяти

Все данные в программе C++ состоят из объектов. Объект не в терминах ООП Это утверждение о строительных блоках данных в C++. Стандарт C++ определяет объект как «область хранения данных». Некоторые из этих объектов являются простыми значениями фундаментального типа, такого как int или float, тогда как другие являются экземплярами пользовательских классов. Некоторые объекты (такие как массивы, экземпляры производных классов и экземпляры классов с нестатическими членами данных) имеют подобъекты, а другие — нет.

Независимо от его типа, объект хранится в одной или нескольких ячейках памяти. Так как в С++ каждый все объекты построены на фундаментальных скалярных типах(числа и указатели), то каждая ячейка памяти — это либо объект или подобъект скалярного типа.

Из этого следует вынести четыре важных вывода:
- Каждая переменная является объектом, включая те, которые являются членами других объектов.
- Каждый объект занимает как минимум одну ячейку памяти.
- Составной объект(массив или объект кастомного класса) занимает несколько ячеек памяти.
- Переменные фундаментальных типов, таких как int или char, занимают ровно одну ячейку памяти, независимо от их размера, даже если они являются смежными или частью массива.


## Concurrency аспекты модели памяти

Эти аспекты полностью зависят от ячеек памяти. Если два потока обращаются к разным ячейкам памяти, то нет никаких проблем: все работает нормально. 

С другой стороны, если два потока обращаются к одной и той же ячейке памяти, то вам нужно быть настороже. 

Если все потоки только читают данные из разделяемой ячейки памяти, то все в порядке; данные, предназначенные только для чтения, не нуждаются в защите или синхронизации. Но если хотя бы один из потоков изменяет данные, то это предвестник состояния гонки данных.

Эти рассуждения неактуальны данных, которые уже защищены примитивами синхронизации, типа мьютексов. К этим данным нет конкурентного доступа, это обспечивается самим примитивом. 

Проблемы возникают только для ячеек памяти, в которых находятся синхронизирующие переменные. Они и являются строительными блоками более высокоуровневых примитивов или сами синхронизирую данные. К таким переменным потоки пытаются получить доступ реально конкурентно.

Наша задача - определить отношения порядка между доступами к этой ячейке. Такие отношения и отвечают за то, чтобы все потоки контролируемо видели одинаковые результаты чтений и записи одной и той же переменной.

В С++ такие отношения порядка задаются только через атомарные переменные.

## Synchronization order

У атомарных переменных есть всего 3 типа операций: Store(запись), Load(чтение) и Read-Modify-Write или RMW(операции, которые одновременно читают переменную, изменяют ее и делают запись).

В прошлых уроках мы фокусировались только на свойстве атомарности этих операций. Однако это актуально в большей мере именно для RMW операций, потому что на многих современных процессорах чтение и запись переменной скалярного типа и так происходит атомарно.

Однако у атомиков есть еще одно свойство: если происходит запись в атомик, то другие потоки при следующем чтении прочитают именно эту запись. И это свойство ключевое для обеспечения отношений порядка, которого нет у обычных переменных. Ядро вынуждено выполнить протокол общения с другими кэшами и получить самые актуальные данные.

Интуитивно вы это и так понимали. Но этого свойства мало для обеспечения синхронизации между несколькими переменными. Нужно, чтобы все обращения ко всем синхронизирующим переменным были упорядочены и этот порядок был согласован с кодом программы.

Без такого порядка, который бы был согласован с кодом программы в нашем знакомом примере все равно имеется вероятность вывода на экран двух нулей.

```cpp
std::atomic<int> x, y, r1, r2;
void foo() {
	x.store(1);
	r1.store(y.load);
}

void bar() {
	y.store(1);
	r2.store(x.load);
}

int main() {
	std::thread th1{foo}, th2{bar};
	th1.join();
	th2.join();
	std::println("r1 = {}, r2 = {}", r1, r2);
}
```

Отсутствие порядка опять приводит к известной проблеме: либо процессор, либо компилятор могут переупорядочить операции в функциях, даже если каждое чтение атомиков видит самую последнюю запись.

При наличии же порядка между операциями над разными атомиками, на консоль не может вывестись 2 нуля.

И такое отношение между операциями над атомиками действительно есть в С++. Назовем его synchronization order.

Synchronization order - это скелет программы, благодаря которому упорядочиваются не только записи и чтения атомиков, но и неатомарных переменных.

Благодаря тому, что упорядочиваются и неатомарные переменные, можно передавать данные между потоками и индикатором готовности данных будет атомик:

```cpp
std::string data;
std::atomic<bool> ready;

void foo() {
	data = "data";
	ready.store(true);
}

void bar() {
	if (ready.load()) {
		std::println("{}", data);
	}
}
```

При чтении программы создается уверенность, что в функции bar на консоль должна вывестись именно та строка, которая была записана в foo. И synchronization order гарантирует это. Раз мы выводим data на консоль, значит в ready записано true, а значит функция foo уже выполнила запись. То есть запись в data произошла раньше чтения из data.

Synchronization order - это не глобальный, а частичный порядок. Обычно выставляется для зависимых по данным операциям в местах синхронизации потоков. Глобальный порядок вредит производительности, однако мест синхронизации в программе обычно немного и в них корректность доступов важнее производительности.

## Отношения порядка

Synchronization order в стандарте имеет более строгое определение и структуру, поэтому давайте посмотрим, как устроены отношения между чтениями и записями переменных с точки зрения стандарта.

## Синхронизировано-С

Это отношение между операциями гарантирует, что любое чтение атомарной переменной увидит самую последнюю запись в нее. В этом случае говорят, что чтение атомика "синхронизировалось-с" записью в этот атомик. 

Это можно представить, как посылку сообщения: когда мы приняли сообщение(прочитали значение переменной), то мы точно знаем, что оно гарантировано было отправлено в прошлом(произошла запись в ту же переменную).

![[Pasted image 20250619175131.png]]

Запись в атомик можно считать массовой рассылкой сообщения: все читатели при следующем чтении получат одно и то же сообщение(одинаковое записанное значение). RMW операции считаются одновременно чтением и записью, то есть они и принимают сообщение и отправляют новое.

Важно понимать: чтение синхронизируется с самой последней запись в атомик. Синхронизируется именно в тот момент, когда оно из атомика в первый раз считали новую запись.

Заранее до запуска программы не известно между какой записью и чтением возникнет частичный порядок "синхронизировано-с". Это определяется во время работы программы. Очередное чтение обязательно увидит какую-то последнюю запись и именно в этот момент происходит синхронизация.

"Синхронизировано-С" обычно считают межпотоковым отношением, так как этот частичный порядок может возникнуть между чтениями и записями в разных потоках исполнения.

## Расположено-Раньше

Одним из аспектов synchronization order было то, что операции упорядочены в том числе и в коде программы. Код программы задает еще одно отношение между операциями - "расположено-раньше". Если операция A над ячейку памяти расположена выше по коду С++ программы, чем операция В над той же ячейкой памяти, то говорят, что A "расположено-раньше" B.

"Расположено-Раньше" обычно считают внутрипотоковым отношением, так как оно возникает строго между чтениями и записями в одном потоке исполнения.

Это отношение порядка устанавливается только между обращениями к одной и той же ячейке памяти. Обращения к разным ячейкам памяти так не упорядочиваются.

## Произошло-Раньше

Это ключевой элемент сегодняшнего урока.

Стандарт определяет отношение порядка "Произошло-Раньше" следующим образом.

Не беря учет потоки исполнения, операция А "произошло-раньше" операции В, если верно любое из следующих утверждений:

- A "расположено-раньше" B.
- A "синхронизировано-с" B.
- A "произошло-раньше" Х и Х "произошло-раньше" B.

Это была дань уважения стандарту, а теперь объясним по-человечески.

В однопоточной программе, если запись А расположена выше по коду чтения B, то компилятор не имеет право переставлять инструкции так, чтобы В не увидело запись А. Это бы изменяло видимое поведение однопоточной программы. Модель памяти описывает, какие записи увидят чтения в любой С++ программе, поэтому этот частичный порядок должен быть в ней. В однопоточной программе мы точно знаем, если запись находится чтения по коду, то запись "произошла-раньше" чтения. В такой программе нам достаточно отношения "расположено-раньше", чтобы получить отношение "произошло-раньше".

В многопоточной программе, в тот момент, когда A "синхронизировалось-с" B, мы также понимаем, что A "произошло-раньше" B. Это следует из самой посылки сообщения: нельзя получить сообщение раньше, чем его кто-то оправил.

Отношение "синхронизировано-с" актуально только для атомарных переменных и многопоточных программ. Но, как мы обсуждали ранее, атомики помогают синхронизировать также неатомарные переменные. Это происходит потому что мы можем транзитивно замкнуть отношения порядка "расположено-раньше" и "синхронизировано-с" и отношение "произошло-раньше".

Из этого следует, что:
- Если A "расположено-раньше" B и В "синхронизировано-с" С, значит A "произошло-раньше" С. 
- Если A "синхронизировано-с" B и В "расположено-раньше" С, значит A "произошло-раньше" С. 
- Если A "произошло-раньше" B и В "произошло-раньше" С, значит A "произошло-раньше" С. 

Happens-Before - самое важное отношение порядка, потому что именно за счет него разные потоки в критических секциях видят изменения, которые сделали другие потоки. В корректно синхронизированной программе каждое чтение переменной должно читать последнюю Happens-Before запись. Это гарантирует стандарт, который требует соответствующего поведения от компилятора и процессора.

![[Pasted image 20250619191820.png]]

На картинке выше все записи до записи ready перетекли по стрелке "synchronizes-with" в другой поток T' и стали доступны чтениям в T'.

А что случится, если программа неправильно синхронизирована?

## Гонка данных

Наконец-то мы можем определить это понятие через стандартные термины.

Два обращения к памяти конфликтуют, если:

- они обращаются к одной и той же ячейке памяти.
- по крайней мере одно из обращений - запись.

Гонкой данных назовем 2 конфликтующих обращения к неатомарной переменной, между которыми не возникло отношение порядка "Произошло-Раньше". 

Гонка данных по стандарту приводит к неопределенному поведению.


## Эпилог

Из определения стандарта следует, что любые отношения поряка - это отношение "произошло-раньше", однако нам в этом модуле нужно будет их как-то различать друг с другом. Поэтому здесь и дальше мы будем называть "произошло-раньше" только транзитивное замыкание двух других отношений. Гонкой данных же будем считать отсутствия любого отношения порядка.

И последнее важное уточнение. Модель памяти, которую мы описали выше, мы имеем в С++ по умолчанию. Атомарные и неатомарные переменные по-умолчанию ведут себя именно так. Описанный порядок называет Sequential Consistency. Если коротко, то вокруг атомиков мы ожидаем, что с код выполняется последовательно по отношению к чтениям и записям в одни и те же разделяемые переменные. 

Однако это не полная картина. В С++ даже такой порядок считается слишком неоптимальным и существуют более слабые порядки, при которых требования к возможным переупорядочиваниям слабее, но и производительность выше. О них мы поговорим в следующием уроке.


**Кнопка**: К итогам!
## Заключение

В этом уроке вы узнали:

- инструкции программы на С++ не всегда выполняются по порядку, компилятор и процессор могут переупорядочивать их.
- требовать исполнения инструкций по порядку неэффективно, это потребует постоянного общения ядер процессора друг с другом и запретит некоторые оптимизации компилятора
- модель памяти отвечает на вопрос: какие значения увидят чтения в правильно синхронизированной программе.
- модель памяти актуальна для низкоуровневых атомиков, потому что доступы до привычных критических секций синхронизированы через более высокоуровневые инструменты, типа мьютексов.
- модель памяти С++ вводит определенные отношения порядка между операциями, которые помогают программисту понимать, какие значения будут прочитаны.
- главную роль в этих отношениях при межпоточном взаимодействии играют атомарные переменные. 
- Отношение порядка "Расположено-Раньше" возникает между двумя обращениями к одной ячейке памяти в коде программы.
- Отношение порядка "Синхронизирова-С" возникает между записью и чтением в атомарную переменную.
- Отношение порядка "Произошло-Раньше" является комбинацией "Расположено-Раньше" и  "Синхронизировано-С".
- Гонка данных - это ситуация, при которой между конфиликтующими обращениям к неатомарным переменным не возникло отношение  "Произошло-Раньше".
