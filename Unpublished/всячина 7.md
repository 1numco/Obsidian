
Конфигурация и переменные окружения
#опытным 

Любой серьезный сервис нуждается в конфигурации. Файлы конфигурации (JSON, YAML, INI) — популярный способ хранения настроек приложений. Так параметры можно хранить в репозитории, версионировать, да и просто удобно, когда все можно менять в одном месте и никак не менять команду запуска.

Однако не одними конфигами едины. Не всегда они подходят для решения определенных задач.

Возьмем например ключи шифрования. Не всегда они генерируются новые, для интеграции двух партнеров могут использоваться ключи, которые обновляются раз в год или раз в полгода. Безопасно ли ключ шифрования выставлять в конфиге?

Не совсем. Что если какой-нибудь умник после тестирования приложения случайно закоммитит ключ в репозиторий? Это серьезная опасность: репозиторий вашей команды скорее всего может читать любой сотрудник, у которого есть доступ к вашей системе совместной разработки. А если у вас еще сторонние лица имеют доступ к репе... Не завидую вам. Безопасники будут радостно потирать ладоши, когда будут вам пистоны вставлять за эту ошибку. Потом еще ключ перевыпускать скомпрометированный, долго и мучительно заменять его... Сам наступал на эти грабли, приятного мало.

```
{
  "data_key": "qwerty123"  // Утечка при публикации кода!
}
```

Да и хранить ключ в открытом виде в файле на сервере такое себе. А если кто-нибудь подглядит?

То же самое можно сказать про креды базы данных, in-memory кэша, брокеров сообщений и прочего. Пароли могут быть скомпрометированы. 

```
# config.yml (попадает в Git)
db:
  host: db.example.com
  username: admin
  password: "P@ssw0rd123!"  # Утечка при публикации кода!
```

А как с докерами и кубернетисами вашими работать? Иметь 100500 образов с разными настройками кредов и множить их постоянно? Выглядит, как не очень расширяемое решение.

Конечно же никто не хранит в конфигах чувствительные данные и специфичные для конкретного инстанса переменные. Вместо этого используют переменные окружения.

Переменные окружения можно установить видимыми только для конкретного запущенного docker контейнера:

```
docker run -e MY_VAR=value my_image
```

В k8s можно брать переменые окружения из отдельно развернутого и защищенного Vault. В этом случае вообще отсутсвует явное указание секрета:

```
env:
	- name: MY_VAR
	- value: vault:my_group/my_service#my_var
```

Переменные окружения не попадают в репозиторий -> нет компрометации секретов.

Можно без изменения конфига на одном и том же сервере тестировать приложение в разных контурах:

```
# Local
export DB_HOST=localhost

# Dev
export DB_HOST=dev-db.example.com
```

В общем, переменные окружения в приложении - полезная вещь, не стоит ими принебрегать.

К чему это я и причем здесь С++? 

Ну нам же нужно выяснить, как в стандартных плюсах можно получать значения переменных окружения. Об этом поговорим в следующем посте.

Protect your secrets. Stay cool.

#goodpractice #tools


std::getenv
#новичкам 

Переменные окружения - это пары "ключ-значение", которые хранятся в операционной системе и доступны всем процессам. Они часто используются для:

- Конфигурации приложений
- Хранения чувствительных данных (паролей, ключей API)
- Управления поведением программ

Самый банальный пример - PATH. В этой переменной окружения находится список путей для поиска исполняемых файлов системой. Добавив путь к своей утилите в эту переменную, вы сможете ее запускать без указания полного пути.

Или например, более приближеный к плюсам пример, LD_LIBRARY_PATH. Это список путей, в котором линкер ищет указанные при линковке библиотеки.

И мы можем прочитать из плюсового кода переменные окружения с помощью С++11 функции std::getenv:

```cpp
#include <cstdlib>

char* std::getenv(const char* name);
```

Это скоммунизженная из Сей функция, которая принимает имя переменной окружения и возвращает ее содержимое. Если искомой переменной не существует, возвращается nullptr.

Почему-то они решили возвращать неконстантный указатель, поэтому если уже в вашу голову пришла мысль как-то поменять данные по этому указателю, то не стоит этого делать. Получите UB.

При запуске программы ОС копирует переменные окружения, видимые родительскому процессу, внутрь программы и таким образом они окружение программы перестает зависеть от внешнего мира.

Допустим, пишите вы какой-нибудь свой клиент-сервер на Boost.Asio. Хочется конфигурировать клиента адресом и портом сервера извне, чтобы иметь возможность по-разному запускать клиента локально и, допустим, через docker-compose. Конфиг и его парсилку писать довольно муторно, а адекватную парсилку аргументов командной строки - еще сложнее. Даже если использовать готовые решения в виде json парсера и boost.program_options.

Вместо этих решений можно передавать креды подключения к серверу через переменную окружения:

```cpp
#include <boost/asio.hpp>
#include <iostream>
#include <cstdlib>

using boost::asio::ip::tcp;

int main() {
    try {
        // HERE
        const char* host = std::getenv("SERVER_HOST");
        const char* port = std::getenv("SERVER_PORT");

        if (!host || !port) {
            std::cerr << "Please set SERVER_HOST and SERVER_PORT environment variables\n";
            return 1;
        }

        boost::asio::io_context io_context;

        // Создаем и соединяем сокет
        tcp::socket socket(io_context);
        tcp::resolver resolver(io_context);
        boost::asio::connect(socket, resolver.resolve(host, port));

        // Отправляем тестовое сообщение
        std::string message = "Hello from Boost.Asio client!\n";
        boost::asio::write(socket, boost::asio::buffer(message));

        // Читаем ответ (до символа новой строки)
        boost::asio::streambuf response;
        boost::asio::read_until(socket, response, '\n');

        // Выводим ответ
        std::istream is(&response);
        std::string reply;
        std::getline(is, reply);
        std::cout << "Server replied: " << reply << std::endl;

    } catch (std::exception& e) {
        std::cerr << "Exception: " << e.what() << "\n";
        return 1;
    }

    return 0;
}
```

Всего две строчки и никакой мороки! Очень удобная и полезная функция.

Explore your enviroment. Stay cool.

#cpp11


Третий аргумент main
#новичкам 

Почти всегда вы пишите функцию main вот так:

```cpp
int main() {
	// some code
}
```

Если вы пишите утилиту командной строки или просто хотите познать боль, то вам нужно парсить аргументы командной строки. В этом случае вы определяете main вот так:

```cpp
int main (int argc, char *argv[]) {
	// argc - количество переданных аргументов
	// argv - массив из переданных аргументов

	// some parsing
}
```

Однако в стандарте описан еще один способ определения main:

```cpp
int main(/* implementation-defined */) {body}
```

Стандарт разрешает компиляторам давать возможность пользователям как-то по-другому задавать аргументы для main. И хоть это будет не переносимо, но нам не всегда нужна кроссплатформенность.

Самая частовстречающаяся нестандартная сигнатура main следующая:

```cpp
int main(int argc, char* argv[], char* envp[]) {}
```

Третий аргумент main - это массив строк переменных окружения в формате "KEY=value". Массив завершается null pointer'ом.

Программа получает копию переменных окружения родительского процесса (например, терминала или скрипта). Набор переменных и их значения не меняются в течение жизни программы. То есть это захардкоженные неизменяемые снаружи значения.

Вот минимальный примерчик:

```cpp
#include <iostream>

int main(int argc, char* argv[], char* envp[]) {
    std::cout << "Environment variables:\n";
    
    for (char** env = envp; *env != nullptr; env++) {
        std::cout << *env << "\n";
    }
    
    return 0;
}
```

Возможный вывод:

```
PATH=/usr/local/bin:/usr/bin:/bin
USER=grokaem_cpp
...
```

Вы не так часто можете увидеть этот формат сигнатуры main по уже очевидным для вас причинам:

- нестандарт
- а самое главное - это дело надо парсить. Засовывать в мапу какую-то и искать потом по ключу нужную переменную. А зачем, если есть std::getenv или его брат getenv из Сей.

Рассказываю про это, чтобы вы при встрече в таким форматом аргументов main не думали, что что-то базовое упустили при изучении плюсов. Ну или просто для расширения кругозора)

Expand your horizons. Stay cool.

#NONSTANDARD #goodoldc 


environ
#опытным 

В POSIX-совместимых системах (Linux, macOS, BSD) существует еще один альтернатива параметру `envp` в функции `main()` и функции `std::getenv()` для получения значений переменных окружения. Это глобальная переменная `extern char** environ`, которая предоставляет прямой доступ ко всему окружению процесса.

В сущности, у нее такой же функционал, что и у envp, только эту переменную видно из любой единицы трансляции, так как это глобальная переменная, имеющая внешнюю линковку.

```cpp
#include <stdio.h>

extern char** environ;

void foo() {
    for(char** env = environ; *env != NULL; env++) {
        printf("%s\n", *env);
    }
}
```

В остальном, особенности работы такие же, как и у envp.

Но если мы уже зашли по колено в Posix, то там есть функция [setenv](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html), которая позволяет менять переменные окружения уже в ходе выполнения программы:

```cpp
#include <stdlib.h>  
  
int setenv(const char *_envname_, const char *_envval_, int _overwrite_);
```

И эти изменения будут видеть все ранее оговоренные методы получения значений env переменных. Однако это все не тредсейф и нужна защита в виде мьютексов.

Не встречал кейсов изменения переменных окружения. Наверное, это можно использовать, как костыльный механизм общения между модулями программы. Если у кого есть достойные примеры применения setenv, черканите в комментах, буду благодарен.

Интересно, как много в С|С++ методов получения окружения процесса. Но рекомендуется использовать конечно стандартный вариант std::getenv.

Be visiable. Stay cool.

#NONSTANDARD 


or and not
#новичкам 

В С/C++ всегда был не очень дружелюбный синтаксис операторов. Показать вот такой код человеку, который не в зуб ногой в программировании:

```cpp
if (x > 0 && y < 10 || !z) {
    // ...
}
```
есть вероятность, что он подумает, что его прокляли шаманы майя.

Однако знали ли вы, что в С/C++ есть альтернативный синтаксис токенов? Символы операторов заменяются на короткие слова и код выше становится почти питонячьим:

```cpp
if (x > 0 and y < 10 or not z) {
    // ...
}
```

Выглядит свежо! Хотя было доступно еще с С++98.

Вот полный список альтернативных токенов:

```
`&&` - `and`
`&=` - `and eq`
`&` - `bitand`
`|` - `bitor`
`~` - `compl`
`!` - `not eq`
`|` - `or`
`|=` - `or eq`
`^` - `xor`
`^=` - `xor eq`
`{` - `<%`
`}` - `%>`
`[` - `<:`
`]` - `:>`
`#` - `%:`
`##` - `%:%:`
```

Последние токены для скобок - это конечно дичь. Но остальные - вполне интересные варианты. 

В сях альтернативные токены были введены в С95, поэтому до этого момента токенов не было в языке. Но даже с их введением все продолжали использовать привычный синтаксис. Поэтому мы так до сих пор и остались на уровне наскальной живописи.

 Evolve. Stay cool.

#fun #goodoldc 


Последний элемент enum
#новичкам 

С enum'ами в С++ можно творить разное-безобразное. Можно легко конвертить элементы enum'а в числа и инициализировать их числом. Мы в это сейчас глубоко не будем погружаться, а возьмем базовый сценарий использования. Вам дано перечисление:

```cpp
enum class Color {
	kRed,
	kGreen,
	kBlue
};
```

И в каком-то месте программы вам нужно узнать размер этого перечисления. Вопрос: как в коде получить его размер?

В таком варианте, когда элементам enum'а явно не присвоены никакие числа, каждому из них присвоен порядковый номер, начиная с нуля. kRed - 0,  kGreen - 1, kBlue - 2.

Соответственно, чтобы получить количество элементов перечисления нужно сделать такую операцию:

```cpp
auto size = static_cast<int>(Color::kBlue) + 1;
```

Это работает, но выглядит что-то не очень. Читающий этот код конечно догадывается, что если мы хотим получить размер, то kBlue должен быть последним элементом. Но это вообще никем не гарантируется. Особенно, если в какой-то момент цветов станет больше:

```cpp
enum class Color {
	kRed,
	kGreen,
	kBlue,
	kBlack
};
```

И все. Код получения размера поломался. И надо везде его исправлять теперь. В общем, подход не расширяемый и требует модификации большого количество кода.

На этот случай есть проверенный прием: заранее вставлять в enum фейковый последний элемент, порядковый номер которого и будет равен размеру перечисления:

```cpp
enum class Color {
	kRed,
	kGreen,
	kBlue,
	kCount
};

auto size = static_cast<int>(Color::kCount);
```

В этом случае расширять enum нужно приписывая элементы перед kCount. А код получения размера не меняется.

Эта фишка повсеместно используется в реальных проектах, поэтому берите на вооружение.

Create extendable solutions. Stay cool.

#goodpractice #cppcore





https://t.me/c/2009887601/55452

зачем нужны свободные функции работы над атомиками

https://en.cppreference.com/w/cpp/language/operator_alternative.html



https://t.me/c/2009887601/52081


Концепты делают ошибки более читаемыми

Пример внутреннего кэша. filter_view

std::ranges::less и std::less разница при сортировке

Flexible array member

бесконечный цикл - уб

SPAM

кладутся ли на стек constexpr локальные переменные

std::filesystem введение

приватные инклюды и их директория

нужны .done файлы

inotify
Какая разница между спецификатором, модификатором, квалификатором, идентификатором, инициализатором?

https://youtu.be/O56xKKy34Do?si=rvmTFjXTenCdpzDX\