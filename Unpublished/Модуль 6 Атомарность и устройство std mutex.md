
ОРы:
- понимает как устроен мьютекс изнутри
- понимает мотивацию к std::atomic
- понимает что такое spinlock
- понимает ситуации взаимных блокировок livelocks

- применяет std::atomic для реализации спинлока


Структура:

- Показываем базовый пример защиты данных мьютексом. Говорим, что в начале поток получает эксклюзивный доступ, а затем потоки, которые хотят захватить занятый лок, отправляются спать . В этом уроке будем говорить про получение эксклюзивного доступа.
- Пробуем написать получение эксклюзивного доступа с помощью обычной переменной. Показываем пример, как можно зашедулить потоки, чтобы оба потока получили доступ к локу.
- Вся проблема в том, что в любой момент исполнение текущего потока может прерваться и другой поток может нарушить логику последовательного исполнения команд.
- Нужна такая инструкция, которая бы одновременно читала изменяла и записывала бы значения в переменную, чтобы другие потоки не смогли "увидеть" промежуточное состояние. Это можно сделать с помощью атомиков и конкретно std::atomic_exchange.
- Если мы не отправляем потоки спать, до использовав в функции получения эксклюзивного доступа std::atomic_exchange, мы получим полноценный механизм взаимного исключения - спинлок. Особенность спинлоков - активное ожидание и активное использование cpu.
- У спинлоков, как и у мьютексов тоже могут быть проблемы при попытке блокировать нескольких замков. Показываем пример, когда потоки берут по одному спинлоку, пытаются взять второй и при неудачной попытке - освобождают свои спинлоки. Таким образом потоки не перестают работать, но исполнение программы никуда не продвигается. Такая ситуация называется спинлок.

Введение

В одном из прошлых уроков вы уже изучили, что std::mutex может помочь синхронизировать доступ потоков к общему ресурсу. Сегодня мы посмотрим, что лежит под капотом std::mutex. Вы узнаете:

- как устроен std::mutex изнутри
- что такое атомарные операции и какая у них роль в реализации мьютекса
- что такое спинлок и как он позволяет организовать взаимное исключение потоков
- какая проблема может возникнуть при использовании спинлоков.

Контент

Посмотрим еще раз на то, как можно использовать std::mutex. Напишем упрощенную версию потокобезопасной std::map:

```cpp
template<Key, Value>
class ThreadSafeMap {
	std::mutex mtx;
	std::map<Key, Value> map;
public:
	void Insert(const Key& key, const Value& value) {
		std::lock_guard lg{mtx};
		map.insert(key, value);
	}

	Value& Get(const Key& key) {
		std::lock_guard lg{mtx};
		return map[key];
	}
};

ThreadSafeMap map;
std::vector<std:thread> vec;
for (int i = 0; i < 4; i++) {
	vec.emplace_back(&ThreadSafeMap::Insert, &map, std::to_string(i), i);
}
```

Вызов каждого метода мапы ограждается с помощью мьютекса. И когда мы пытаемся в нескольких потоках вставить значения в мапу, эти вставки происходят строго упорядоченно: только один поток в один момент времени производит вставку элемента в мапу. Попробуем расписать, как именно мьютекс ограничивает доступ к ресурсу:

- Несколько поток пытаются одновременно захватить мьютекс, но получается это только у одного потока. Этот поток получает эксклюзивный доступ к ресурсу.
- Исполнение остальных потоков приостанавливается(блокируются) до тех пор, пока мьютекс не будет освобожден.



Выберете код, который больше остальных приближен к тому, что происходит при захвате реального мьютекса:

Что может произойти, если несколько потоков изменяют общую переменную **без**`std::atomic`?

Как работает spinlock при попытке захвата заблокированного ресурса?

Два человека в коридоре пытаются разойтись, но постоянно зеркально повторяют движения друг друга.


Сниппет Напишите класс Spinlock и 2 его метода lock и unlock.