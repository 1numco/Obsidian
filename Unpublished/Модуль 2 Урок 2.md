
#### Введение

Концепция шаблонов классов и переменных идейно очень схожа с концепцией шаблонов функций. Они позволяют писать обобщенный, типобезопасный код и избежать его дублирования. Только шаблоны классов ориентированы не на операции, а на структуры данных. То есть если шаблоны функций позволяют реализовывать операции, которые могут работать с несколькими типами, то шаблон класса позволяет реализовывать классы, которые единообразно оперируют разными типами данных. А шаблоны переменных позволяют задавать значения переменным в зависимости от обрабатываемого типа.

Как и в случае функций, у шаблонов классов и переменных есть множество дополнительных возможностей кастомизации поведения. Про все это мы сегодня будем разговаривать.

Из этого урока вы узнаете:

- Как правильно определять шаблоны классов и переменных.
- Что такое зависимые типы
- Что такое шаблонные параметры по-умолчанию.
- Какие виды специализаций есть у шаблонов классов и переменных.


#### Шаблоны классов

Давайте разберем концепцию шаблонов класса сразу на примере. Есть такая структура данных - стек. Она работает по принципу "первый вошел - последний вышел". Или как стопка книг: легко взять ту, которую только что положили наверх, и чтобы взять самую нижнюю книгу, придется снять всю стопку.

Но у нее есть еще особенность: ее внутреннее хранилище можно реализовать с помощью любого последовательного контейнера из стандартной библиотеки. В разных случаях могут понадобиться хранилища на разных контейнерах.

Хотим ли мы писать свой класс стека для каждого используемого типа данных и контейнера под внутреннее хранилище? Вопрос риторический. Благо, нам на помощь приходят шаблоны. Давайте посмотрим, как мы можем реализовать шаблонный класс стека:

```cpp
template <typename T, typename Container>
class Stack {
public:
	// добавляем элементы в стек
    void push(const T& value) {
        storage_.push_back(value);
    }
    
	void push(T&& value) {
        storage_.push_back(std::move(value));
    }
	// достаем элемент из стека
    void pop() {
        storage_.pop_back();
    }
	// получаем доступ к верхнему элементу
    T& top() {
        return storage_.back();
    }

    const T& top() const {
        return storage_.back();
    }
	// проверяем стек на пустоту
    bool empty() const {
        return storage_.empty();
    }
	// получаем текущий размер стека
    size_t size() const {
        return storage_.size();
    }

private:
    Container storage_;
};
```

Обратите внимание, что мы используем ключевое слово typename для обозначения типов шаблонных параметров ровно также, как мы бы это делали для шаблона функции. Тип шаблонного параметра имеют право использовать все методы класса в качестве типов возвращаемого значения или параметров. 

Теперь наш стек может работать с любыми типами данных и любым шаблонным контейнером!

Однако есть несколько проблем в этом классе.

1 Хотелось бы иметь возможность создавать стек из последовательности элементов, задаваемой двумя итераторами. Причем итераторы также могут принадлежать любому шаблонному контейнеру. Что делать? 

Использовать шаблонный конструктор конечно! Давайте посмотрим, как можно объявить шаблонный метод внутри класса и определить его за границами описания класса:

```cpp
template <typename T, typename Container>
class Stack {
public:
	template<typename It>
	Stack(It first, It second);
// опустим все остальные поля и методы
};

template<typename T, typename Container>
template<typename It>
Stack<T, Container>::Stack(It first, It second) : storage_(first, second) {}
```

Обратите внимание на синтаксис определения шаблонного метода вне объявления шаблонного класса. 2 уровня шаблонности и 2 раз пишем ключевое слово template.

2 А почему мы уверены, что метод size() должен возвращать size_t? Или перегрузки методов top возвращать именно такую ссылку?
Если хорошо подумать, то станет понятно, что типы возвращаемых значений и аргументов методов стека зависят от типов возвращаемого значения и аргументов соответствующих методов конкретного контейнера, который мы выберем. 

Но как по конкретному шаблонному классу контейнера узнать, какие он использует типы?

Для этого существуют **зависимые типы**. Внутри публичной секции любого шаблонного/нешаблонного класса можно определить синонимы типов, которые внешний код может использовать, чтобы понять, с какими типами работает класс.

Факт: у каждого контейнера стандартной библиотеки есть набор синонимов типов, которые мы можем использовать в качестве конкретных типов возвращаемых значений и параметров методов. Тогда типы, с которыми работает стек, будут соответствовать типам, с которыми работает наше контейнер-хранилище.

Давайте посмотрим, как мы можем использовать зависимые типы контейнера и создавать свои специфичные для класса Stack, чтобы внешний код мог также ими пользоваться.

```cpp
template <typename T, typename Container>
class Stack {
public:
	using value_type = typename Container::value_type;
	using reference = typename Container::reference;
	using const_reference = typename Container::const_reference;
	using size_type = typename Container::size_type;

void push(const value_type& value) {
	storage_.push_back(value);
}

void push(value_type&& value) {
	storage_.push_back(std::move(value));
}

void pop() {
	storage_.pop_back();
}

reference top() {
	return storage_.back();
}

const_reference top() const {
	return storage_.back();
}

bool empty() const {
	return storage_.empty();
}

size_type size() const {
	return storage_.size();
}
private:
	Container storage_;
};
```

Обратите внимание на синтаксис. Если с шаблонными параметрами компилятор понимает, что это тип(и то только потому что мы так указатели с помощью `typename` внутри треугольных скобок на первой строчке кода), то с зависимыми типами - нет. И ему надо это объяснить. Поэтому нам необходимо указать ключевое слово `typename` перед упониманием зависимого типа, чтобы компилятор понял, что мы работаем именно с типом, а не с чем-то другим.

Теперь все типы параметров и возвращаемых значений методов шаблона класса Stack зависят от соответствующих типов хранилища.

А что будет, если выбранный контейнер не будет предоставлять зависимых типов?

Компилятор не найдет эти типы в шаблоне Container и будет соответствующая ошибка компиляции.

Это свойство шаблонов можно использовать. Для этого рассмотрим следующую проблему.

Теперь как будто шаблонный параметр Т нигде в коде не используется и его можно выкинуть. Все заменили на зависимые типы. В целом, так и есть, работать будет. Но в этом случае шаблонный параметр Т может служить нам для проверки на соответствие типа, которым оперирует контейнер. Для этой проверки мы тоже можем использовать зависимые типы.

Давайте определим 2 версии шаблонного класса SameType. Версия с двумя параметрами будет вообще пустой, а версия с одним параметром будет содержать только алиас типа type. 
```cpp
template<typename T1, typename T2>
struct SameType {
};

template<class T>
struct SameType<T, T> {
	// определяем зависимый тип type
	using type = T;
};
```

Здесь мы забегаем чуть вперед урока. Втора версия класса - это частичная специализация SameType. Но суть в другом.

Если в SameType передавать в точности одинаковые шаблонные параметры, то у этой версии класса появляется зависимый тип. А если передавать 2 разных, то типа не появляется. Помните, что будет, если компилятор не найдет зависимый тип? Будет ошибка компиляции.

И для нашего стека мы с помощью SameType можем сделать проверку на идентичность шаблонного параметра Т и типа, с которым работает контейнер. Это нужно для большей ясности и предоствращения неожиданностей. Если мы настроены создать стек с типом int, то и контейнер должен обязательно обрабатывать тот же тип.

Проверять можно следующим образом:

```cpp
template <typename T, typename Container, typename = typename SameType<T, typename Container::value_type>::type>
class Stack {/*тело класса*/};
```

Когда работаешь с шаблонами, слово `typename` начинает везде мерещиться, но это нормально. Если следовать правилам, что перед каждым зависимым типом должен стоять typename и для обозначения типового шаблонного параметра тоже используют это ключевое слово, то все становится понятно.  Синтаксис `typename =` - с пропуском перед `=` - это определение безымянного шаблонного параметра. Мы им нигде кроме этого места пользоваться не будем, поэтому и его имя нам не нужно.

Теперь:

```cpp
Stack<int, std::vector<int>> st; // OK
Stack<double, std::vector<int>> st1; // ОШИБКА: double не соответствует типу int
```
2


Теперь в нашем классе все типы согласованы. Давайте соберем все вместе:

```cpp
template<typename T1, typename T2>
struct SameType {
};

template<class T>
struct SameType<T, T> {
	using type = T;
};

template <typename T, typename Container, typename = typename SameType<T, typename Container::value_type>::type>
class Stack {
public:
	using value_type = typename Container::value_type;
	using reference = typename Container::reference;
	using const_reference = typename Container::const_reference;
	using size_type = typename Container::size_type;

	Stack() = default;

	template<typename It>
	Stack(It first, It second) : storage_(first, second) {}

	void push(const value_type& value) {
		storage_.push_back(value);
	}
	
	void push(value_type&& value) {
		storage_.push_back(std::move(value));
	}
	
	void pop() {
		storage_.pop_back();
	}
	
	reference top() {
		return storage_.back();
	}
	
	const_reference top() const {
		return storage_.back();
	}
	
	bool empty() const {
		return storage_.empty();
	}
	
	size_type size() const {
		return storage_.size();
	}
private:
	Container storage_;
};
```

#### Шаблоны переменных

Начиная с С++14 мы можем определять шаблоны переменных. Идея та же самая переменная может работать с разными типами и ее значение зависит от типа, с которым будет работать шаблон.

Часто нам нужно инициализировать новосозданные переменные с помощью каких-то инициализаторов по-умолчанию. 

```cpp
int num = 0;
std::string str = "";
```
Для каждого класса они разные, более сложные типы используют более громоздкие инициализаторы. И как-то не хочется думать о том, какой конкретный инициализатор выбрать в данном конкретном случае. Особенно это важно в шаблонном коде, когда мы не знаем наперед, с каким типом будем работать. Здесь нам на помощь приходят шаблоны переменной:

```cpp
template <typename T>
const T default_value = T{};
```

Синтаксис первой строчки ровно такой же как у шаблонов других сущностей. В остальном, все просто: на место конкретного типа при определении переменной мы ставим шаблонный параметр Т.

Теперь мы можем делать так:

```cpp
template<typename T>
const T get_default_value() {
	return default_value<T>;
}
```

Мы не знаем какой тип нам придет. Но теперь можем универсально их всех обрабатывать.

#### Шаблонные параметры по умолчанию

Давайте вернемся к нашему стеку. Хорошо, что мы параметризовали контейнер-хранилище. Но в большинстве случаев, нам не хочется думать о том, какой конкретный контейнер выбрать для стека. Хочется иметь значение по-умолчанию.

Шаблоны предоставляют такую возможность. Это называется шаблонный параметр по-умолчанию:

```cpp
template <typename T, typename Container = std::deque<T>, typename = typename SameType<T, typename Container::value_type>::type>
```

Теперь в базовом варианте мы может не указывать контейнер, с которым хотим создать стек:

```cpp
Stack<int> st; // OK, используем дефолтный std::deque
Stack<int, std::vector<int>> st1; // Также OK используем указанный std::vector
```

Шаблонные параметры по-умолчанию можно использовать также в шаблонах переменных и в шаблонах функций. Синтаксис и семантика одинаковы.

#### Полная специализация шаблонов классов и переменных.

Также как и у шаблонов функций, шаблоны классов и переменных можно полностью специализировать. И концепция та же: есть нам нужна другая реализация шаблона для конкретного типы, мы можем это устроить. 

Хрестоматийный пример. У нас есть шаблонный класс массива, который хранит указатель на начало последовательности и ее размер.

```cpp
template<typename T>
class Array {
// ...
private:
	T * data;
	size_t size;
};
```

Количество памяти, которое занимает последовательность элементов можно вычислить, как:

```
byte_count = size * sizeof(T);
```

Теперь мы скажем, что хотим хранить в массиве булевы значения. Не проблема, текущая реализация это позволяет сделать. Но эффективна ли она будет?

Не совсем. Тип bool занимает как минимум 1 байт, так как это минимально адресуемая ячейка памяти. Но логически он хранит всего 1 бит информации. Если бы мы могли как-то по-хитрому хранить булевы значения, чтобы каждое из них занимало всего 1 бит, то мы бы уменьшили потребление памяти как минимум в 8 раз!

Благодаря полной специализации класса Array для типа bool мы можем решить эту проблему. Будем хранить в классе не указатель на bool, а int*. В каждой ячейке памяти типа int можно будет хранить целых 8 * sizeof(int) булевых значений. И каждый раз при запросе значения элемента по индексу мы будем вычислять место того бита, который хранит нужное значение и возвращать его в виде bool.

```cpp
template<>
class Array<bool> {
public:
	explicit Array(size_t size)
		: data_(new int[size / bit_capacity + 1]) // целочисленное деление обрезает остаток. Чтобы его учесть добавляем еще одну int ячейку
		, size_(size) {}

	bool operator[](size_t idx) const {
		// здесь мы адресуем нужную int ячейку
		// затем получаем битовую маску с одной единственной единичкой на месте нужного нам бита
		// и логически умножаем два числа, чтобы получить реальное значение бита
		return data_[idx / bit_capacity] & (1 << (idx % bit_capacity));
	}
	~Array() { delete[] data;}
private:
	static const size_t bit_capacity = 8 * sizeof(int);
	int * data_;
	size_t size_;
};
```

Подробную реализацию этого класса мы вынесем за скобки. Здесь мы хотим отметить саму суть. Вы можете изменять внутреннее наполнение полной специализации класса, чтобы оптимальнее обрабатывать конкретные типы.

Шаблоны переменных тоже можно полностью специализировать.

Пусть в каком-то проекте активно используют класс Color. У него нет конструктора по умолчанию, потому что непонятно, что значит "пустой цвет". Однако у него есть конструктор от трех аргументов: чисел, которые R, G и B компоненты цвета. В проекте договорились, что для них белый цвет - (255, 255, 255).

В этом случае не получится использовать нашу шаблонную переменную дефолтного инициализатора. Но ее можно полностью специализировать для типа Color:

```cpp
template <typename T>
const T default_value = T{};

template<>
const Color default_value<Color> = Color(255, 255, 255);
```

Теперь наше значение по умолчанию может работать и с классом цвета!

### Частичная специализация

Помимо полной специализации, шаблоны классов и переменных можно частично специализировать. С ее помощью вы можете задать специфическое поведение не для конкретного типа, а для группы типов.

Начнет с простого, с шаблонов переменных. Для большей ясности при чтении кода хочется сделать так, чтобы наш дефолтный инициализатор присваивал nullptr указателям любого типа и только для них. В этом случае мы можем частично специализировать default_value для всех типов указателей:

```cpp
template <typename T>
const T* default_value<T*> = nullptr;
```

Здесь мы продолжаем указывать, что у нас есть шаблонный параметр Т, но после имени переменной в треугольных скобках уточняем группу типов, используя шаблонный параметр Т.

Такая же логика для классов. Пример: простой умный указатель аля std::unique_ptr. Ои могут работать, как с обычными типами, так и с типами массивов. Для типов массивов внутри деструктора вместо оператора delete нужно использовать delete[], иначе нарвемся на неопределенное поведение. Для этого мы можем частично специализировать класс умного указателя для типов массивов:

```cpp
template<typename T>
class smart_ptr {
public:
	smart_ptr() : ptr_{nullptr} {}
	smart_ptr(T * ptr) : ptr_{ptr} {}
	
	T * get() {return ptr_;}
	// для общего шаблона в деструкторе используем оператор delete для одного объекта
	~smart_ptr() {delete ptr_;}
private:
	T * ptr_;
};

// частичная специализация для массивов
template<typename T>
class smart_ptr<T[]> {
public:
	smart_ptr() : ptr_{nullptr} {}
	smart_ptr(T * ptr) : ptr_{ptr} {}
	
	T * get() {return ptr_;}
	// в деструкторе используем оператор delete[] вместо обычного delete
	~smart_ptr() {delete[] ptr_;}
private:
	T * ptr_;
};

smart_ptr<int> p1{new int{0}}; // здесь применится общий шаблон
smart_ptr<int[]> p2{new int[10]}; // здесь применится специализированный шаблон
```

Теперь шаблонный класс smart_ptr умеет корректно обрабатывать и обычные типы, и массивы.

#### Специализированные шаблоны классов

Небольшое дополнение по поводу специализированных шаблонов классов. При специализации шаблонов классов вы не ограничены наличием или отсутствие каких-либо членов в общем шаблоне класса. Вы можете добавлять новые необходимые поля или удалять ненужные. Вы также не ограничены фиксированной сигнатурой методов. 

В общем, специализированный шаблон класса - это фактически новый класс, который только логически связан с общим шаблоном.

Это явно видно видно по нашим прошлым примерам, но самый показательный из них этот:

```cpp
template<typename T1, typename T2>
struct SameType {
};

template<class T>
struct SameType<T, T> {
	// определяем зависимый тип type
	using type = T;
};
```

`type` - это тоже публичный член класса. Его не было в общем шаблоне. Да и в принципе, на существовании или отсутствии этого зависимого типа и держится вся логика этого семейства классов.

В специализациях вы можете как угодно изменять содержимое класса, если это необходимо для реализации соответствующего функционала.

По итогу урока, давайте повторим основные тезисы урока:

- шаблоны классов и переменных дополняют шаблоны функций и предоставляют дополнительные инструменты для написания обобщенного кода.
- зависимые типы шаблонов классов позволяют согласовывать используемые типы между классами.
- шаблонные параметры по-умолчанию позволяют задавать наиболее используемые стратегии поведения или типы, которые шаблон будет базово использовать.
- помимо полной специализации шаблонов для конкретных типов, для шаблонов классов и переменных существует еще и частичная специализация, которая позволяет изменять поведение шаблона для определенного набора типов.
- содержимое специализированных классов можно как угодно изменять.


