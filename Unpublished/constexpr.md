
Линковка constexpr с другими TU

Поступил запрос от подписчика Сергея на пост по поводу линковки constexpr функций, которые используют статические переменные, с другими единицами трансляции. Чтож, будем рассказывать.

Для начала определимся(а точнее вспомним(https://t.me/grokaemcpp/141)), что какое влияние ключевое слово constexpr оказывает на функции в плане линковки. Для функций constexpr подразумевает inline, поэтому мы уходит от первоначального вопроса к вопросу использования статических переменных в inline функциях. 

Использование может быть разным. Сегодня рассмотрим использование статических констант в непосредственно в теле функции. 

Приведу краткий рекап, но для более лучшего понимания процессов можете на достуге прочитать наш гайд по inline(ссылка в закрепе).

inline подразумевает внешнюю линковку. То есть другие единицы трансляции спокойно могут видеть определение сущности и взаимодействовать с ним. inline сущности могут иметь несколько определений в разных единицах трансляции. А компановщик после компиляции в итоговом бинарнике оставляет из всех лишь одно определение inline сущности. 

Статические же сущности уникальны для каждой единицы компиляции и никому не позволительно иметь к ним доступ при линковке. Эдакие эндемики своей TU.

Еще инлайн функции имеют свойство иногда встраиваться в код caller'а. В случае, если в данной TU встроены все вызовы функции, то компилятор на оптимизациях может разрешить себе вообще не генерировать никакого определения.

И тут мы приходим в первой ситуации: мы определили inline функцию в одной единице трансляции и пытаемся из другой единицы получить к ней доступ. Условно так:

```cpp
//first.cpp
static const int a = 3;
constexpr int gaga() {
	return a;
}

//second.cpp
int gaga();
void boo() {
	gaga();
}
```

Это дело в таком виде не соберется даже без оптимизаций. Функция boo будет отсылаться на несуществующий символ gaga. Можно провести ряд манипуляций, чтобы в таком виде генерировалось определение, но на оптимизациях компилятор все равно его выкинет и сборка зафейлится.

Мы не знаем, какие алгоритмы компилятору говорят, можно ли встроить эту функций в ее вызов или нет. Поэтому я бы вообще такой код не писал и даже дальше в проблемы копать не нужно.

А проблемы на самом деле есть.

Более подходящим и общеиспользуемым вариантом организации кода с inline сущностями является помещение их в хэдэры и подключение в те TU, где они будут использоваться. Выглядит это примерно так:

```cpp
//header.hpp
static const int const_var = 3;
constexpr int gaga() {
	return const_var;
}
//first.cpp
#include "header.hpp"
void boo() {
	gaga();
}

//second.cpp
#include "header.hpp"
void kak_delaut_gucy() {
	gaga();
}
```

Этот чудокод теперь собирается без проблем, компилятор встроит все вызовы и будет все хорошо. Но вот что будет, если фукнция gaga будет чуть сложнее для того, чтобы ее встраивать? Что будет, если для first.cpp и second.cpp компилятор все-таки будет генерировать определение gaga? 

А будет UB. Тут применимо вот такое правило.
```
If an inline function [...] with external linkage is defined differently in different translation units, the behavior is undefined.
```
Но почему же определения разные? Мы же один и тот же код с одной и той же константой просто копируем в нужные единицы трансляции. 

Только вот константы на самом деле разные. В каждой единице трансляции будет своя копия const_var и каждое определение gaga будет ссылаться на разные сущности-копии const_var.

В итоге останется одно определение функции, которое будет в себе содержать ссылку на локальную для единицы трансляции сущность. И любая другая единица трансляции может получается получить доступ к этой локальной сущности. Не уверен, что это вообще по-христиански.

Конечно, компилятор скорее всего оптимизирует использование такой простой переменной и все будет работать как ожидается. Но просто сам формат организации кода и зависимостей сущностей может привести к UB. Оно вам надо? Оно вам не надо.

Ярче эффекты могут проявиться не на константной переменной, а на обычной, изменяемой. Вот тут вы точно словите вагон и маленькое ведро неприятностей.

Так что лучше не мешайте статические и инлайновые сущности вместе. Опасный коктейль получается.

Sometimes mixing certain ingredients just won't work. Stay cool.

#cpp11 #cpcore



Фиксим неприятности

Сегодня коротко разберем, как обезопасить себя от проблем кода из предыдущего поста?

Просто надо использовать inline переменные! Но для этого понадобится С++17 и выше. Их и более менее все используют, но надо оговорку сделать.

Инлайн переменные также имеют внешнюю линковку, их определений может быть несколько в пределах одной программы, и по итогу компановщик также выберет одну из копий и весь остальной код будет ссылаться на нее. И в этом случае определение функции будет действительно единственным и доступным всем другим TU и это будет вполне легально.

Поэтому код будет выглядеть вот так:

```cpp
//header.hpp
inline constexpr int const_var = 3;
constexpr int gaga() {
	return const_var;
}
//first.cpp
#include "header.hpp"
void boo() {
	gaga();
}

//second.cpp
#include "header.hpp"
void kak_delaut_gucy() {
	gaga();
}
```

constexpr и const имеют одинаковый линковочный смысл для переменных, поэтому замена вполне корректна. Да и просто constexpr переменная лучше смотрится с constexpr функций.

Fix your flaws. Stay cool.

#cpp17


Правильно смешиваем static с inline

На мой взгляд предыдущее решение проблемы хоть и очень крутое, модное и молодежное, но иногда можно и лучше.

Например. Бывают случаи, когда в глобальную область выносят переменные, которые на самом деле не глобальные. Вообще, глобальные переменные - не самый хороший признак архитектуры кода. Они могут относиться к конкретным сущностям в коде, которые уже обособлены или могут быть выделены в будущем. Существование свободных функций хоть и допустимо, но всегда должно подвергаться сомнению. Возможно эти функции про какую-то отдельную сущность и их стоит выделить в класс. Тогда можно попробовать некоторые другие вещи, помимо inline.

Если свободные функции перенести внутрь описания класса и сделать их явно или неявно inline, то с точки зрения этой функции ничего не изменится. У нее также осталась внешняя линковка и в любой единице транляции будет ее определение.

Но вот теперь можно в ее теле попробовать использовать статические поля класса. [Здесь](https://t.me/grokaemcpp/133) мы обсудили, что они имеют внешнее связывание. Они либо аллоцированы в одной единице трансляции в случае если они не inline, либо во всех в случае inline. Использование дефолтного статического поля внутри инлайн функции будет готовить об использовании единственного экземпляра этого поля и все определения метода в разных единицах трансляции будут одинаковые. Использование inline статического поля внутри inline метода хоть и будет говорить о использовании разных копий одного и того же поля, но компановщик решит эту проблему и оставит в итоге только одну копию в единственном определении, на которую все будут ссылаться.
Выглядеть это может примерно так:

```cpp
//header.hpp
struct StrangeSounds {
	static constexpr int gaga() {
	  return krya;
	}
	static const int krya = 3;
};

//first.cpp
#include "header.hpp"
void boo() {
	StrangeSounds::gaga();
}

//second.cpp
#include "header.hpp"
void kak_delaut_gucy() {
	StrangeSounds::gaga();
}
```

Также не обязательно глобальная переменная принадлежит объекту. Они может принадлежать самой этой функции и больше нигде не использоваться. А нужна она была для сохранения состояния между вызовами функции. Тут очень напрашивается просто поместить эту статическую глобальную переменную и тогда она станет статической локальной переменной. С константами это конечно абсолютно бессмысленно делать, но для "переменных" переменных можно и это стоит упоминания. Тогда мы уже не можем говорить про constexpr(будет зависимость от рантаймового значения), поэтому дальше будем говорить только про inline

Статические локальные переменные не имеют никакой линковки(к ним нельзя получить доступ вне функции), поэтому не совсем понятно, корректно ли такая конструкция себя будет вести в инлайн функциях. И оказывается корректно:

```
Function-local static objects in all definitions 
of the same inline function (which may be 
implicitly inline) all refer to the same object 
defined in one translation unit, as long as the 
function has external linkage.
```

Нам гарантируют, что все определения инлайн функции будут ссылаться на одну и ту же сущность.

Выглядеть это может так:

```cpp
//header.hpp

inline int gaga() {
	static int krya = 3;
	return krya++;
}
//first.cpp
#include "header.hpp"
int boo() {
	return gaga();
}

//second.cpp
#include "header.hpp"
int kak_delaut_gucy() {
	return gaga();
}
```

В общем, смешивать inline и static - можно, но очень осторожно. Не противоречьте стандарту и никакое UB не овладеет вашим кодом.

Mix things properly. Stay cool.

#cpp17 #cppcore #compiler