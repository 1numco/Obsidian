
Инициализация в if и switch

Короче есть такая фича С++17. Называется init statement for if and switch. Английский лучше передает смысл через название. А смысл в том, что мы теперь можем внутри условия if и switch в начале инициализировать какой-то объект, а уже потом с учетом этого объекта составлять условие. Например, хотите вы вставить в мапу какую-нибудь штуку. А метод insert возвращает пару из итератора на вставленную штуку и булевый флаг, произошла ли реально вставка. В безопасных приложениях люди обычно проверяю может ли что-то пойти не так. Поэтому надо проверить, все ли хорошо вставилось. Ну и пишем:
```cpp
if (auto [iter, succeeded] = mymap.insert(value); succeeded) 
{
	use(iter); // ok
}
```
Тут как раз и structure binding повторим. Но не суть. По идее нам вот этот итератор надо бы обработать и больше не засорять им скоуп функции (он и место на стеке будет занимать, и имя будет занимать, и держать в голове его нужно будет, что вдруг он еще будет использоваться). А результат вставки вообще нигде, кроме проверки не будет использоваться. До С++17 мы бы писали так:
```cpp
auto pair = mymap.insert(value);
if (pair.second) 
{
	use(pair.first); // ok
}
```
Тут конечно всё в комбинации работает: и отсутствие инициализации, и отсутствие структурного связывания. Но зато разница прям заметна. Первое, что мне бросается в глаза - эти вонючие поля класса std::pair first и second. Он совершенно не говорящие и затрудняют понимание происходящего в коде. Можно было бы дать имена каждому элементу пары, но это еще сильнее увеличивает код и еще сильнее его засоряет. Но зато понятно, что происходит. Простите, что все сильнее говорю про structure binding, но просто в моменте подгорело. До С++17 мы засоряли скоуп этими парами и, потенциально, элементами этих пар.

В более простых случаях, мы почти всегда можем обойтись и без фичи инициализации. Во многих случаях мы просто проверяем возвращаемый код ошибки из функции. Типа того:
```cpp
bool process_status = obj.Process();
if (!process_status)
	std::cout << "Processing Failed!"
```

Вместо этого обычно пишут так:
```cpp
if (!obj.Process())
	std::cout << "Processing Failed!"
```
И все довольны.

Но не всегда можно так красиво выйти из ситуации. Особенно, когда возвращаемое из функции значение нужно потом использовать. Простой пример:

```cpp
const std::string myString = "My Hello World Wow";

const auto pos = myString.find("Hello");
if (pos != std::string::npos)
	std::cout << pos << " Hello\n"
```
Решением части проблем будет просто вынести обработку во вложенный скоуп.
```cpp
{
	const auto pos = myString.find("Hello");
	if (pos != std::string::npos)
		std::cout << pos << " Hello\n"
}
```
Но этот подход и другие проблемы привносит. Код стал объемнее. Да казалось бы на 2 символа. Но строчек стало больше на 2, отступы тоже стали больше. Все это визуально увеличивает "вес" кода, а значит затрудняет его восприятие.

На самом деле можно было сделать и так:

```cpp
if (const auto pos = myString.find("Hello") != std::string::npos)
	std::cout << pos << " Hello\n";
```

И все прекрасно работает. Но выглядит это не очень. Сходу непонятно, в каком порядке происходят сравнение и присваивание. Поэтому, это хоть и рабочий варинат, но так лучше не писать.

Но благо мы теперь можем писать коротко, четко и понятно.

```cpp
if (const auto pos = myString.find("Hello"); pos != std::string::npos) 
	std::cout << pos << " Hello\n";
```

Вывод такой, что фича прикольная, но я не так много примеров в реальном коде встречаю, где эта штука пригодится может. Большинство примеров на сайтах и в книжках примерно уровня куска кода про obj.Process(). Типа даем, в целом, ненужное имя какому-то rvalue и проверяем его. Но самый первые наш пример хорошо подходит под микрорефакторинг.

Stay laconic. Stay cool.

#cpp17 #goodpractice 

Инициализация в range-based for

Использование цикла range-based for может выглядеть примерно вот так:

```cpp
int main() {
    std::array data = {"hello", ",", "world"};

    std::size_t i = 0;
    for (auto& d : data) {
        std::cout << i++ << ' ' << d << '\n';
    }
}
```

Простой код, но мы коварные ребята и до всего сможем докопаться. Скоуп переменной `i` слишком большой. Переменная все еще доступна после цикла, хотя помимо него она больше нигде не используется. Можно переписать вот так:

```cpp
int main() {
    std::array data = {"hello", ",", "world"};

    for (std::size_t i = 0; i < data.size(); ++i) {
        std::cout << i << ' ' << data[i] << '\n';
    }
}
```

Но выглядит это все менее обобщенно и не так выразительно. Зря мы чтоли получали нормальный цикл по контейнеру?

Почему-то я всегда думал, что раз начиная с с++17 в if мы можем писать инициализатор, то и в range-based for можем. Но я оказался неправ. Эта фича оказалась доступна только с 20-х плюсах. Теперь мы можем писать вот так:

```cpp
int main() {
    std::array data = {"hello", ",", "world"};

    for (std::size_t i = 0; auto& d : data) {
        std::cout << i++ << ' ' << d << '\n';
    }
}
```

Если фича кажется малозначительной, то в целом так и есть. Однако в ее пропоузале приводился интересный пример, когда отсутствие инициализатора повышало  вероятность возникновения UB в коде. Давайте на него посмотрим:

```cpp
class Foo {
public:
    const auto& items() {
        return data;
    }

private:
    std::vector<const char*> data{"hello", ",", "world"};
};

Foo getFoo() {
    return Foo();
}

int main() {
    for (auto& d : getFoo().items()) {
        std::cout << d << '\n';
    }
}
```

Дайте себе несколько секунд, чтобы найти проблему. Нашли? Да вот же она, как раз в цикле for. Использование протухшей ссылки.

Как? Да очень просто.

Дело в том, что такой цикл разворачивается примерно в следующую конструкцию:

```cpp
const std::vector<const char*, std::allocator<const char*>>& __range1 = getFoo().items();

__gnu_cxx::__normal_iterator<const char* const*, std::vector<const char*, std::allocator<const char*>>> __begin1 = __range1.begin();
__gnu_cxx::__normal_iterator<const char* const*, std::vector<const char*, std::allocator<const char*>>> __end1 = __range1.end();

for (; __gnu_cxx::operator!=(__begin1, __end1); __begin1.operator++()) {
    const char* const& d = __begin1.operator*();
    std::operator<<(std::operator<<(std::cout, d), '\n');
}
```

На первой строчке мы сохраняем константную ссылку на временный объект, возвращенный из функции items(). А временные объекты имеют свойство удаляться после перехода к следующей строчке. Вот и получается, что для итерирования по контейнеру мы используем итераторы на несуществующий объект контейнера. Естественно, это UB.

Этой проблемы скорее всего не произойдет и умные внимательные дяди все-таки сохранят результат items() в свою переменную до цикла. Но это не решает проблемы засорения скоупа.

Поэтому инструкции инициализации в range-based for цикле приходятся очень кстати в таких кейсах.

Кстати. А задавались ли вы вопросом нужны ли инструкции инициализации в цикле while?

Наверное нужны, только это будет избыточно. while+инициализация выглядела бы так:

```cpp
while(size_t i = 0; some_condition) {...}
```

Это легко заменяется на классический for без указания инструкций, которые после каждой итерации выполняются:

```cpp
for(size_t i = 0; some_condition;) {...}
```

Даже короче получилось. Поэтому вряд ли это когда-нибудь войдет в стандарт.

Be irreplaceable. Stay cool.

#cpp20




Баг универсальной инициализации

В С++11 нам завезли прекрасную фичу - автоматический вывод типов с помощью ключевого слова auto. Теперь мы можем не беспокоится по поводу выяснения типа итераторов для какой-нибудь мапы от мапы о вектора и написания этого типа. Вместо этого можно просто сделать вот так:
```cpp
const auto it = map_of_map_of_vectors_by_string_key.find(value);
```

И тогда же ввели еще одну замечательную фичу - braced initialization. Она предотвращает парсинг вашей инициализации, как объявления функции, и убирает эффекты неявного приведения типов. Например, при компиляции такого кода

```
struct MyClass {
	int a = 0;
};

int main() {
	MyClass x();
	std::cout << x.a << std::endl;
}
```
компилятор выдаст что-то такое: warning: empty parentheses interpreted as a function declaration [-Wvexing-parse]

Ну вот захотел я вызвать дефолтный конструктор явно. А мое определение трактуют как объявление функции. Если круглые скобки заменить на фигурные, то все будет пучком.

Однако эта универсальная инициализация, как ее называет Майерс, принесла с собой и несколько багов. Один из них мы уже обсуждали в этом посте. Но сегодня посмотрим еще на один.

Вот хотим мы объявить целочисленную переменную и вдруг забыли как пишется int. Здесь мы сильно натягваем даже не сову, а прям воробья, на глобус. Пишем:

auto i{0};

Какой тип будет у i?

i будет иметь тип std::initializer_list\<int>. Снова проблема именно в синтаксисе определения std::initializer_list и фигурными скобками.

Такое поведение совсем контринтуитивное и мы ожидаем, что, как и в прошлом случае, выведется тип int. На@бка для у@бка, как говорится.

Считается, что фигурноскобочная инициализация - более предпочитаемый паттерн для использования, но такие приколюхи сильно снижают универсальность этого паттерна.

Скорее всего, на современных версиях компиляторов при -std=c++11 вы не получите этого бага. Этот момент я объясню в следующем посте.




Фикс баги с инициализацией инта.

В прошлом посте говорили об одной неприятности при использовании универсальной инициализации интов. При таком написании:

auto i = {0};

i будет иметь тип std::initializer_list\<int>. 

С++17 исправил такое поведение. Но для полного понимания мы должны определить два способа инициализации: копирующая и прямая. Приведу примеры

```cpp
	auto x = foo();  // копирующая инициализация
	auto x{foo()};  // прямая инициализация, проинициализирует initializer_list (до C++17)
	
	int x = foo();  // копирующая инициализация
	int x{foo()};  // прямая инициализация
```
Для прямой инициализации вводятся следующие правила:

• Если внутри скобок 1 элемент, то тип инициализируемого объекта - тип объекта в скобках.
• Если внутри скобок больше одного элемента, то тип инициализируемого объекта просто не может быть выведен.

Примеры:

auto x1 = { 1, 2 }; // decltype(x1) -  std::initializer_list<int> 
auto x2 = { 1, 2.0 }; // ошибка: тип не может быть выведен, потому что внутри скобок объекты разных типов
auto x3{ 1, 2 }; // ошибка: не один элемент в скобках
auto x4 = { 3 }; // decltype(x4) - std::initializer_list<int>
auto x5{ 3 }; // decltype(x5) -  int

Этот фикс компиляторы реализовали задолго до того, как стандарт с++17 был окончательно утвержден. Поэтому и даже если вы не используете с++17, вы не столкнётесь с этой проблемой.

Fix your flaws. Stay cool.

#cpp11 #cpp17 #compiler

