
ОРы:

- Понимает, как использовать Policy based pattern
- Понимает, как совместно использовать traits и tag dispatching
4 Идиомы шаблонов
- Template method pattern аля policy based pattern. Преимущество по сравнению с паттером стратегия. На примере логирования. Отсылка к стандартным алгоритмам.
- Traits. Определяем свойство, которому могут удоволетворять или не удовлетворять типы. На примере простого is_arithmetic. Переход к стандартным type_traits, перечисляем некоторые полезные из них.
- Tag dispatching. С помощью трейтов и перегрузок шаблонных функций выбираем нужную реализацию. Пример сериализации шаблонного ассоциативного контейнера в json с перенаправлением обработки элементов в функции для чисел, строковых типов(их сериализовывать нужно, оборачивая в кавычки) и массивов.
  
- ? DI с помощью шаблонов. На видео вариабельные шаблоны используются, поэтому это вообще логично к ним отнести. Есть пара опасений по поводу этой темы. 1 -  DI глобальных вещей довольно редко используется, никогда такого не видел и не слышал, чтобы кто-то логгер тестировал. 2 Это не уровень джуна, который на миддла хочет идти. Такой джун про DI возможно даже не знает. Без нормального объяснения для чего нужен DI + реальный показательный пример хотя бы с логгером займет целый урок. Да и в большинстве проектов тебя не поймут, если использовать этот мув. Возможно этот видос можно разместить, как полезный дополнительный материал. Но отдельно его хорошо раскрыть не получиться, учитывая сроки и объем уроков.

Type erasure




# Внутренняя информация

  

- [Внутренняя информация](#внутренняя-информация)

- [Текущий объём урока](#текущий-объём-урока)

- [ОРы](#оры)

- [Комментарии](#комментарии)

- [Материалы для студента (если нужны)](#материалы-для-студента-если-нужны)

- [Примерная структура](#примерная-структура)

- [Контент урока](#контент-урока)

- [Policy-Based Design](#policy-based-design)

- [Сниппет 1 (с проверкой)](#сниппет-1-с-проверкой)

- [Авторское решение для поддержки](#авторское-решение-для-поддержки)

- [Подсказка](#подсказка)

- [на что обратить внимание](#на-что-обратить-внимание)

- [Текст успеха](#текст-успеха)

- [Конец сниппета 1](#конец-сниппета-1)

- [Диспетчеризация по тэгам (tag dispatching)](#диспетчеризация-по-тэгам-tag-dispatching)

- [свойства типов (type traits)](#свойства-типов-type-traits)

- [Авторское решение для поддержки](#авторское-решение-для-поддержки-1)

- [Подсказка:](#подсказка-1)

- [Текст успеха](#текст-успеха-1)

- [Заключение](#заключение)

  

## Текущий объём урока

  

Number of characters: 1

Number of characters (no code): 2

Number of words (no code): 3

  

## ОРы

  

Название

  

- Использует policy based design в шаблонах.

- понимает tag dispatching

- Использует идиому type traits, в том числе совместно с tag dispatching

  
  

## Комментарии

  

## Материалы для студента (если нужны)

  

- Добавить текст из ссылки_1

- Добавить пояснение к термину А

  

## Примерная структура

  

- показываем пример policy based в сравнении со стратегией на виртуальных функциях

- пример диспетчеризации if-else в сравнении с простейшим случаем tag dispatching

- искусственный случай traits, затем улучшаем, автоматизируем tag dispatching

- в заключении говорим что эти идиомы редко применяются отдельно, но часто используются в комплексе с другими, особенно в старом коде, поэтому их надо хотя бы уметь узнавать.

- Сегодня они во многом замещены либо готовыми классами stl, либо новыми возможностями языка вроде constexpr if или концепты.

  

# Контент урока

  

Сегодня мы поговорим о самых простых и довольно распространённых идиом шаблонного программирования, которые базируются на уже изученных особенностях шаблонах функций и классов.

Сегодня вы познакомитесь:

  

- с использованием policy based design в шаблонах.

- с tag dispatching, и его использованием.

- с идиомой type traits, и её использованием, в том числе совместно с tag dispatching.

  

## Policy-Based Design

  

Попытки переиспользовать готовый код часто оборачиваются множеством деталей, в которых прячется дьявол. Вам всё нравиться в сетевом компоненте, но не нужно шифрование? или нужно, но другое? Несколько объектов используют общий функционал? Для юнит-тестов вам конечно требуется заменить часть используемых объектов заглушками.

Изменение поведения класса в некоторых аспектов, простое разделение классов на относительно слабо связанные части, давно стало общим местом, а монолитные гигантские классы множественное наследование как способ расширения функционала - дурным тоном. Сейчас мы говорим о том, как шаблоны помогают в поддержании адекватной структуры приложения.

  

Policy-Based Design (PBD) – это довольно старая идиома, позволяющая определять поведение класса через передаваемые ему политики (policy-классы). Это делает код более гибким и расширяемым. Его идея естественно вырастает из мысли, что тип параметра шаблона можно использовать как угодно, в том числе создавать или получать экземпляры этого типа, вызывать у этого типа методы.

Ту же задачу можно решить с помощью наследования, т.е замены базового класса – но это может привести к сложности в управлении, особенно при множественном наследовании.

Другой вариант шаблон стратегии, использующий в с++ виртуальные функции (Strategy Pattern) – но они требуют дополнительных затрат.

  

>немного о терминах.

Здесь у нас пересекаются шаблоны проектирования, шаблоны c++, и идиомы.

Постараемся их не путать.

Шаблоны, это инструмент языка с++

Шаблон проектирования стратегия - это типовой элемент низкоуровневой архитектуры приложения, в своё время популяризованный GoF. К конкретному языку программирования не привязан. Его активно применяли и до книги "банды четырёх", и для с++ он исторически получил первую популярную реализацию - на виртуальных функциях.

Идиомы программирования шаблонов, это тоже типовые решения, но более низкого уровня, и жёстко привязаны к шаблонам с++. Они могут сильно пересекаться с шаблонами программирования, но в основном выступают инструментами для их реализации. В случае PBD и стратегии пересечение очень велико.

  

Есть ещё специализация шаблонов, но это неудобно, если вариантов поведения много.

Мы сравним PBD с вариантом стратегии, как с самым популярным.

  

У нас есть класс, выполняющий некоторую работу (Worker), и мы хотим:

Позволить пользователям выбирать разные способы логирования (std::cout, файл, без логов).

Избежать нагромождения кода (if-ов и switch-ей).

Обеспечить оптимизацию на этапе компиляции.

  

Посмотрим сначала вариант со стратегией:

```cpp

#include <iostream>

#include <fstream>

#include <string>

#include <memory>

  

// Базовый интерфейс логгера

class ILogger {

public:

virtual void log(const std::string& message) = 0;

virtual ~ILogger() = default;

};

  

// Реализация логирования в консоль

class ConsoleLogger : public ILogger {

public:

void log(const std::string& message) override {

std::cout << "[Console] " << message << std::endl;

}

};

  

// Реализация логирования в файл

class FileLogger : public ILogger {

public:

void log(const std::string& message) override {

std::ofstream file("log.txt", std::ios::app);

file << "[File] " << message << std::endl;

}

};

  

// Реализация логирования в сеть

class NetworkLogger : public ILogger {

public:

void log(const std::string& message) override {

std::cout << "[Network] (pretend this is sent over network): " << message << std::endl;

}

};

  

// неподходящая политика, мы можем сразу увидеть, что здесь не тот интерфейс, что ожидает Logger, IWriter, а не ILogger

struct DBLogger: public IWriter {

void write(const std::string& message) {

std::ofstream file("log.txt", std::ios::app);

file << "[Data base] " << message << std::endl;

}

};

  

// Основной класс Logger

class Logger {

public:

Logger(ILogger* policy) : policy_(policy) {}

  

void logMessage(const std::string& message) {

policy_->log(message); // Виртуальный вызов

}

  

void setPolicy(ILogger* newPolicy) {

policy_ = std::move(newPolicy); // Динамическая смена стратегии

}

  

private:

ILogger* policy_; // Храним политику в виде указателя

};

  

// Использование

int main() {

auto consoleLogger = std::make_unique<ConsoleLogger>();

auto fileLogger = std::make_unique<FileLogger>();

auto networkLogger = std::make_unique<NetworkLogger>();

auto dbLogger = std::make_unique<DBLogger>();

  

Logger logger(consoleLogger.get());

logger.logMessage("Hello, console!"); // Логируем в консоль

  

logger.setPolicy(fileLogger);

logger.logMessage("Hello, file!"); // Логируем в файл

  

logger.setPolicy(networkLogger);

logger.logMessage("Hello, network!"); // Логируем в сеть

  

//logger.setPolicy(dbLogger);// не получится, несовместимы интерфейсы.

}

```

  

очевидные плюсы и минусы:

- большой плюс - выбор стратегии на этапе выполнения → можно менять логгер в setPolicy()

Но он не всегда нужен, хотелось бы не платить за него производительностью в таком случае.

- Виртуальные вызовы (policy->log()) → небольшие накладные расходы

  

создавать стратегию внутри не обязательно, недостатком не считаем.

  

Теперь Policy-Based:

Здесь ничего дополнительно не создаём, ничем не инициализируем, а указываем типы для шаблонного класса, настраиваем его.

  

```cpp

#include <iostream>

#include <fstream>

#include <string>

  

// Политики логирования (без наследования)

struct ConsoleLogger {

void log(const std::string& message) {

std::cout << "[Console] " << message << std::endl;

}

};

  

struct FileLogger {

void log(const std::string& message) {

std::ofstream file("log.txt", std::ios::app);

file << "[File] " << message << std::endl;

}

};

  

struct NetworkLogger {

void log(const std::string& message) {

std::cout << "[Network] (pretend this is sent over network): " << message << std::endl;

}

};

  

// неподходящая политика

struct DBLogger {

void write(const std::string& message) {//возможно, это клас создавали не предполагая,

что мы его используем как один из вариант политик, но пользователю этот функционал оказался нужен

std::ofstream file("log.txt", std::ios::app);

file << "[Data base] " << message << std::endl;

}

};

  

// Основной класс Logger, который использует политику

template <typename Policy>

class Logger {

public:

void logMessage(const std::string& message) {

policy.log(message);

}

private:

Policy policy; // Объект политики

};

  

// Использование

int main() {

Logger<ConsoleLogger> consoleLogger;

Logger<FileLogger> fileLogger;

Logger<NetworkLogger> networkLogger;

//Logger<Logger> networkLogger; ошибка, не подходит неявный интерфейс

  

consoleLogger.logMessage("Hello, console!");

fileLogger.logMessage("Hello, file!");

networkLogger.logMessage("Hello, network!");

}

```

  

Получается очень лаконичный и выразительный код. Хотя и он не без минусов, чтобы понять, можно ли типом DBLogger параметризовать Logger нужно посмотреть реализацию логгера, которая в нашем случае очень проста, но вообще может быть довольно сложной.

Посмотрим плюсы и минусы помимо особенностей кода:

- Выбор реализации происходит на этапе компиляции - здесь плюс- минус. Зависит от того, нужно ли изменение поведения во время работы кода.

- Отсутствуют виртуальные вызовы → больше производительность.

  

Очевидно, стратегию имеет смысл использовать, если менять поведение надо на ходу, а шаблонный Policy-Based лучше, если реализацию можно определить на этапе компиляции.

Теперь попрактикуемся в реализации:

  

У нас есть два класса генерирующих данные разным образом, и два класса по разному выводящих эти данные. Допишите DataProcessor так, чтобы он мог комбинировать способы генерации данных и записи. Возможность менять эту комбинацию во время работы программы - не требуется.

Для функционала генерации данных используйте имя ProcessingPolicy.

Для функционала вывода используйте имя OutputPolicy.

  

# Сниппет 1 (с проверкой)

  

```cpp

// классы генерации данных
struct FastProcessing {
	std::string process() const {
		return "Fast processing ";
	}
};

struct SafeProcessing {
	std::string process() const {
		return "Safe processing";
	}
};

// классы вывода данных
struct ConsoleOutput {
	void output(const std::string& result) const {
		std::cout << "Console: " << result << "\n";
	}
};

struct FileOutput {
void output(const std::string& result) const {
	std::ofstream file("output.txt", std::ios::app);
		file << "File: " << result << "\n";
	}
};

// здесь объединяем функциональность
class DataProcessor {
public:
	void execute() {
		auto res = processing.process();
		output.output(res);
	}
private:
};

// Использование

int main() {
	DataProcessor fastConsoleExecutor;
	DataProcessor fastFileExecutor;
	fastConsoleExecutor.execute(); // Fast processing -> Console output
	fastFileExecutor.execute(); // Fast processing -> File output
	
	DataProcessor safeConsoleExecutor;
	DataProcessor safeFileExecutor;
	safeConsoleExecutor.execute(); // Safe processing -> Console output
	safeFileExecutor.execute(); // Safe processing -> File output
	return 0;
}

```

  

# Авторское решение для поддержки

  

```cpp
// Основной класс с двумя шаблонными политиками
template <typename ProcessingPolicy, typename OutputPolicy>
class DataProcessor {
public:
	void execute() {
		auto res = processing.process();
		output.output(res);
	}
private:
	ProcessingPolicy processing;
	OutputPolicy output;
};

int main() {

  

DataProcessor<FastProcessing, ConsoleOutput> fastConsoleExecutor;

DataProcessor<FastProcessing, ConsoleOutput> fastFileExecutor;

fastConsoleExecutor.execute(); // Fast processing -> Console output

fastFileExecutor.execute(); // Fast processing -> File output

  

DataProcessor<SafeProcessing, ConsoleOutput> safeConsoleExecutor;

DataProcessor<SafeProcessing, ConsoleOutput> safeFileExecutor;

safeConsoleExecutor.execute(); // Safe processing -> Console output

safeFileExecutor.execute(); // Safe processing -> File output

}

  

```

  

# Подсказка

  

сделайте DataProcessor шаблоном, и параметризуйте типами нужных классов.

  

# на что обратить внимание

  

Здесь нет подводных камней, просто используйте имена параметров шаблона как типы.

Сделайте имена этих параметров осмысленными.

  

# Текст успеха

  

Замечательно, в вашем арсенале теперь ещё один способ собирать сложный функционал из простых компонентов, и наоборот, разделать код на простые переиспользуемые и легко тестируемые части.

  

# Конец сниппета 1

  

## Диспетчеризация по тэгам (tag dispatching)

  

Мы уже много говорили о перегрузке функции, и совместном использовании шаблонов классов и функций, здесь речь идёт о ещё одной старой как сами шаблоны идиоме, основанной на их совмещении, - диспетчеризации по тэгам (tag dispatching). В некоторых случаях она может заменить довольно грустную картину перенаправления вызова функции в зависимости от фиксированного параметра.

  

```cpp

auto h0() { std::cout << "h0\n"; }

auto h1() { std::cout << "h1\n"; }

auto h2() { std::cout << "h2\n"; }

  

static const int option = 1;// каким то образом определена константа, которая не изменится без перекомпиляции.

auto h() {

if (option == 0)

h0();

else if (option == 1)

h1();

else

h2();

}

```

  

вместо этого, когда всё известно на этапе компилляции, можно использовать перегрузку функций, причём с фальшивым параметром, "тэгом"

Мы создаем структуры-теги и перегружаем функции, принимая разные теги.

  

```cpp

#include <iostream>

  

struct tag1 {};

struct tag2 {};

  

void f(int a, tag1) {

std::cout << a << " via tag1\n";

}

  

void f(int a, tag2) {

std::cout << a << " via tag2\n";

}

  

int main() {

f(1, tag1{}); // Выбирается первая перегрузка

f(1, tag2{}); // Выбирается вторая перегрузка

}

```

  

Здесь видим очевидные преимущества:

  

- Компилятор выбирает нужную функцию на этапе компиляции

- Отсутствует проверка условий во время выполнения

- Можно расширять код, добавляя новые теги и перегрузки

  

Если вспомнить, какой сложной и неоднозначной может быть перегрузка функций с использованием шаблонов - появляется ещё одна причина использовать эту идиому - упрощение перегрузки функций.

Может возникнуть вопрос, выбор по константе - довольно экзотический случай.

все эти сложности не нужны, если всё равно приходятся явно описывать способ разрешения перегрузки с помощью тэга, не проще ли просто изменить имя функции? Добавить в конец имени тот же тэг?

И вообще, при чём здесь шаблоны?

  

```cpp

#include <iostream>

  

void ftag1(int a) {

std::cout << a << " via tag1\n";

}

  

void ftag2(int a) {

std::cout << a << " via tag2\n";

}

  

int main() {

ftag1(1); // Выбирается код первой перегрузки

ftag2(1); // Выбирается код второй перегрузки

}

  

```

Можно. будет работать. и если у нас изолированный код, от которого нам ничего не нужно, кроме однократного использования, так будет проще, никаких лишних структур и параметров функций. Просто вместо того, чтобы изменять в коде тэг - изменим имя функции.

А вот если мы хотим автоматизировать выбор реализации функции, нам нужно одно, общее имя. И шаблоны.

Это имеет смысл, если такая функция нужна хотя бы в двух местах.

  

```cpp

template<typename T>

void complexFunction() {

f(1, T{});

// какая то логика.

f(someValue, T{});

}

  

int main() {

complexFunction<tag1>();//внутри для f выбираются реализации для tag1

}

```

А ещё в complexFunction может быть несколько разных функций, f1, f2, и так далее, которые можно согласованно настраивать параметром тэга. А ещё это может быть класс вроде:

```cpp

template<typename TagType>

class SomeWorker

{

public:

void process(){

f1(value,TagType);

}

void prepare(){

fn(anotherValue,TagType);

}

};

```

Ну да, это всё не выглядит полезным.

Эти абстрактные примеры приведены главным образом чтобы показать, что в шаблонах диспетчеризация тэгов становится действительно рабочим инструментом управления.

  

Как и многие другие простейшие приёмы, в таком виде эта идиома используется редко, чаще её можно увидеть в сочетании с другими. Поэтому, к ней мы вернёмся чуть позже.

  

## свойства типов (type traits)

  

А пока поговорим о type traits. Тоже в самом простом и старом виде.

Идея проста, и состоит из двух частей:

  

1 - в параметре шаблона передаём класс, который специально создан как пакет разнообразных настроек, типов и констант. Можно сказать, что это какое то абстрактное "свойство"

  

2 - делаем специализации такого

шаблона для конкретных типов, меняя значения полей в "свойстве". Вот эта специализация уже указывает чьё свойство мы сделали.

  

В какой шаблон передаём такой класс? Не важно, в шаблон класса или функции, работает одинаково хорошо, но в функциях чаще используется вывод типов параметров шаблонов, и сколь угодно сложная шаблонная автоматизация оказывается скрытой от глаз пользователя.

Ниже пример, как видите, простой int внутри функции становится целым набором свойств, и даже функцией.

Обратите внимание на пустой базовый traits, специализация подразумевает, что есть какой то исходный шаблон.

  

```cpp

#include <iostream>

  

// Базовый traits (пустой)

template <typename T>

struct TypeTraits; // нужен неспециализированный шаблон, который теперь можно специализировать.

  

// Специализация для int

// связываем int с нашими типами, константой, и функцией

template <>

struct TypeTraits<int> {

using tag = int;

using type = long;

static constexpr int value = 100;

static void specialAction(){

//

}

};

  

// Функция, использующая traits

template <typename T>

void process(const T& val) {

// int ничего не знает о наших определённых для него типах, значении value, и даже специально для него сделанной функции

// но функция вместе с ним получает TypeTraits<int>, а значит и его поля, типы, и функции, если они есть.

std::cout << "Processing " << val << " with type: " << typeid(typename TypeTraits<T>::type).name()

<< " and limit: " << TypeTraits<T>::value << std::endl;

TypeTraits<int>::specialAction();

}

  

int main() {

process(42); // Работает

// process("hello"); // Ошибка компиляции: TypeTraits<std::string> не определён

}

```

  

Как видите, type traits уже позволили получать множество информации, связанной с типом совершенно прозрачно для пользователя шаблона, process(42) выглядит как просто вызов функции с числовым параметром.

  

Конечно, traits можно использовать без всякой связи с диспетчеризацией тэгов, но совместно эти две техники дают больше, чем по отдельности. Давайте соберём что то полезное из наших шестерёнок и пружин!

  

Следующий пример показывает, как шаблонная функция благодаря type traits может автоматизировать диспетчеризацию тэгов.

  

```cpp

  

// Определяем теги

struct IntTag {};

struct FloatTag {};

  

// Простая реализация traits

template <typename T>

struct traits {};

  

template <>

struct traits<int> {

using tag = IntTag;

};

  

template <>

struct traits<float> {

using tag = FloatTag;

};

  

// Перегрузки для работы с разными типами

void process(int value, IntTag) {

std::cout << "Processing int: " << value << std::endl;

}

  

void process(float value, FloatTag) {

std::cout << "Processing float: " << value << std::endl;

}

  

// Универсальная функция, использующая Type Traits

template <typename T>

void process(T value) {

process(value, typename traits<T>::tag{});

}

  

int main() {

process(42); // Вызывает process(int, IntTag)

process(3.14f); // Вызывает process(float, FloatTag)

}

```

  

traits\<T> сопоставляет тип данных с тегом.

Функция process(T value) автоматически выбирает нужный тег и передает его.

  

Здесь мы получили несколько плюсов:

  

- Не нужно передавать tag вручную – компилятор сам выбирает, небольшая автоматизация

- добавить поддержку новых типов не намного сложнее, чем без traits, но код стал более выразительным и приобрёл новые свойства.

- можно ещё добавить, такой подход отлично сочетается с шаблонами.

  

Однако, если мы однозначно int превращаем в tag, почему не перегрузить сразу функцию по int, а не tag?

  

Потому что не всегда однозначно.

У нас теперь есть промежуточная концепция, которая связывает тип параметра функции process и одну из специализаций traits. Это значит, что один тэг можно поставить в соответствие нескольким типам, другими словами - классифицировать их.

Например, к IntTag отнести все целые числа, обрабатывать их общим образом, а FloatTag использовать для самых разных чисел с плавающей точкой. Можно добавить ещё категорию каких то особых классов которые должны попадать в особую реализацию функции process.

  

```cpp

struct SpecialClassTag{};// новых тэг для новой категории обрабатываемых типов

  

// классы, которые надо обработать.

struct SomeClass1{/* какая то пользовательская реализация */};

struct SomeClass2{/* какая то пользовательская реализация */};

  

template <>

struct traits<SomeClass1> {// связываем обрабатываемый тип с тэгом

using tag = SpecialClassTag;

};

  

template <>

struct traits<SomeClass2> {

using tag = SpecialClassTag;

};

  

// Перегрузка для работы с группой особых классов

void process(int value, SpecialClassTag) {

std::cout << "Processing int: " << value << std::endl;

}

// Перегрузки для работы с разными типами

void process(int value, IntTag) {

std::cout << "Processing int: " << value << std::endl;

}

  

void process(float value, FloatTag) {

std::cout << "Processing float: " << value << std::endl;

}

  

// Универсальная функция, использующая Type Traits

template <typename T>

void process(T value) {

process(value, typename traits<T>::tag{});

}

  

int main() {

process(42); // Вызывает process(int, IntTag)

process(3.14f); // Вызывает process(float, FloatTag)

SomeClass1 sc1;

SomeClass2 sc2;

process(sc1);

process(sc2);//оба класса приводят к одной перегрузке по SpecialClassTag

}

  

```

Теперь попробуйте самостоятельно дополнить реализацию подобного совмещения tag dispatching и type traits.

  

Ниже заготовка кода, которая должна по разному обрабатывать указатель, и не указатель, выводя соответствующие сообщения.

  

Сниппет 2 (с проверкой)

```cpp

#include <iostream>

  

struct pointer_tag {};

struct non_pointer_tag {};

  

// TODO: Реализуйте type_category для общего случая (не указатель)

template<typename T>

struct type_category {

/* Ваш код здесь */

};

  

// TODO: Реализуйте специализацию type_category для указателей

template<typename T>

struct type_category<T*> {

/* Ваш код здесь */

};

  

template<typename T>

void process_impl(T, non_pointer_tag) { std::cout << "Non-pointer type\n"; }

  

template<typename T>

void process_impl(T, pointer_tag) { std::cout << "Pointer type\n"; }

  

// TODO: Допишите функцию process, используя tag dispatching через type_category<T>::type

template<typename T>

void process(T t) {

/* Ваш код здесь */

}

  

int main(){

int main(){

int x = 42;

int* p = &x;

process(x);

process(p);

return 0;

}

  

```

# Авторское решение для поддержки

  

```cpp

#include <iostream>
struct pointer_tag {};
struct non_pointer_tag {};

template<typename T>
struct type_category {
	using type = non_pointer_tag;
};

template<typename T>
struct type_category<T*> {
	using type = pointer_tag;
};

template<typename T>
void process_impl(T, non_pointer_tag) { std::cout << "Non-pointer type\n"; }

template<typename T>
void process_impl(T, pointer_tag) { std::cout << "Pointer type\n"; }

template<typename T>
void process(T t) {
	process_impl(t, typename type_category<T>::type{});
}

  

```

# Подсказка:

  

Доработайте функцию так, чтобы при вызове с различными типами аргументов выводились правильные сообщения.

  
  

# Текст успеха

Слышали, что на шаблонах можно улететь в космос? Примите поздравления, вы успешно стартовали.

  

## Заключение

  

- Сегодня мы научились:

- Использовать policy based design в шаблонах. С их помощью можно гибко настраивать код, меняя реализацию его частей без затрат на виртуальные функции.

- разбирать и понимать tag dispatching, это позволяет упрощать перегрузку функций, и разбираться в более сложных приёмах шаблонного программирования.

- использовать идиому type traits, в том числе совместно с tag dispatching, что даёт возможность автоматизировать согласование параметров шаблонов, и сокращать количество параметров шаблонов, делать ошибки компиляции более понятными.

  

Эти идиомы имеют свои условия применения, очень важны для понимания готового кода, и как подводящие примеры, для более сложных концепций, используемых в шаблонах, которые мы рассмотрим на следующих занятиях.