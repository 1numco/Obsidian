
ОРы:

- Понимает, как использовать Policy based design pattern
- Понимает, как совместно использовать traits и tag dispatching
4 Идиомы шаблонов
- Template method pattern аля policy based design pattern. Преимущество по сравнению с паттером стратегия. На примере логирования. Отсылка к стандартным алгоритмам.
- Traits. Определяем свойство, которому могут удоволетворять или не удовлетворять типы. На примере простого is_arithmetic. Переход к стандартным type_traits, перечисляем некоторые полезные из них.
- Tag dispatching. С помощью трейтов и перегрузок шаблонных функций выбираем нужную реализацию. Пример сериализации шаблонного ассоциативного контейнера в json с перенаправлением обработки элементов в функции для чисел, строковых типов(их сериализовывать нужно, оборачивая в кавычки) и массивов.
  
- ? DI с помощью шаблонов. На видео вариабельные шаблоны используются, поэтому это вообще логично к ним отнести. Есть пара опасений по поводу этой темы. 1 -  DI глобальных вещей довольно редко используется, никогда такого не видел и не слышал, чтобы кто-то логгер тестировал. 2 Это не уровень джуна, который на миддла хочет идти. Такой джун про DI возможно даже не знает. Без нормального объяснения для чего нужен DI + реальный показательный пример хотя бы с логгером займет целый урок. Да и в большинстве проектов тебя не поймут, если использовать этот мув. Возможно этот видос можно разместить, как полезный дополнительный материал. Но отдельно его хорошо раскрыть не получиться, учитывая сроки и объем уроков.

Type erasure



## Ведение 

Шаблоны - настолько уникальный инструмент в арсенале С++ разработчиков, что за время использования языка для применения шаблонов возникли свои паттерны. Несколько ближайших уроков мы будем с ними знакомиться

Сегодня вы изучите:

- Как реализуется полиморфизм времени компиляции с помощью policy based design pattern?
- Что такое трейты и как они помогают определять характеристики типов?
- Как на основе трейтов перенаправлять исполнение в нужную функцию с помощью tag dispathing?

### Policy Based Pattern

В прошлом мы с вами в основном говорили про то, что шаблоны могут универсально обрабатывать различные типы данных. Хранить данные разных типов в структурах данных или выполнять однотипные операции для разных типов.

Но что, если нам нужно не универсально обрабатывать данные, а нам хочется самим указывать, как правильно в данный момент нужно данные обработать?

Конечно же в мире программирования это популярная задача и для нее есть несколько решений.

Самое популярное - паттерн Стратегия. Это паттерн объктно-ориентированного программирования, основанный на виртуальном функциях и динамическом полиморфизме. Мы можем переопределять поведение потомков базовой стратегии и при вызове метода стратегии по ссылке или указателю на базовый класс выберется правильная переопределенная реализация. Так мы сможем не меняя интерфейса или клиента адаптивно подстраивать поведение программы.

Посмотрим на пример. Для наблюдения за тем, что происходит в программе, нужен логгер. Лог должен уметь писать сообщения в консоль или в файл, в зависимости от нашего желания. Чтобы это сделать, в конструкторе логгера мы можем ему передавать указатель на базовый класс стратегии логирования, которая будет в себе инкапсулировать логику записи сообщений в конкретный пункт назначения.

```cpp
// Базовый интерфейс стратегии

class LogStrategy {
public:
	virtual void log(const std::string& message) = 0;
	virtual ~LogStrategy() = default;
};

// Реализация логирования в консоль
class ConsoleLog : public LogStrategy {
public:
	void log(const std::string& message) override {
		std::println(message);
	}
};

// Реализация логирования в файл
class FileLog : public LogStrategy {
public:
void log(const std::string& message) override {
	// здесь будет запись в файл
}

// Основной класс Logger
class Logger {
public:
	Logger(std::unique_ptr<LogStrategy> strategy) : strategy_(std::move(strategy)) {}
	
	void logMessage(const std::string& message) {
		policy_->log(message); // Виртуальный вызов
	}
private:
	std::unique_ptr<LogStrategy> strategy_; // Храним политику в виде умного указателя
};

auto consoleLogger = std::make_unique<ConsoleLog>();
auto fileLogger = std::make_unique<FileLog>();
Logger logger(std::move(consoleLogger));
logger.logMessage("Hello, console!"); // Логируем в консоль
Logger logger1(std::move(fileLogger));
logger1.logMessage("Hello, file!"); // Логируем в файл
```

При создании объекта мы указываем ему нужную стратегию, которой он дальше пользуется. Заметим, что логгер может использовать любую стратегию логирования из иерархии LogStrategy.

В чем недостатки такого подхода?

**КНОПКА:** Я знаю ответ!

Каждый раз при вызове метода стратегии мы платим за виртуальный вызов метода. Для высоконагруженных приложений это может быть неподъемной платой.

Раз нам не подошел динамический полиморфизм, может быть нам подойдет статический?

Давайте взглянем на шаблоны с немного другой стороны. Ведь если шаблон может оперировать различными типами, то эти типы и могут содержать логику по изменению поведения приложения.

Параметризация шаблона функции или класса с помощью типа, который будет диктовать шаблону не "что нужно обрабатывать?", а "как нужно обрабатывать?", называется Policy based design pattern. Или по простому паттерн Политика. 

Давайте посмотрим, как можно логгеру указать политику поведения с помощью шаблонного параметра.

```cpp
// Политики логирования (без наследования)
struct ConsoleLogger {
	void log(const std::string& message) {
		std::println(message);
	}
};

struct FileLogger {
	void log(const std::string& message) {
		// здесь будет запись в файл
	}
};

// Основной класс Logger, который использует политику

template <typename Policy>
class Logger {
public:
	void logMessage(const std::string& message) {
		policy.log(message);
	}
private:
	Policy policy; // Объект политики
};

// обязательно указываем политику в качестве шаблонного параметра
Logger<ConsoleLogger> consoleLogger;
Logger<FileLogger> fileLogger;  
consoleLogger.logMessage("Hello, console!"); // логируем в консоль
fileLogger.logMessage("Hello, file!"); // логируем в файл
```

По сути, мы с вами достигли того же результата. Класс Logger может обрабатывать сообщения так, как этого хочет политика. 

При этом никаких виртуальный функций и соответствующего оверхэда. Ловкость рук, шаблоны и никакого мошенничества!

Политиками также можно параметризовать шаблоны функций. Показательным примером здесь являются стандартные алгоритмы. Возьмем объявление функции std::sort:

```cpp
template<typename RandomIt, typename Compare>  
void sort( RandomIt first, RandomIt last, Compare comp);
```

С помощью шаблонного параметра Compare и аргумента функции comp мы можем диктовать функции сортировки, как сравнивать элементы последовательности между собой. Это ведь тоже уже знакомый нам паттерн политики!

Простота в использовании политик определила его популярность этого подхода. Поэтому это чуть ли не самый часто используемый паттерн шаблонов в С++.

### Traits

В одном из прошлых уроков мы создали шаблонный класс, который может сравнивать типы друг с другом:

```cpp
template<typename T1, typename T2>
struct SameType {
};

template<class T>
struct SameType<T, T> {
	// определяем зависимый тип type
	using type = T;
};
```

На самом деле мы тогда создали общее свойство для двух шаблонных параметров: если эти параметры представляют собой один и тот же тип, то у класса SameType появляется зависимый тип type.

Давайте по аналогии напишем подобное свойство для одиночного шаблонного параметра, которые бы говорило нам, является ли данный тип указателем.

```cpp
template<typename T>
struct PointerTrait {
	bool is_pointer = false;
};
template<typename T>
struct PointerTrait<T*> {
	bool is_pointer = true;
	using object_type = T;
};
```

Немножко добавили деталей. Теперь поле класса is_pointer будет говорить нам о том, является ли тип указателем или нет. А с помощью частичной специализации класса PointerTrait для указателей мы определяем вторую реализацию, в которой устанавливаем is_pointer в true и определяем зависимый тип object_type, в который сохраняем тип объекта под указателем.

Теперь мы можем узнавать, является ли данный тип указателем, реализовывать логику в зависимости от результата проверки, а также на этапе компиляции запрещать функциям работать с указательными типами :

```cpp
template<typename T, typename = typename PointerTrait<T>::object_type>
void printOnlyPointerValue(const T& val) {
	std::println("pointer value is {}", value);
}

template<typename T>
void printIsPointer(const T& val) {
	if (PointerTrait<T>::is_pointer) {
		std::println("val is a pointer");
	} else {
		std::println("val is a value");
	}
}

int x = 42;
int* p = &x;
printIsPointer(x); // выведется "val is a value"
printIsPointer(p); // выведется "val is a pointer"
printPointerValue(p); // возможный вывод "pointer value is 0x7fff76634ca4"
// printPointerValue(x); // Здесь будет ошибка компиляции из-за того что у общего шаблона PointerTrait, инстанцированного с типом int, нет зависимого типа object_type
```

Такие свойства, которые характерны одиночным типам или сочетаниям типов, называются трейтами(Traits).

В стандартной библиотеке реализовано большое множество уже готовых трейтов, которые могут быть очень полезны при работе с шаблонами.

Вот некоторые примеры стандартных трейтов:

- [is_integral](https://en.cppreference.com/w/cpp/types/is_integral "cpp/types/is integral")- трейт, определяющий является ли данный тип целым числом (числа + bool).
- [is_pointer](https://en.cppreference.com/w/cpp/types/is_pointer "cpp/types/is pointer")- трейт, определяющий является ли данный тип указателем(теперь вам не нужно писать его самим)
- [is_reference](https://en.cppreference.com/w/cpp/types/is_reference "cpp/types/is reference") - трейт, определяющий является ли данный тип ссылкой(правой или левой)
- [is_same](https://en.cppreference.com/w/cpp/types/is_same "cpp/types/is same") - трейт, проверяющий два типа на равенство (да и это тоже есть в стандарте)
- [is_base_of](https://en.cppreference.com/w/cpp/types/is_base_of "cpp/types/is base of") - трейт, проверяющий является ли один тип базовым классом другого

Увидеть их всех вы можете по [этой ссылке](https://en.cppreference.com/w/cpp/header/type_traits).

Трейты - это очень мощное средство, которое сильно упрощает шаблонное программирование и позволяет писать отдельные реализации для типов с определенными свойствами.