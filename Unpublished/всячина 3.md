No new line

Оказывается, чтобы получить неопределенное поведение даже необязательно писать какой-то плохой код. Достаточно просто не добавить перенос строки в конце подключаемого файла!

Небольшой пример:

```cpp
Файлик foo.hpp:

// I love code
// I love C++<no newline>

Файлик bar.cpp:

#include "foo.hpp"
#include "baz.hpp"

```

А теперь вспоминаем, что препроцессор вставляет все содержимое хэдера на место инклюда И(!) не вставляет после него символ конца строки. То есть спокойно может получится следующее:

```cpp
// I love code
// I love C++#include "baz.hpp"
```

То есть включение baz.hpp может быть полностью заэкранивано.
Учитывая, сколько всего препроцессор может делать с кодом, комбинации вариантов развития событий могут быть абсолютно разными

Стандарт нам говорит:
```
... If a source file that is not empty does not end in a new-line character, or ends in a new-line character immediately preceded by a backslash character before any such splicing takes place, the behavior is undefined.
```

Так что ub без кода - вполне существующая вещь. 

Или уже нет?

На самом деле приведенная цитата была из стандарта 2003 года.

С++11 пофиксил эту проблему и обязал препроцессоры вставлять new line в конце :

```cpp
A source file that is not empty and that does not end in a new-line character, or that ends in a new-line character immediately preceded by a backslash character before any such splicing takes place, shall be processed as if an additional new-line character were appended to the file.
```

Так что теперь проблемы нет.

Решил написать об этом, просто потому что очень весело, что в плюсах можно было такими неочевидными способами отстрелить себе конечность.

Ну и хорошо, что стандарт все-таки не только новую функциональность вводит, а фиксит вот такие вот недоразумения.

Fix your flaws. Stay cool.

#compiler

**Виртуальные функции в compile-time**
#опытным

Виртуальные функции являются средством реализации динамического полиморфизма в С++. Почему он вообще называется динамическим?

Да потому что выбор конкретной реализации происходит в рантайме, а не во время компиляции.

Но что, если я вам скажу, что мы можем реализовывать полиморфизм времени компиляции с помощью виртуальных функций?

Выглядит как оксюморон, но подождите кидаться грязными тряпками. Сейчас все разберем.

Начиная с С++11 у нас есть constexpr функции. Эти функции могут быть вычислены на этапе компиляции, если их аргументы также известны на этом этапе. Аргументы могут быть константами, литералами, constexpr переменными или результатом вычисления других constexpr функций.

```cpp
constexpr int double_me(int n)
{
    return n * 2;
}
static_assert(double_me(4) == 8); // условие верное и мы не падаем
static_assert(double_me(4) == 7); // условие ложно и компиляция прервется на этой строчке
```

В примере мы определяем constexpr функцию double_me и проверяем с помощью [static_assert](https://t.me/grokaemcpp/214)'а то, что она вычисляется во время компиляции.

Изначально constexpr функции были довольно ограничены по возможностям своего применения. Однако с новыми стандартами спектр применений расширяется, так как все больше операций из стандартной библиотеки можно проводить в compile-time. Сейчас даже с контейнерами в complie-time можно работать. Но мы сейчас не об этом.

Начиная с С++20 constexpr функции могут быть виртуальными!

```cpp
struct VeryComplicatedCaclulation
{
    constexpr virtual int double(int n) const = 0;
};

struct Impl: VeryComplicatedCaclulation
{
    constexpr virtual int double(int n) const override
    {
        return 2 * n;
    }
};

constexpr const VeryComplicatedCaclulation& impl_ref = Impl{}; // для полиморфизма с виртуальными функциями нужна ссылка

constexpr auto a = impl_ref.double(4);
static_assert(a == 8); // true
```

Все как мы привыкли: делаем иерархию классов с виртуальной функцией, только везде на всех этапах приписываем constexpr. И это работает!

А где это может быть использовано, посмотрим в следующий раз.

Increase your usability. Stay cool.

#cpp11 #cpp20

**Виртуальные функции в compile-time** Ч2
#опытным 

Сходу не очень понятны кейсы применения полиморфизма на виртуальных функциях во время компиляции. У нас как бы есть шаблоны, которые прекрасно работают. Так какие применения у constexpr виртуальных функций?

constexpr виртуальные функции могут помочь перенести больше вычислений в компайл тайм. [Предложение в стандарт](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1064r0.html) по этому поводу содержит следующий пример:

В стандартной библиотеке есть отличный класс std::error_code. Но он не идеальный . Он не поддерживает вычисления в compile-time. Стандартную библиотеку не поправишь, но мы можем первое улучшение - сделать свой error_code с блэкджеком и constexpr:

```cpp
class error_code
{
private:

    int val_;
    const error_category* cat_;

public:

    constexpr error_code() noexcept;
    constexpr error_code(int val, const error_category& cat) noexcept;
    template<class ErrorCodeEnum>
    constexpr error_code(ErrorCodeEnum e) noexcept;

    constexpr void assign(int val, const error_category& cat) noexcept;
    template<class ErrorCodeEnum>
    constexpr error_code& operator=(ErrorCodeEnum e) noexcept;
    constexpr void clear() noexcept;

    constexpr int value() const noexcept;
    constexpr const error_category& category() const noexcept;
    constexpr explicit operator bool() const noexcept;

    error_condition default_error_condition() const noexcept;
    string message() const;
};
```

Второе улучшение, которое мы можем сделать - устранить ограничение error_code от захардкоженого в ноль значения успеха операции. Существуют категории ошибок, которые считают все неотрицательные значения успешными, и есть (по общему признанию, очень редкие) другие, в которых ноль является неудачей. Чтобы решить эту проблему, мы уже имеем механизм - внутри error_code есть указатель на базовый класс `error_category*`, наследникам которого мы и можем делигировать принятие решения о том, является ли значение ошибкой или нет.

```cpp
class error_category
{
public:
    // ...
    virtual bool failed(int ev) const noexcept;
    // ...
};

// И добавляем метод в класс error_code
class error_code
{
    // ...
    bool failed() const noexcept { return cat_->failed(val_); }
    // ...
};
```

Однако не-constexpr виртуальные функции ломают наше желание разрешить использовать error_code во время компиляции. Благо в С++20 мы можем их пометить constexpr и все заработает как надо!

Также шаблоны - конкуренты выртуальных функций - имеют одну противную особенность. Глаза хочется выкинуть, когда видишь шаблонный код. Виртуальные функции compile time'а могут в определенных кейсах заменить шаблоны и помочь увеличить читаемость кода.

Не стоит забывать и про кодогенерацию. С ее помощью мы можем включать в код по сути все, что мы хотим. Можно хоть из файла конфигурации сгенерить хэдэр, в котором будет переменная, содержащая весь этот конфиг. Для разных, но все же похожих, сгенерированных сущностей могут быть нужны полиморфные обработчики. Вот здесь отлично вписываются виртуальные constexpr функции.

Самому мне еще не удавалось их применять. Однако у нас в канале очень много крутых спецов. Если у вас был опыт использования этой фичи - поделитесь в комментах.

Increase your usability. Stay cool.

#cpp20

Неочевидное преимущество шаблонов
#новичкам 

Мы знаем, что шаблоны используются как лекарство от повторения кода, а также как средство реализации полиморфизма времени компиляции. Но неужели без них нельзя обойтись?

Можно и обойтись. Возьмем хрестоматийный пример std::qsort. Это скоммунизденная реализация сишной стандартной функции qsort. Сигнатура у нее такая:

```cpp
void qsort( void *ptr, std::size_t count, std::size_t size, /* c-compare-pred */* comp );
extern "C" using /* c-compare-pred */ = int(const void*, const void*);  
extern "C++" using /* compare-pred */ = int(const void*, const void*);
```

Как видите, здесь много `void *` указателей на void. В том числе с помощью него достигается полиморфизм в С(есть еще макросы, но не будем о них).

Как это работает?

Функция qsort спроектирована так, чтобы с ее помощью можно было сортировать любые POD типы. Но не хочется как-то пеерегружать функцию сортировки для всех потенциальных типов. Поэтому придумали обход. Передавать void указатель, чтобы мочь обрабатывать данные любых типов. Но void* - это нетипизированный указатель, поэтому фунции нужно знать размер типа данных, которые она сортирует, и количество данных. А также предикат сравнения.

Вот тут немного поподробнее. Предикат для интов может выглядеть примерно так:

```cpp
[](const void* x, const void* y)
        {
            const int arg1 = *static_cast<const int*>(x);
            const int arg2 = *static_cast<const int*>(y);
            const auto cmp = arg1 <=> arg2;
            if (cmp < 0)
                return -1;
            if (cmp > 0)
                return 1;
            return 0;
        }
```

Предикату не нужно передавать размер типа, потому что он сам знает наперед с каким данными он работает и сможет закастить void* к нужному типу.

Вот в этом предикате и проблема. Функция qsort не знает на этапе компиляции, с каким предикатом она будет работать. Поэтому компилятор очень ограничен в оптимизации этой части: он не может заинлайнить код компаратора в код qsort.

Тип шаблонных параметров, напротив, известен на этапе компиляции. Значит код код компаратора шаблонной функции может быть включен в код сортировки. Именно поэтому функция std::sort намного быстрее std::qsort при включенных оптимизациях.

Казалось бы плюсы, а быстрее сишки. И такое бывает, когда используешь шаблоны.

Use advanced technics. Stay cool.

#template #goodoldc #goodpractice #compiler


Частичная специализация шаблонов функций
#опытным 

Во многих образовательных ресурсах на русском и английском языке я видел, как рассказывают про частичную специализацию шаблонов функций. Ресурсы конечно не очень авторитетные, но если читать про шаблоны в стандарте, то голова вспухнет. Давайте сейчас проясним этот момент.

Частичной специализации шаблонов функции не существует. И точка!

То, что называют выдают за нее - это обычная перегрузка шаблонных функций.

Звучит, как пустяковая проблема. Какая разница, как назвать молоток, если им все равно можно забить гвоздь?

Безусловно, вы правы. Большинству разработчиков такие тонкости знать не нужно. Но мы ведь тут грокаем С++, у нас больше трети постов про такие тонкости. Поэтому погнали.

Шаблонные функции, как и обычные функции, можно перегружать. Логично было принести этот функционал в шаблоны, ибо перегрузки могут быть вообще не связаны ни одним общим параметром.

```cpp
void f(int) { std::cout << "int-overload" << std::endl; }; 
void f(int*){ std::cout << "int-p-overload" << std::endl; }

template<class T> void f(T) { std::cout << "T-overload" << std::endl; }; 
template<class T> void f(T*){ std::cout << "T-p-overload" << std::endl; }

```

Заметьте, что синтаксис одинаковый с точностью до появления template\<class T> и замены конкретного типа на шаблонный параметр.

Частичная специализация же характерна только для шаблонов классов и переменных. 

```cpp
template<typename T>
class Foo {};

template<typename T>
class Foo<T*> {};
```

И в специализированном классе мы должны показать с помощью треугольных скобок, для какой подгруппы типов мы специализируем шаблон. И это обязательно. Специализация должна показать, что она именно специализация какого-то общего шаблона. Ведь перегрузок шаблонов классов не бывает:

```cpp
template <typename T1>
struct Foo<T1> {};
// Так нельзя делать, это несвязанные шаблоны
template <typename T1, typename T2>
struct Foo<T1,T2> {};
```

С этим разобрались. Давайте посмотрим, что будет, если мы попытаемся частично специализировать шаблон функции:

```cpp
template<class T> void f(T) { std::cout << "T-overload" << std::endl; }; 
template<class T> void f(T*){ std::cout << "T-p-overload" << std::endl; }

template<class T> void f<T*>(T*){std::cout << "T-p-specialization" << std::endl;}
```

Ну и как компилятору выбирать между T-p-overload и T-p-specialization?

Частичная специализация вводит неоднозначность в порядок разрешения перегрузок функции. Поэтому ее не существует. Но ее функционал полностью покрывает перегрузка, так что можно и не рыдать(кто бы собирался).

На самом деле без понимания того, какими способами можно изменить поведение шаблона, нельзя нормально понять, как компилятор выбирает правильного кандидата для вызова. Это тонкости, но на высоком уровне тонкости все больше и больше роляют.

Don't be confused. Stay cool.

#template #cppcore 


Перегружаем шаблоны классов
#опытным 

В прошлом посте я говорил, что нельзя перегружать шаблоны классов.

В принципе, это логично. Если у вас класс принимает другие шаблонные параметры, то скорее всего это должен быть другой класс. 

Но как и любая задача в программировании, все можно решить введя дополнительный уровень абстракции.

Особенности вариадик шаблонов - их можно специализировать для любого набора и комбинации шаблонных параметров.

```cpp
template <typename... T>
struct Foo;

template <typename T1>
struct Foo<T1> {};

template <typename T1, typename T2>
struct Foo<T1,T2> {};

```

Мы просто вводим вариабельный класс-пустышку и специализируем его с любым количеством типов.

Вот такие фокусы.

Однако у этого способа есть ограничения. Элементы пака параметров должны быть так скажем одного вида. То есть вы не можете специализировать этот шаблон с типовым и нетиповым параметром:

```cpp
template <typename T, int N>
struct Foo<T, N> {}; // forbidden 
```

Но все равно это хороший инструмент, которым можно пользоваться.

Hack the boundaries. Stay cool.

#template #cppcore


Квиз

Сегодня будет интересный #quiz из малоизвестной области плюсов. А именно дефолтные параметры виртуальных методов. У них немного неинтуитивное поведение. Так что давайте проверим, насколько ваша интуиция вам врет.

Правильный ответ показывать сразу не буду, пусть останется интригой до завтрашнего поста с объяснениями.

У меня к вам всего один вопрос. Каков результат попытки компиляции и запуска следующего кода под С++20?

```cpp
#include <iostream>
struct base {
	virtual void foo(int a = 0) { std::cout << a << " "; }
	virtual ~base() {}
};

struct derived1 : base {};

struct derived2 : base {
	void foo(int a = 2) { std::cout << a << " "; }
};

int main() {
	derived1 d1{};
	derived2 d2{};
	base & bs1 = d1;
	base & bs2 = d2;
	d1.foo();
	d2.foo();
	bs1.foo();
	bs2.foo();
}
```

Challenge your life. Stay cool.

Варианты ответа:

Ошибка компиляции

UB

0 0 0 0 

0 2 0 0

0 0 0 2

0 2 0 2


Дефолтные параметры виртуальных методов
#опытным 

Как и в обычных функциях и методах класса, в виртуальных методах тоже можно определять параметры по-умолчанию. Однако, они могут вести себя не совсем так, как вы этого ожидаете.

Правильный ответ из поста выше - `0 2 0 0 `.

```cpp
#include <iostream>
struct base {
	virtual void foo(int a = 0) { std::cout << a << " "; }
	virtual ~base() {}
};

struct derived1 : base {};

struct derived2 : base {
	void foo(int a = 2) { std::cout << a << " "; }
};

int main() {
	derived1 d1{};
	derived2 d2{};
	base & bs1 = d1;
	base & bs2 = d2;
	d1.foo();
	d2.foo();
	bs1.foo();
	bs2.foo();
}
```

Дело вот в чем. Если реализация виртуальных методов выбирается по динамическому типу, то выбор дефолтных параметров определяется статическим типом. 

То есть, если мы вызываем метод у объекта наследника(или через ссылку, или указатель), то выбирается дефолтное значение метода наследника.

А если мы вызываем метод по указателю или ссылке на базовый класс, то дефолтное значение будет взято из объявления метода в базовом классе.

Из-за такого поведения в коммьюнити не принять переопределять дефолтные параметры виртуальных методов в наследниках, потому что это может сильно осложнить отладку.

Вообще говоря, если так хочется задать значение по-умолчанию, то возможно стоит рассмотреть перегрузку с последующим перенаправлением вызова в общую реализацию. Но это уже по ситуации нужно смотреть, чтобы не плодить много виртуальных методов.

Или можно использовать [идиому публичного невиртуального интерфейса](https://t.me/grokaemcpp/89). Тогда ваш публичный метод будет устанавливать значения по умолчанию и их никто не сможет переопределить, потому что метод будет сам невиртуальный.

Слышится легкое: "Эх, я когда-нибудь смогу выучить плюсы?...".

Don't be confusing. Stay cool.

#cppcore 



noexcept
#новичкам 

Гарантии безопасности исключений - важная штука в С++. И если мы как-то на уровне кода можем показать коллегам и компилятору, что функция не бросает исключений - это надо делать.

Эту задачу решает спецификатор noexcept. С его помощью мы указываем, что не предполагается, что функция может бросать исключения.

```cpp
void doSomething() noexcept;
```

noexcept также принимает опциональный булевый параметр - выражение. В основном это показывают примерно так:

```cpp
void doSomething() noexcept(true);
void doSomething() noexcept(false);
```

Но в этом виде это особо не имеет практического смысла. Этот опциональный параметр реально может сыграть роль в шаблонном коде, когда для одних типов выражение вычисляется в true, а для других в false. Тогда мы можем гибко генерировать более безопасный с точки зрения исключений код для первых типов и обычный для вторых.

Внимание! Очень важное уточнение. Если мы пометили функцию noexcept, это не значит, что она не бросает исключений. Она может это делать, только будут последствия. При вылете любого исключения из небросающей функции будет вызван std::terminate. И никакие try-catch вам не помогут.

Также стандарт не гарантирует раскрутку стека и вызов деструкторов локальных объектов в этом случае.

Именно поэтому помечайте функции noexcept только тогда, когда точно знаете, что ни при каких условиях она не выбросит. Иначе приложение просто упадет без какой-либо внятной ошибки.

Если вы не уверены в гарантиях безопасности исключений функции, просто не помечайте ее и все. Ничего плохого в этом нет. Если мы живем с исключениями, то надо свыкнуться с мыслью, что каждая функция может бросить исключение.

Ходят слухи, что пометка noexcept разрешает компилятору некоторые оптимизации. Может в каких-то кейсах это и так, но бежать, сломя голову, метить свои функции noexcept, мечтая, что код ваш код будет бежать быстрее скорости звука, не стоит.

Вот где noexcept действительно важен - это специальные методы класса, а конкретно мув-конструктор и перемешающий оператор присваивания. Пометив их noexcept, вы разрешаете [вектору при реаллокации перемещать элементы](https://t.me/grokaemcpp/125), функции своп менять местами переменные с помощью мув-семантики и многое другое. Стандартная библиотека старается давать сильную гарантию исключений(commit or rollback), поэтому для нее очень важны небросающие перемещающие методы класса.

Stay safe. Stay cool.

#cppcore #cpp11 #STL


std::move_if_noexcept
#опытным 

В [этом посте](https://t.me/grokaemcpp/125) мы рассказали о том, что noexcept конструктор позволяет разрешить перемещения элементов при реаллокациях std::vector. Однако даже если ваш мув-конструктор определен, но не помечен noexcept, и нет копирующего конструктора, то вектору все равно разрешается перемещать элементы. За это ответственна функция std::move_if_noexcept. Сегодня приоткроем завесу тайны, за счет чего происходит такая магия.

Вот реализация этой функции в gcc:

```cpp
template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };

  template<typename _Tp>
    [[__nodiscard__,__gnu__::__always_inline__]]
    constexpr
    __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
```

Две части: условия мува и сам мув.

Все работает буквально на одних type trait'ах. Если условие move_if_noexcept_cond правдиво, то результат мува кастуется к константной левой ссылке, чтобы в итоге мува в итоге не произошло. Если ложное, то результат кастится к правой ссылке, что и разрешает мув.

Условие move_if_noexcept_cond истинно только в одном случае: когда мув-конструктор бросающий и есть копирующий конструктор. Получается, что это единственная ситуация, когда мува не произойдет. Во всех остальных случаях значение скастуется к правой ссылке.

Не спрашивайте меня, почему условие мува как будто бы перевернутое. Странное решение. Если кто знает, поясните в комментах.

Кстати тут есть интересный момент. Если класс move_constructible, то это не значит, что у него есть мув конструктор! move_constructible всего лишь значит, что объект можно скрафтить из правой ссылки. А правые ссылки могут приводиться к константным левым ссылкам. И даже если ваш класс не будет иметь мув-конструктора, но его копирующий конструктор принимает константную левую ссылку, то этот класс будет удовлетворять условию is_move_constructable:

```cpp
struct NoMove1
{
    // prevents implicit declaration of default move constructor;
    // however, the class is still move-constructible because its
    // copy constructor can bind to an rvalue argument
    NoMove1(const NoMove1&) {}
};
static_assert(std::is_move_constructible_v<NoMove1>); // Here
static_assert(!std::is_trivially_move_constructible_v<NoMove1>);
static_assert(!std::is_nothrow_move_constructible_v<NoMove1>);
 
struct NoMove2
{
    // Not move-constructible since the lvalue reference
    // can't bind to the rvalue argument
    NoMove2(NoMove2&) {}
};
static_assert(!std::is_move_constructible_v<NoMove2>); // And here
static_assert(!std::is_trivially_move_constructible_v<NoMove2>);
static_assert(!std::is_nothrow_move_constructible_v<NoMove2>);
```

То есть использование трейта std::is_nothrow_move_constructible на классе, не имеющем мув-конструктора, абсолютно легально.

В общем, просто хотел рассказать про эти два интересных момента. Это может быть важно при проектировке своих структур данных.

Don't believe in magic. Stay cool.

#template #cppcore #STL


Что будет если бросить исключение в деструкторе? Ч1
#новичкам 

Вопрос, который часто задают на собеседованиях, но боюсь, что мало кто понимает правильный ответ.

Значит единственный адекватный ответ - вызовется std::terminate. И здесь даже не нужно упоминать никаких double exception. То есть:

```cpp
struct Class {
	~Class() {throw 1;}
};
int main() {
	try {
		{Class cl;}
	} catch(...) {
		std::cout << "caught exception" << std::endl;
	}
}
```

В этом случае исключение не поймается, а просто вызовется std::terminate. И точка. Никаких дополнений.

Первое надо понимать, что деструкторы неявно компилятором помечены, как noexcept. То есть не предполагается, что он выбрасывает исключения. 

Если вы определяете деструктор дефолтным, то он noexcept. И даже если вы определяете кастомный деструктор, но не указываете ему политику исключений, он все равно помечен noexcept.

Однако мы можем сделать деструктор бросающим. Мы должны явно прописывать политику исключений:

```cpp
struct Class {
	// HERE
	~Class() noexcept(false) {throw 1;}
};
int main() {
	try {
		{Class cl;}
	} catch(...) {
		std::cout << "caught exception" << std::endl;
	}
}
```

Только в этом случае на консоли появится `caught exception`.

И вот здесь уже можно говорить, что будет при раскрутке стека, втором исключении и прочем.

**Пока вы явно не пометили деструктор бросающим, при вылете исключения из деструктор будет вызван std::terminate.**

Be explicit in your intentions. Stay cool.

#cppcore #cpp11 #interview 
 

Что будет если бросить исключение в деструкторе? Ч2
#новичкам 

Теперь мы разобрались с основным кейсом. Давайте подробнее рассмотрим, что будет, если мы будет работать с явно бросающими деструктором.

Единственный важный вопрос, который здесь можно задать: а что будет, если деструктор вызовется при раскрутке стека?

Вот так:

```cpp
struct Class {
	// HERE
	~Class() noexcept(false) {throw 1;}
};
int main() {
	try {
		Class cl;
		throw 1.0;
	} catch(...) {
		std::cout << "caught exception" << std::endl;
	}
}
```

В этом случае при бросании 1.0, исключение увидит блок catch и перед входом в него начнет раскручивать стек, вызывая деструкторы всех локальных объектов во всех фреймах, которые пролетело исключение. 
В нашем коде деструктор Class будет вызван до блока catch и получается, что у нас ситуация, в которой есть 2 необработанных исключения. Эта ситуация называется double exception и она приводит к немедленному вызову std::terminate.

Именно поэтому вы не должны бросать исключения в деструкторах. Именно поэтому все деструкторы по умолчанию noexcept. Потому что невозможно безопасно работать с классом, у которого бросающий деструктор, в мире, где другие сущности тоже могут сгенерировать исключения.

Теперь вы профессионально будете отвечать всем интервьюерам, заслужите много уважения и конфеты(но это не точно).

Stay safe. Stay cool.

#cppcore #cpp11 #interview 


Mutable
#новичкам 

Это ключевое слово - один из самых темных уголков С++. И не то, чтобы очень важный уголок. Вы вполне ни разу могли с ним не сталкиваться. Но тем не менее по какой-то причине интервьютеры часто задают вопрос: "для чего предназначен mutable?". Ответит человек или нет особо никак не показывает его навыки программиста, лишь знание узких мест языка. Но раз такие вопросы задают, то вы должны быть готовы к ответу на них. Поэтому и родился этот пост.

Проблема вот в чем. Есть константный объект. Как вы знаете, поля константного объекта запрещено изменять. Но это довольно сильное ограничение. Да, не хотелось бы, чтобы инвариаты класса менялись. Однако помимо комплекса полей класса, представляющих собой инвариант класса, в объекте могут храниться другие поля, которые не входят в этот инвариант.

И вот мы имеем дело с тем, что нам хочется иметь семантическую константность, когда защищаем от изменения только те поля, которые должны быть неизменными в константном объекте. Но по дефолту нам дана синтаксическая константность, которая запрещает изменения любых нестатических полей.

```cpp
class ThreadSafeLogger {
    std::atomic<int> call_count = 0;
public:
    void log(const std::string& msg) const {
        call_count++; // Error! Changing class field in const member-function
        // logging
    }
};
```

В этом логгере мы хотим подсчитать количество логирований на протяжении времени жизни объекта. Одна мы не можем этого сделать, потому что нам запрещено изменять поля в константных методах.

Что же делать?

Вот тут как раз, mutable ~~Валера~~, настало твое время.

Помечая ключевым словом mutable поле класса вы разрешаете менять его в константных методах:

```cpp
class ThreadSafeLogger {
    mutable std::atomic<int> call_count = 0;
public:
    void log(const std::string& msg) const {
        call_count++; // Works fine
        // logging
    }
};
```

Теперь мы можем изменять счетчик даже в константном методе.

В целом, на это все о функциональности этого ключевого слова.

В каких кейсах его можно применять?

1 Сбор статистики вычислений в объекте. Пример выше как раз об этом. Для сбора статистики могут использоваться и более сложные сущности, типа оберток над  [известными системами мониторинга](https://habr.com/ru/articles/709204/)(аля prometheus).

2 Если вы хотите [потокобезопасные константные методы](https://t.me/grokaemcpp/71). Вам могут понадобиться мьютексы и/или кондвары, которые придется пометить mutable, чтобы их можно было использовать в константных методах.

3 Кэш. Результаты предыдущих вычислений никак не влияют на инвариант класса, поэтому внутренний кэш класса можно пометить mutable, чтобы кэш можно было использовать в константных методах.

```cpp
class SomeComputingClass {
    mutable std::unordered_map<Key, Result> cache;
public:
    Result compute(const Key& key) const {
        if (!cache.contains(key)) {
            cache[key] = /* actual computing */;
        }
        return cache[key];
    }
};
```

Из популярного все. Если кто знает узкий кейсы применения mutable, просим пройти в чат.

Ну все, никакой гадкий интервьюер вас не завалит. Ваше кунг-фу теперь сильнее его кунг-фу.

Surprise your enemy. Stay cool.

#cppcore #interview 

Mutable. А зачем?
#опытным 

В прошлом посте мы рассказали, для чего используется ключевое слово mutable. Однако все же этот инструмент нарушает привычное поведение полей константных объектов. Да, есть семантическая и синтаксическая константность. Но вот проблема: когда у вас в арсенале есть инструмент, который позволяет обходить ограничения, то высока вероятность появления соблазна использовать этот хак не по назначению.

Поля классов в константных методах не должны меняться! Не просто так это правило придумано. В неумелых руках  mutable может использоваться, как сглажевание косяков дизайна. В принцпе классика: в начале пишется говнокод, потом пишется другой говнокод, чтобы исправить косяки изначального говнокода. Зато быстро задачи закрываются и KPI растет!

Чтобы предотвратить круговорот говнокода в природе, старайтесь минимизировать использование mutable. Проектируйте свои модули с умом, чтобы не приходилось их фиксить грязными хаками.

Тем более, что есть отличный способ, как вы можете заменить использование mutable.

Используйте умные указатели!

Дело в том, что на самом деле при работе с умными указателями вы меняете не сам объект указателя, а объект, на который он указывает. В этом случае вы спокойно можете проводить операции над нижележащим объектом в константном методе и при этом синтаксическая константность будет сохраняться!

Если вам нужен какой-то счетчик определенных событий? Передайте его шаренным указателем в конструктор и инкрементируйте его, сколько вам влезет в константных методах:

```cpp
class ThreadSafeLogger {
	explicit ThreadSafeLogger(std::shared_ptr<CallCountMetric> metric) : call_count{metric} {}
    std::shared_ptr<CallCountMetric> call_count;
public:
    void log(const std::string& msg) const {
        call_count->Increment(); // Works fine
        // logging
    }
};
```

Единственное, что  будет странно оборачивать мьютексы внутрь умного указателя. Кажется, это более страшная конструкция, чем mutable. Поэтому для мьютексов думаю можно сделать исключение.

В общем, смысл такой, что надо 100 раз подумать о целесообразности использования mutable в вашем конкретном случае. А потом все равно решить его не использовать. 

Don't use dirty hacks. Stay cool.

#cppcore


decltype(auto) vs auto&&. Ч1
#опытным 

decltype(auto) и auto&& позволяют нам не беспокоиться о конкретных типах сущностей, включая ref квалификацию. Основные кйсы применения decltype(auto) - это автоматический вывод типа возвращаемого значения функции и переменной на основе инициализатора. Но чем отличаются decltype(auto) и auto&& в контексте этих кейсов? Спасибо @SoulslikeEnjoyer за идею для постов в этом комменте https://t.me/c/2009887601/47858.

Сегодня мы поговорим конкретно про это автоматический вывод типа переменной на основе инициализатора.

Чтобы продемонстрировать различия нам нужна вот такая заготовка:

```cpp
int g = 0;
int foo() {return 42;}
int& foo1() {return g;}
int&& foo2() {int i = 42; return std::move(i);}

auto&& a1 = foo();
auto&& a2 = foo1();
auto&& a3 = foo2();

decltype(auto) b1 = foo();
decltype(auto) b2 = foo1();
decltype(auto) b3 = foo2();
```

Здесь касательно вывода типа нас интересует, как ссылочность типа возвращаемого значения функции (или ее отсутствие), сказывается на типе переменных.

Чтобы заглянуть под капот этого дела, я буду использовать полезнейший инструмент - [cppinsides](https://www.google.com/url?sa=t&source=web&rct=j&opi=89978449&url=https://cppinsights.io/&ved=2ahUKEwjAjIa22NCMAxVtHxAIHWvcETsQFnoECAoQAQ&usg=AOvVaw0JHCDd0tkHLPa8kmUi4laS). Эта тулза позволяет снимать слои магии и показывает суть. И вот, что она показала:

```cpp
int && a1 = foo();
int & a2 = foo1();
int && a3 = foo2();

int b1 = foo();
int & b2 = foo1();
int && b3 = foo2();
```

Здесь можно четко увидеть разницу: при возврате из функции не-ref-квалифицированного типа, decltype(auto) в точности передает тип, а вот auto&& определяет тип как правую ссылку.

Проблема ли это? 

a1 по идее должна быть висячей ссылкой, так как объект тут же разрушится. Но на самом деле в этом случае правая ссылка продлевает время жизни объекта, возвращенного из функции, до конца времени жизни ссылки. 

Поэтому в большинстве кейсов при объявлении переменной использование decltype(auto) избыточно, auto&& прекрасно справляется. 
Единственное, когда его нужно использовать - в тестах всякого шаблонного непотребства, чтобы получить точный тип возвращаемого значения и сравнить его с образцом.

В следующий раз обсудим, какие различия между ними при использовании автоматического вывода типа возвращаемого значения функции.

Be laconic. Stay cool.

#cppcore #cpp14




Сравниваем производительности оператора<
#опытным 

В [этом посте](https://t.me/grokaemcpp/676) я рассказал об отличном способе лексикографического сравнения набора объектов с помощью std::tie. Однако в комментариях несколько подписчиков задались вопросом, а не будет ли использование std::tie сильно ударять по производительности? Настоящих плюсовиков всегда на подкорке волнует вопрос оверхеда используемых инструментов. Поэтому сегодня мы выясним, есть ли разница в практических вычислениях между разными вариантами оператора< .

Большое спасибо, @SoulslikeEnjoyer, за представление основного объема кода.

Сравним 4 реализации operator<:
```cpp
struct Time_comparison_unreadable {
	int hours;
	int minutes;
	int seconds;

	bool operator<(const Time_comparison_unreadable& other) {
		if ((hours < other.hours) || (hours == other.hours && minutes < other.minutes) || (hours == other.hours && minutes == other.minutes && seconds < other.seconds))
			return true;
		else
			return false;
	}
};

struct Time_comparison_readable {
// fields
	bool operator<(const Time_comparison_readable& other) {
		if (hours < other.hours) return true;
		if (hours > other.hours) return false;
		if (minutes < other.minutes) return true;
		if (minutes > other.minutes) return false;
		if (seconds < other.seconds) return true;
		return false;
	}
};

struct Time_tie {
// fields
	bool operator<(const Time_tie& other) {
		return std::tie(hours, minutes, seconds) < std::tie(other.hours, other.minutes, other.seconds);
	}
};

struct Time_spaceship {
// fields
	auto operator<=>(const Time_spaceship &) const = default;
};
```

Первые 2 варианта - это обычные реализации лексикографического оператора сравнения, просто второй из них более читаемый. В структуре Time_tie мы используем std::tie для формирования тупла и используем оператор сравнения тупла. В последнем варианте используем дефолтно-сгенерированный spaceship оператор.

Для того, чтобы качественно сравнить время выполнения чего-либо aka провести перфоманс тесты, нам поможет фреймфорк google benchmark. Она предоставляет гибкие инструменты для управления запуском кода и измерением времени его работы. Не будем вдаваться в детали фреймворка, а сразу посмотрим код:

```cpp
std::random_device dev;
std::mt19937 rng(dev());
std::uniform_int_distribution<int> dist(1,100);

template <typename TimeClass>
static void time_comparison_experiment(benchmark::State& state) {
	std::vector<TimeClass> v(1'000'000);
	std::generate(v.begin(), v.end(), [&] () -> TimeClass { return TimeClass{ dist(rng) % 24, dist(rng) % 60, dist(rng) % 60 }; });
	while (state.KeepRunning()) {
		auto start = std::chrono::high_resolution_clock::now();
		std::sort(v.begin(), v.end());
		auto end = std::chrono::high_resolution_clock::now();
		
		auto elapsed_seconds =
		std::chrono::duration_cast<std::chrono::duration<double>>(
		end - start);
		state.SetIterationTime(elapsed_seconds.count());
		std::shuffle(v.begin(), v.end(), rng);
	}
}

BENCHMARK(time_comparison_experiment<Time_comparison_unreadable>)->UseManualTime()->Iterations(20);

BENCHMARK(time_comparison_experiment<Time_comparison_readable>)->UseManualTime()->Iterations(20);

BENCHMARK(time_comparison_experiment<Time_tie>)->UseManualTime()->Iterations(20);

BENCHMARK(time_comparison_experiment<Time_spaceship>)->UseManualTime()->Iterations(20);
```

Все просто: создаем вектор, наполняем его объектами с рандомным временем, в цикле производим сортировку как операцию, обильно использующую сравнение, и шаффлим элементы вектора перед каждой новой итерацией цикла. Сравнивать нам нужно только время выполнения самой операции сортировки и gbenchmark предоставляет возможность пользователю самому измерять только те операции, которые имеет смысл сравнивать. 

В конце мы запускаем бенчмарк над функцией с измерением времени выполнения, говорим ему, что мы сами будет мерять время(UseManualTime), и сколько итераций цикла нужно выполнить(Iterations(20)).

Без оптимизаций результаты следующие:
```cpp
time_comparison_experiment<Time_comparison_unreadable> 809393239 ns
time_comparison_experiment<Time_comparison_readable>   799267011 ns
time_comparison_experiment<Time_tie>                   5439882770 ns
time_comparison_experiment<Time_spaceship>             1204335568 ns
```

Сортировка с помощью первых двух вариантов операторов работают примерно за одно время. spaceship operator справился примерно в 1.5 раза хуже. Ну а сортировка с оператором, использующим std::tie, примерно на порядок тормознутей.

Но давайте вспомним: **в чем сила плюсов?**

В способности усидеть на 2-х стульях. Можно использовать высокоуровневые абстракции и получать быстрый машинный код за счет оптимизаций компилятора.

Так давайте посмотрим, как изменится ситуация при применении оптимизаций О3:

```
time_comparison_experiment<Time_comparison_unreadable>  187431600 ns
time_comparison_experiment<Time_comparison_readable>    169871716 ns
time_comparison_experiment<Time_tie>                    188380443 ns
time_comparison_experiment<Time_spaceship>              180096881 ns
```

Ну во-первых, все варианты примерно сравнялись. Лучше всех себя показал человекочитаемый вариант на условиях, а хуже всего - std::tie. 

Однако разница между ними - 10%. Стоит ли предпочитать использовать кучу условий короткой записи с std::tie, но тратить на выполнение этой операции на 10% боле времени - решать уже вам на основе нефункциональных требований вашего проекта.

Кто хочет поиграться с кодом бэнчмарка - [вот ссылочка](https://quick-bench.com/q/VyHSwUUMJs59M_6LRdhM5Emz4B4) на quick benchmark с этим кодом

Compare things. Stay cool.

#performance #cpp20 





https://t.me/c/2009887601/47858


Без оптимизаций результаты следующие:
```cpp
time_comparison_experiment<Time_comparison_unreadable> 809393239 ns
time_comparison_experiment<Time_comparison_readable>   799267011 ns
time_comparison_experiment<Time_tie>                   5439882770 ns
time_comparison_experiment<Time_spaceship>             1204335568 ns
```

Сортировка с помощью первых двух вариантов операторов работают примерно за одно время. spaceship operator справился примерно в 1.5 раза хуже. Ну а сортировка с оператором, использующим std::tie, примерно на порядок тормознутей.

Но давайте вспомним: **в чем сила плюсов?**

В способности усидеть на 2-х стульях. Можно использовать высокоуровневые абстракции и получать быстрый машинный код за счет оптимизаций компилятора.

Так давайте посмотрим, как изменится ситуация при применении оптимизаций О3:

```
time_comparison_experiment<Time_comparison_unreadable>  187431600 ns
time_comparison_experiment<Time_comparison_readable>    169871716 ns
time_comparison_experiment<Time_tie>                    188380443 ns
time_comparison_experiment<Time_spaceship>              180096881 ns
```

Ну во-первых, все варианты примерно сравнялись. Лучше всех себя показал человекочитаемый вариант на условиях, а хуже всего - std::tie. 

Однако разница между ними - 10%. Стоит ли предпочитать использовать кучу условий короткой записи с std::tie, но тратить на выполнение этой операции на 10% боле времени - решать уже вам на основе нефункциональных требований вашего проекта.

Кто хочет поиграться с кодом бэнчмарка - вот ссылочка на quick benchmark  (https://quick-bench.com/q/VyHSwUUMJs59M_6LRdhM5Emz4B4)с этим кодом.


Помогите Доре найти проблему в коде
#опытным 

Наткнулся на просторах всемирной сети на интересный пример:

```cpp
#include <cstdio>

void bar(char * s) {
	printf("%s", s);
}

void foo() {
	char s[] = "Hi! I\'m a kind of a loooooooooooooooooooooooong string myself, you know...";
	bar(s);
}

int main() {
	foo();
}
```

Код работает и пример довольно игрушечный. Однако в этом С++ коде есть проблема/ы. Сможете ли вы их найти?

Это не то, чтобы рубрика #ревью, особо никакой цели и предназначения у кода нет. Просто интересно, как много разнообразных проблем и недостатков вы сможете найти в этом небольшом отрывке кода.

Critique your solutions. Stay cool.

#fun


Ответ

Поговорим о том, что не так в коде из предыдущего поста:

```cpp
#include <cstdio>

void bar(char * s) {
	printf("%s", s);
}

void foo() {
	char s[] = "Hi! I\'m a kind of a loooooooooooooooooooooooong string myself, you know...";
	bar(s);
}

int main() {
	foo();
}
```

1 Вопрос был про плюсовый код, но он как будто бы здесь даже не проходил. Пользоваться С++ и использовать только сишный инструментарий - идея, мягко говоря, не очень.

2 В bar() принимает указатель на неконстантные данные и никак их не изменяем. Стандартные правила хорошего тона - это помечать константностью параметры функции, в которой данные остаются нетронутыми.

3 В bar() нет никакой проверки границ. Почему-то функция надеется, что когда-нибудь она встретит null-terminator. Но этого спокойно может и не быть.

4 Каждый раз при вызове foo() мы кладем на стек то, что должно храниться в сегменте данных, где обычно хранятся строковые литералы. То есть вместо того, чтобы по указателю ссылаться на строку, foo копирует ее на стек и дальше использует. Это ненужные действия, которые негативно сказываются на производительности. Если конечно мы вообще можем говорить о производительности в рамках этого кода.

Как выглядел бы код на современных плюсах?

```cpp
#include <print>
#include <string_view>

void bar(std::string_view s) {
	std::println("{}", s);
}

void foo() {
	std::string_view s = "Hi! I\'m a kind of a loooooooooooooooooooooooong string myself, you know...";
	bar(s);
}

int main() {
	foo();
}
```

Всего 2 простых улучшения:

1 Использование легковестного std::string_view из С++17. Это по сути просто указатель + размер данных, так что накладные расходы на этот объект минимальны. А еще его даже рекомендуют передавать в функции по значению.

2 Вместо сишной вариабельной нетипобезопасной функции printf используем типобезопасную плюсовую std::println на вариабельных шаблонах из С++23.

Простые улучшения, но в итоге все неприятности пофиксили. Магия С++.

Believe in magic. Stay cool.

#cppcore #cpp23 #cpp17





std::midpoint
#новичкам 

Простая задача - получить среднее арифметическое двух чисел. Берем и пишем, как на уроке математики:

```cpp
int avg(int a, int b) {
	return (a + b) / 2;
}
```

И дело в шляпе. Или нет?

На самом деле это некорректная реализация, потому что не учитывает переполнение целых чисел. Если сумма (a + b) будет больше, чем помещается в int, то произойдет переполнение, а вы в итоге получите неправильный ответ.

Что же делать?

Если несколько способов обойти эту проблему.

1 Складываем половинки двух чисел:

```cpp
int avg(int a, int b) {
	return a/2 + b/2;
}
```

2 Первое число складываем с разницей двух чисел:

```cpp
int avg(int a, int b) {
	return a > b ? b + (a - b) / 2 : a + (b - a) / 2;
}
```

Если раскрыть скобки, то выходит тоже самое.

3 std::midpoint. С++20 мы наконец получили стандартную функцию, считающую среднее арифметическое двух объектов. Давайте посмотрим на ее реализацию из gcc:

```cpp
 // midpoint
#ifdef __cpp_lib_interpolate // C++ >= 20
  template<typename _Tp>
    constexpr
    enable_if_t<__and_v<is_arithmetic<_Tp>, is_same<remove_cv_t<_Tp>, _Tp>,
			__not_<is_same<_Tp, bool>>>,
		_Tp>
    midpoint(_Tp __a, _Tp __b) noexcept
    {
      if constexpr (is_integral_v<_Tp>)
	{
	  using _Up = make_unsigned_t<_Tp>;

	  int __k = 1;
	  _Up __m = __a;
	  _Up __M = __b;
	  if (__a > __b)
	    {
	      __k = -1;
	      __m = __b;
	      __M = __a;
	    }
	  return __a + __k * _Tp(_Up(__M - __m) / 2);
	}
      else // is_floating
	{
	  constexpr _Tp __lo = numeric_limits<_Tp>::min() * 2;
	  constexpr _Tp __hi = numeric_limits<_Tp>::max() / 2;
	  const _Tp __abs_a = __a < 0 ? -__a : __a;
	  const _Tp __abs_b = __b < 0 ? -__b : __b;
	  if (__abs_a <= __hi && __abs_b <= __hi) [[likely]]
	    return (__a + __b) / 2; // always correctly rounded
	  if (__abs_a < __lo) // not safe to halve __a
	    return __a + __b/2;
	  if (__abs_b < __lo) // not safe to halve __b
	    return __a/2 + __b;
	  return __a/2 + __b/2;	    // otherwise correctly rounded
	}
    }

  template<typename _Tp>
    constexpr enable_if_t<is_object_v<_Tp>, _Tp*>
    midpoint(_Tp* __a, _Tp* __b) noexcept
    {
      static_assert( sizeof(_Tp) != 0, "type must be complete" );
      return __a  + (__b - __a) / 2;
    }
#endif // __cpp_lib_interpolate

```

Не будем вдаваться в подробности, однако стоит заметить, что стандартная функция использует оба подхода в разных ситуациях. Для целых чисел используется второй подход, а для чисел с плавающей точкой - первый и, даже, оригинальный подход, когда нет риска переполнения.

Да, может быть эта реализация не такая эффективная, зато гарантировано безопасная. Так что если вы не упарываетесь по перфу, то она станет вашим верным другом.

Stay safe. Stay cool.

#cpp20 #cppcore




Концепты делают ошибки более читаемыми


Пример внутреннего кэша. filter_view

std::exchange числа фибоначчи

Перечислить все callable сущности с примерами

Flexible array member
