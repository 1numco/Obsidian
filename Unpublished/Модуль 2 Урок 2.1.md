
Параметры шаблонов, не являющиеся типами

ОРы:
- применяет целочисленные шаблонные параметры
- применяет указатели и ссылки в качестве шаблонных параметров
- применяет вещественные числа в шаблонах
- применяет объекты пользовательских типов в шаблонах

Структура:

- Отсылки к первому уроку и введения ключевого слова typename. Тогда мы сказали, что typename нужен для обозначения типа, потому что не все шаблонные параметры бывают типами. Бывают еще 2 вида: нетиповые параметры и шаблон-шаблонные параметры.(Ко всем ОРам)
- Раскрываем нетиповые параметры. Начинаем с целых чисел. Тут примеры - std::array, std::bitset, std::get. Требования к числам, с которыми инстанцируем шаблоны - их значение должно быть известно на этапе компиляции.(ОР: применяет целочисленные шаблонные параметры)
- Шаблон инстанцируется со значением конкретного типа и это значение зашито в типе этой инстанциации. Это значит, что две инстанциации с разными числами - разные типы. (К конкретному ОРу напрямую не относится, важно для понимания темы)
- Специализация шаблонов с нетиповыми параметрами на примере рекурсии вычисления чисел Фибоначчи. Для нуля и единицы ставим 0 и 1. (ОР: применяет целочисленные шаблонные параметры)
- Указатели и ссылки. Полезность указателей, как шаблонных параметров показываем на примере инстанцирования с коллбэком, ссылки - DI с помощью ссылки на базовый класс как параметр шаблона (ОР: применяет указатели и ссылки в качестве шаблонных параметров)
- С++20 и расширение множества типов, которые можно использовать как NTTP.
- вещественные типы в шаблонах. Очень коротко на примере compile-time проверки равенства двух даблов с заданной в параметре точностью(ОР: применяет вещественные числа в шаблонах)
- объекты пользовательских типов в качестве шаблонных параметрах. Требования к пользовательским типам, чтобы их можно было использовать в качестве параметров шаблонов. На примере параметризации класса значением структуры-конфига.(ОР: применяет объекты пользовательских типов в шаблонах)
- auto параметры шаблонов
- Шаблон-шаблонные параметры. Для шаблонных параметров, которые сами являются шаблонами, есть специальный синтаксис. На примере функции, принимающей шаблонный последовательный контейнер. (ОР: применяет шаблонные параметры в шаблонах (template template))

Введение

До этого урока мы рассказывали о том, как можно передать в качестве параметра шаблона тип. Но на самом деле шаблоны не ограничены использованием только типов. Сегодняшний урок про параметры шаблонов, которые типами не являются. Вы узнаете:

- Как можно проводить вычисления на этапе компиляции с помощью целочисленных шаблонных параметров?
- Для чего могут понадобиться ссылки и указали в качестве шаблонных параметров?
- Как использовать числа с плавающей точкой в шаблонах?
- Какие особенности использования пользовательских типов в качестве шаблонных параметров?
- Что за зверь такой шаблон-шаблонные параметры?

Контент

Помните, как  на самом первом уроке мы вводили ключевое слово typename? Тогда мы сказали, что typename нужен для обозначения типа, потому что не все шаблонные параметры бывают типами. Но тогда было не время для объяснения других случаев. Но сегодня мы глубоко погрузимся в них, посмотрим на особенности и примеры использования. 

Всего есть 2 большие группы параметров, не являющихся типами. Non-Type Template Parameters(NTTP) и шаблон-шаблонные параметры. Название первой группы не очень удачное, так как в целом относится к обоим группам, но так принято в литературе, поэтому будет называть так. 

При передаче NTTP в шаблон, он инстанцируется не с типом параметра, а с конкретным значением параметра. То есть если шаблон с typename может обрабатывать любой тип на этапе компиляции, но со значениям этим типов шаблон работает уже на этапе исполнения. С NTTP другое поведение, шаблону уже на этапе компиляции известно конкретное значение параметра, которое мы в него передали. В этом вся разница.

NTTP относятся: целые числа, указатели и ссылки, вещественные числа и пользовательские типы.

## Целочисленные шаблонные параметры

Если вы хотите работать с размерами или порядковыми номерами в compile-time, то целочисленные шаблонные параметры - это ваш бро. Стандартна библиотека библиотека полна примеров их использования. Давайте посмотрим на них, чтобы понять, для они могут применяться.

Яркий пример - std::array. Это набор однотипных элементов, последовательно расположенных в памяти. И! Его размер известен и факсирован на этапе компиляции:

```cpp
template<typename T, size_t Size>
struct array
{
	T& operator[](size_t index) {
		return _data[index];
	}
	T& front() {
		return _data[0];
	}
	T& back() {
		return _data[Size - 1];
	}
	T* data() {
		return _data;
	}
	size_t size() const {
		return N;
	}
	bool empty() const {
		return Size == 0;
	}
// еще const версии перечисленных методов и некоторые другие методы и зависимые типы
	T _data[Size];
};

std::arrray<int, 5>  cpp_arr; // размер массива 5.
```

Обратите внимание на объявление шаблонных параметров. Тут уже есть привычный нам тип Т и целочисленный параметр N. Он как раз-таки и отражает compile-time размер массива. Вы один раз задаете его в шаблонном параметре и можете быть уверены, то размер не поменяется в течение всей жизни объекта.

Другой похожий пример - std::bitset. Он представляет собой набор бит фиксированного размера. Подходит для определения битовых масок и удобного оперирования ими:

```cpp
template<size_t N>  
class bitset {/*реализация*/};

std::bitset<4> mask{"0011"}; // опредеяем битовую маску
// std::bitset поддерживает различные операции по преобразованию набора битов
mask |= 0b0100; assert(mask == 0b0111);
mask.reset(); assert(mask == 0);
mask.set(); assert(mask == 0b1111);
```

Только лишь указанием размеров последовательностям дело не оканчивается. Мы также можем использовать число, как порядковый номер для compile-time идексации. Для этого, например, можно использовать шаблонную функцию std::get. У нее много перегрузок, но рассмотрим одну, которая позволяет индексировать элементы в std::pair:

```cpp
template<std::size_t I, class T1, class T2>  
typename std::tuple_element<I, std::pair<T1,T2> >::type&  
    get(std::pair<T1, T2>& p) noexcept;

auto p = std::pair(1, 3.14);
std::println("({}, {})", std::get<0>(p), std::get<1>(p));
// На консоли появится:
// (1, 3.14)
```

Здесь мы с помощью порядкового номера элемента в паре получаем к нему доступ.

Важно: значения целочисленного параметра должно быть константным и известным на этапе компиляции.

Во всех примерах мы использовали целочисленные литералы в качестве шаблонного параметра, чтобы гарантировать это условие. Также можно использовать константные глобальные переменные, чтобы достичь того же результата:

```cpp
const size_t size = 5;

int main() {
	std::array<int, size> arr;
}
```

Однако вы не можете использовать в качестве шаблонный параметр, если его значение не известно на этапе компиляции:

```cpp
size_t get_size() {
	return 5;
}

int main() {
	const size_t size = get_size(); // несмотря на константность переменной, ее значение компилятор не знает на этапе компиляции.
	std::array<int, size> arr;
}
```


## Типобезопасность

Шаблоны - это не полноценные сущности. Их нужно инстанцировать. В этом случае в инстанциации как бы "зашита" информация о всех параметрах, с которым инстанцирован шаблон.

Это верно для любых видов шаблонных параметров.

Это также значит, что один и тот же шаблон, инстанцированный с разными значениями - это разные сущности и у них разный тип. Это легко проверить с помощью уже известного нам класса SameType:

```cpp
template<typename T1, typename T2>
struct SameType {
};

template<typename T>
struct SameType<T, T> {
	// определяем зависимый тип type
	using type = T;
};

using is_arrays_same = typename SameType<std::array<int, 5>, std::array<int, 6>>::type;
```

На последней строчке будет ошибка компиляции, потому что типы std::array<int, 5> и std::array<int, 6> - разные, поэтому компилятор не найдет нужного зависимого типа в первой специализации SameType.

## Специализация шаблонов с целочисленными параметрами

Специализация шаблонов - гибкий способ изменить поведение шаблона для конкретных шаблонных параметров. 

Также в купе с рекурсией она играет важную роль в compile-time вычислениях для целочисленных параметров.

Скажем, нам нужно вычислять N-ый элемент последовательности Фибоначчи на этапе компиляции. Но как это сделать без циклов и функций?

С помощью рекурсивной инстанциации шаблонов, конечно.

```cpp
template<size_t N>
struct Fibonacci {
	// рекурсивно складываем два предыдущих значения последовательности Фибоначчи
	static const unsigned value = Fibonacci<N-1>::value + Fibonacci<N-2>::value;
};
```

Мы рекурсивно запрашиваем доступ к значению `value` шаблонного класса Fibonacci и передаем с него числа N-1 и N-2. Это заставляет компилятор рекурсивно инстанцировать шаблонные классы  Fibonacci с разными значениями шаблонных параметров. И затем складывает значения статического поля `value` в этих инстанциациях.

Но момент. До каких пор мы будем спускаться в рекурсию? До бесконечности? Плохой вариант. У рекурсии всегда есть база, которая ограничивает глубину рекурсии.

В нашем случае этими базами должны быть полные специализации шаблона Fibonacci:

```cpp
template<>
struct Fibonacci<0> {
    static const unsigned value = 0;
};

template<>
struct Fibonacci<1> {
    static const unsigned value = 1;
};
```

Теперь рекурсия не уйдет в бесконечность и мы можем в compile-time вычислять нужное число:

```cpp
static_assert(Fibonacci<7>::value == 13, "Fibonacci<7> should be 13");
```

static_assert успешно компилируется, потому что значение `value` известно на этапе компиляции

## Ссылки и указатели как шаблонные параметры

Ссылки и указатели тоже можно использовать в качестве шаблонных параметров. Однако в этом случае на них накладываются ограничение - адрес объекта, на который ссылается указатель или ссылка, должен быть известен на этапе компиляции. Это ограничивает параметризацию указателями и ссылками на глобальные переменные и указателями на свободные функции.

Не так уж и просто представить, зачем нужны такие шаблонные параметры. У них действительно не так много юзкейсов. Но они все же есть.

Очень часто в конструктор класса передается некий указатель на функцию, который в последствии используется как callback. 

```cpp
struct Class {
	Class(void (*callback)()) : callback_{callback} {}
	void foo() {
		callback_();
	}

	void (*callback_)();
};
```

Сигнатура такого класса не предполагает изменения коллбэка. То есть в том момент, когда мы создали объект, коллбэк уже определен и не меняется на протяжении времени жизни объекта. Имеет смысл вынести на этап компиляции задание коллбэка:

```cpp
template<void (*callback_)()>
struct Class {
	Class(void (*callback)()) : callback_{callback} {}
	void foo() {
		callback_();
	}
};
```

Тем самым мы не будем тратить на это время в рантайме.

Другой пример - на этапе компиляции задавать полиморфные зависимости классу. Так как динамический полиморфизм работает при использовании указателей и ссылок, можно определить в качестве шаблонного параметра ссылку на полиморфный объект и не передавать его в конструктор класса:

```cpp
// определяем уровни логирования
enum class Level {
	Info,
	Error
};

// сопоставляем уровень лога с соответсвующей строкой
std::map<Level, std::string> level_to_str = {{Level::Info, "Info"}, {Level::Error, "Error"}};

// базовый класс
struct Logger {
	virtual void log(const std::string& str, Level level) = 0;
};

// наследник
struct LoggerImpl : Logger{
	void log(const std::string& str, Level level) override {
		std::println("{}: {}", level_to_str[level], str);
	}
};

// класс сервиса, параметризованный логгером
template <Logger& logger>
struct Service {
	void log(const std::string& str, Level level) {logger.log(str, level);}
};

LoggerImpl logger;

int main() {
	Service<static_cast<Logger&>(logger)> service;
	service.log("Error", Level::Error);
}
```

Логгер для сервиса обычно не меняется в течение жизни сервиса. Поэтому мы можем вынести выбор логгера на этап компиляции. Важно, что мы должны явно привести объект логгера к ссылке на базовый класс, чтобы тип точно совпадал с типом, определенном в шаблонном параметре.

За счет полиморфизма также мы имеет возможность тестировать функционал логирония в сервисе:

```cpp
struct LoggerTestImpl : Logger{
	void log(const std::string& str, Level level) override {
		ss << level_to_str[level] << ": " << str << std::endl;
	}
	std::stringstream ss;
};

LoggerTestImpl test_logger;

int main() {
	Service<static_cast<Logger&>(test_logger)> test_service;
	test_service.log_error("Test", Level::Info);
	std::println(test_logger.ss.str());
}
// OUTPUT:
// Info: Test
```

Такое сочетание шаблонов и динамического полиморфизма позволяет иметь преимущества обоих подходов.

Касательно NTTP, которые обсуждались выше, они были еще в самом первом стандарте С++. С введением С++20, у нас появились новые возможности. О них подробнее дальше.
## Вещественные числа как параметры шаблонов

Мы можем определять вещественные числа типа float и double как параметры шаблонов. Опять же, числа должны быть известны на этапе компиляции. Давайте сразу на примере.

Вы уже в уроке по шаблонам функций реализовывали сравнений двух чисел с плавающей точкой. Тогда нужно было передать дельту сравнения в аргументы функции. Однако значение epsilon вряд ли должно меняться от вызова к вызову, обычно это константа. Давайте это используем и напишем функцию, которая сравнивает два floating-point числа с шаблонным параметром epsilon.

```cpp
template <typename T, T epsilon = static_cast<T>(0.00001)>
bool is_equal(T a, T b) {
    return std::abs(a - b) < epsilon;
}
// используем значение по умолчанию
std::println(is_equal(1.000001, 1.000002));
// явно передаем epsilon, поэтому явно нужно передать все параметры, стоящие впереди в объявлении шаблона
std::println(is_equal<float, 0.0001f>(1.0001f, 1.0003f));
// OUTPUT:
// 1
// 0
```

Обратите внимание, что тип epsilon не фиксированный в шаблоне. Но во время инстанциации, когда компилятор смог вывести тип Т, epsilon становится значением этого выведенного типа.

Также вы можете использовать параметры по умолчанию, но в этом случае при явном указании шаблонного параметра вам нужно указать также все предыдущие параметры.

## Объекты пользовательских типов как шаблонные параметры

Мы также получили возможность определять объекты пользовательских типов в качестве шаблонных параметров. Однако на такие типы накладываются серьезные ограничения. Объект пользовательского типа можно объявлять в качестве шаблонного параметра, если значение объекта известно на этапе компиляции и его тип удовлетворяет следующим условиям:

- Только публичное наследование от всех базовых классов
- Все нестатические члены класса публичные и немутабельные
- Типы нестатических полей класса и всех его базовых классов являются одним из: левая ссылка, целое число, число с плавающей точкой, указатель, enum или пользовательский тип, поля которого представляют комбинацию из них.
- 

Это требования сильно ограничивают использование объектов в качестве NTTP. Но все же об этой возможности нужно знать.

Определим функцию, которая преобразует локальные координаты точки в глобальные с помощью класса точки:

```cpp
struct Point { double x, y; };

template <Point Origin> // NTTP - смещение начала координат
Point ToGlobalCoordinateSystem(Point local) {
	return {local.x + Origin.x, local.y + Origin.y};
}

auto point = ToGlobalCoordinateSystem<Point{100.0, 200.0}>({5.0, 3.0});
std::println("{}, {}", global.x, global.y); // выведется 105.0, 203.0
```

Здесь мы используем структуру Point как NTTP, чтобы внедрить значения начала координат в функцию на этапе компиляции, чтобы не тратить время на передачу этого аргумента в рантайме.

## auto параметры

С++17 подарил нам автоматический вывод типов для нетиповых шаблонных параметров. Иногда это может упростить реализацию шаблонов для разных типов NTTP и не задумываться о конкретных типах.

```cpp
template <auto N> // N может быть int, char, size_t и т.д.
struct Array {
	int data[N];
};

Array<10U> arr1;
Array<5l> arr2;
```

Не смотря на то, что `10U` и `5l` - литералы разных типов, шаблон корректно инстанцируется со значениями обоих типов.

## Шаблон-шаблонные параметры

Шаблоны не являются полноценными типами. Поэтому мы не можем параметризировать ими другие шаблоны через простой `typename`, как мы привыкли. Однако для такой параметризации существует особый синтаксис. Встречайте, шаблон-шаблонные параметры.

Синтаксис объявления такого параметра:

```cpp
template <template <typename> typename ClassType>
```

Чтобы сказать компилятору, что параметр сам является шаблоном, нужно дополнительно указать `template <typename> `перед объявлением параметра.

Использовать это можно так:

```cpp
template <template <typename> class Creator>
class ObjectFactory {
public:
	// шаблонный метод, в котором мы используем Creator с шаблонным параметром
	template <typename T>
		std::unique_ptr<T> create() {
		return Creator<T>().make();
	}
};

template <typename T>
struct DefaultCreator {
	std::unique_ptr<T> make() { return std::make_unique<T>(); }
};

template <typename T>
struct DebugCreator {
	std::unique_ptr<T> make() {
		std::cout << "Creating " << typeid(T).name() << "\n";
		return std::make_unique<T>();
	}
};

int main() {
	// в первом случае передаем один шаблонной тип
	ObjectFactory<DefaultCreator> defaultFactory;
	auto obj1 = defaultFactory.create<int>();
	// во втором - другой
	ObjectFactory<DebugCreator> debugFactory;
	auto obj2 = debugFactory.create<double>();
}
```

Фабрика объектов принимает шаблон-шаблонный Creator, который может создавать объекты любых типами с конструктором по-умолчанию. Мы изначально не знаем с каким типом будет работать Creator. Да нам это и не важно, потому что конкретный тип задает метод create. В итоге мы можем одним объектом-фабрикой создавать объекты разных типов.

Шаблон-шаблонные параметры редко используются в разработке. Но чтобы понять, какую они могут принести пользу, нам нужно узнать о шаблонах немного больше. В одном из следующих уроков мы найдем им применение.

## Заключение

Давайте повторим, что мы сегодня узнали о шаблонных параметрах, не являющихся типами:

- С помощью целочисленных шаблонных параметров можно работать с размерами структура и с порядковыми номерами их элементов. А также проводить различные compile-time вычисления.
- Указатели в качестве шаблонных параметров могут быть полезны для параметризации класса коллбэками.
- Указатели и ссылки можно использовать для compile-time параметризации классов полиморфными структурами.
- Числа с плавающей точкой и пользовательские типы расширяют спект применения NTTP и позволяют перенести больше вычислений в compile-time.
- Шаблон-шаблонные параметры помогают параметризовывать шаблоны другими шаблонами, что позволяет еще больше обобщить код.






