  
  

# Финальный проект модуля — разработка типобезопасной функции scan

  

- Модуль: 2 - Шаблоны и метапрограммирование

- Задание 1: разработка функции scan, выполняющей чтение данных из исходной строки, интерпретацию данных на основе форматирующей строки и сохранение результатов интерпретации в объекты указанных типов во время исполнения.

- Навык: умеет управлять памятью и ресурсами с применением идиом языка, инструментов стандартной библиотеки и языковых конструкций

- умеет разрабатывать типобезопасные обобщенные программы на основе шаблонов

- Проверяемые ОРы:

	- Применяет перегрузку шаблона функции - семейство функций parse_value
	
	- Применяет целочисленные шаблонные параметры - в функции scan для получения тупла из типов.
	
	- применяет шаблон класса, функции совместно. В приниципе любая функция в текущей реализации
	
	- Применяет traits. Для создания составных концептов(StringLike в проекте) используются трейты.
	
	- применяет вариабельные шаблоны для реализации функции - главная функция scan вариабельная.
	
	- применяет сверточные выражения - для проверки того, что все возвращаемые значения parse_value_with_format не ошибочные.
	
	- применяет лямбда-выражения как локальные функции - Опционально, всегда все можно без лямбды сделать. Используется для большей локализации кода, когда надо вызвать небольшую функцию.
	
	- применяет концепты в шаблонах функций и классов - с помощью концептов ограничивается набор типов для работы функции парсинга строки в разные типы parse_value.
	
	- применяет конструкцию if constexpr для ветвления во время компиляции - опционально. конкретная перегрузка функция парсинга строки в строковые типы должна ветвиться во время компиляции по конкретному переданному строковому типу.

- Задание 2: разработка функции scan, выполняющей чтение данных из исходной строки, интерпретацию данных на основе форматирующей строки и сохранение результатов интерпретации в объекты указанных типов во время компиляции.

- Навык: умеет разрабатывать типобезопасные обобщенные программы на основе шаблонов и проводить вычисления на этапе компиляции.

- Проверяемые ОРы:

	- применяет перегрузку шаблона функции - семейство функций parse_value.
	
	- применяет шаблон класса, функции совместно - Любая функция.
	
	- применяет целочисленные шаблонные параметры - класс fixed_string
	
	- применяет объекты пользовательских типов в шаблонах - главная функция scan, которая принимает форматирующую и исходную строку в качестве шаблонных параметров.
	
	- применяет вариабельные шаблоны для реализации функции - главная функция scan должна работать с любым количеством переданных типов.
	
	- применяет сверточные выражения - удобное применение функции парсинга одного параметра для всего пакета шаблонных параметров
	
	- применяет лямбда-выражения как локальные функции - Опционально, всегда все можно без лямбды сделать. Используется для большей локализации кода, когда надо вызвать небольшую функцию. Но в этой версии проекта это особенно важно, так как в этом задании часто приходится вычислять код в отдельной функции, чтобы использовать ее результат в качестве constexpr переменной. Чтобы не дробить логически связанный код на разные функции, лучше использовать лямбды.
	
	- применяет концепты в шаблонах функций и классов - с помощью концептов ограничивается набор типов для работы функции парсинга строки в разные типы parse_value.
	
	- применяет ключевое слово contsexpr при реализации функций - constexpr лямбды и конструкторы класса fixed_string
	
	- применяет constexpr при реализации конструкторов классов - конструкторы класса FormatString
	
	- применяет constexpr для реализации переменной - статические поля класса FormatString
	
	- применяет конструкцию if constexpr для ветвления во время компиляции - любая операция в функциях парсинга, которая самостоятельно может сгенерировать ошибку компиляции через static_assert, должна использовать if constexpr.
	
	- применяет consteval при реализации фукнций времени компиляции - все функции, так как у нас ограничение, что результат должен быть готов уже на этапе компиляции.

## Контент

Поздравляем! Вы изучили тему “Шаблоны и вычисления времени компиляции“. Самое время проверить полученные знания на практике и самостоятельно выполнить проектную работу. Проект — разработка функции scan, выполняющей чтение данных из исходной строки, интерпретацию данных на основе форматирующей строки и сохранение результатов интерпретации в объекты указанных типов.

Вы можете выбрать одну из версий выполнения этого задания:

1. Функция scan должна выполнять интерпретацию данных в runtime. Результат работы функции можно получить только во время выполнения.

2. Функция scan должна выполнять интерпретацию данных в compile-time. Результат работы функции должен быть получен на этапе компиляции.

В обоих случаях необходимо будет:

- реализовать функцию scan, которая будет на вход принимать 2 строки(форматирующую строку и строку с исходными данными) и набор типов, в которые мы хотим превратить исходные данные. Принцип работы функции аналогичен принципу работы сишной функции [scanf](https://en.cppreference.com/w/c/io/fscanf). Главное отличие - ваша реализация должна быть типобезопасна.

- протестировать эту функцию для различных входных данных.

  

Общие особенности реализации:

1. Форматирующая строка представляет собой строку с включенными в нее плейсхолдерами(Всплывашка: ограждающие символы, на месте которых в исходной строке находятся данные парсинга) и, потенциально, спецификаторами форматирования. Плейсхолдеры в форматирующей строке могут быть одним из двух вариантов:

- Пустой - "{}"

- Со спецификатором конвертации - "{%`conversion-specifier`}". Спецификатор конвертации определяет, данные какого типа лежат в исходной строке на месте плейсхолдера. Какие спецификаторы будут использоваться описывается в требованиях к проекту ниже.

Пример корректной форматирующей строки: "I want to sum {} and {%f} numbers."

- В строке с исходными данными на месте плейсхолдеров находятся данные для парсинга. Пример корректной строки с исходными данными для примера выше: "I want to sum 42 and 3.14 numbers.".

  

Такой функции еще нет в стандартной библиотеке, поэтому в каком-то смысле вы будет первопроходцами в ее реализации. Динамическая версия функции scan может быть использована для получения значений из строковых данных при обработке больших файлов с фиксированным паттерном строк(csv, логи). Статическая версия scan может использоваться для конфигурирования приложения без затрат на этапе выполнения.

  

Какую версию функции реализовывать - решать вам. Динамическая версия требует бо'льшей работы с шаблонами, статическая версия - с вычислениями времени компиляции.

  

# Динамическая версия

## План реализации динамической версии функции scan

  

1. Подготовьтесь к работе:

- Откройте [шаблон проекта реализации динамического варианта функции scan](https://github.com/Yandex-Practicum/cpp-middle-project-sprint-2-dynamic){target="_blank"}.

- Выполните инструкции в разделе `Начало работы`.

- Соберите проект и запустите приложение по шагам в разделе `Сборка проекта и запуск тестов`.

  

1. В файле types.hpp определите шаблонны класс `scan_result`, который в себе будет содержать поле типа std::tuple для готовых сканированных значений и метод values для удобного доступа к сканированным значениям. Там же обратите внимание на класс scan_error, хранящий строку ошибки сканирования.

  

2. В файле parse.hpp изучите реализацию функции parse_sources, которая возвращает пару массивов подстрок форматирующей и исходной строки. Элементы массивов с одинаковыми индексами соответствуют плейсхолдеру в форматирующей строке и соответствующую ему подстроке в строке с исходными данными.Там используется класс std::expected, который мы будем подробно разбирать в одном из будущих модулей. Для его использования в проекте почитайте [документацию](https://en.cppreference.com/w/cpp/utility/expected).

  

3. В файле parse.hpp напишите тело шаблонной функции parse_value_with_format:

- функция должна инкапсулировать всю логику преобразования подстроки исходных данных в конкретный тип на основе спецификатора конвертации.

- функция должна возвращать ошибку scan_error в случае несоответствия переданного типа и спецификатора конвертации.

  

4. В файле parse.hpp определите семейство функций parse_value, конвертирующих подстроку исходных данных в конкретный тип.

  

5. В файле scan.hpp реализуйте главную шаблонную функцию scan:

- функция в качестве шаблонных параметров принимает набор типов, в которые нужно конвертировать исходные данные. В качестве параметров функции принимает форматирующую строку и строку с исходными данными.

- scan должна использовать функцию parse_sources, чтобы получить разбиение строк.

- затем агрегировать результаты работы parse_value_with_format в объект типа scan_result и возвращать его наружу.

  

6. Внедрите повсеместную обработку ошибок с помощью стандартного класса std::expected. В случае некорректного ввода функции должны возвращать ошибку(unexpected результат), в случае корректного ввода - набор преобразованных значений. Исключения запрещено использовать.

  

7. Финализируйте работу:

- Протестируйте функцию scan для разных входных данных

- Убедитесь, что выходные данные действительно соответствуют ожидаемым значениям.

- Убедитесь в правильной обработке пограничных случаев и ошибочных сценариев.

  
  

### Общие требования к проекту

1. Должна быть реализована функция scan, выполняющей чтение данных из исходной строки, интерпретацию данных на основе форматирующей строки и сохранение результатов интерпретации в объекты указанных типов во время выполнения.

2. В разработке должны применяться современные возможности C++23, изученные виды шаблонов, идиомы и практики организации шаблонного кода.

  

### Ключевые функциональные требования

  

1. Функция scan должна выполнять сканирование строки с исходными данными на основе форматирующей строки и конвертацию в набор объектов переданных типов.

2. Форматирующая строка должна поддерживать следующие converison specifiers: `d` - в исходной строке на месте плейсхолдера находится целое число, `s` - в исходной строке на месте плейсхолдера находится строка, `u` - в исходной строке на месте плейсхолдера находится натуральное число, `f` - в исходной строке на месте плейсхолдера находится число с плавающей точкой.

  

3. Функция scan должна поддерживать сканирование данных из исходной строки в следующий набор типов: int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t, float, double, std::string_view и std::string, а также cv-квалифицированные версии этих типов. Использование ссылочных типов нужно запретить.

  

4. Функция scan должна возвращать либо корректный результат, либо объект ошибки с сообщением о том, что пошло не так.

  

### Технические требования

  

В проекте должны применяться:

- Вариабельные шаблоны для обработки неограниченного числа типов.

- Класс std::expected для обработки ошибок.

- Тесты с использованием фреймворка GTest.

- Концепты и трейты для ограничения набора типов, с которыми может работать функция.

  
  

## Чек-лист

  

### Обязательные требования

  

- **Определены типы scan_result и scan_error**

  

- **Парсинг параметров функции scan**

- [ ] Получено разбиение входных строк с помощью функции parse_sources

- [ ] Реализовано семейство функций parse_value, инкапсулирующее логику преобразования подстроки в нужный тип.

  

- **Реализация функции scan**

- [ ] Определено тело функции scan, агрегирующей результаты работы parse_value_with_format для всех плейсхолдеров.

- [ ] Разбиение входных строк получено с помощью функции parse_sources.

- [ ] Поддержано сканирование в типы int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t, float, double, std::string_view и std::string, а также cv-квалифицированные версии этих типов. При передаче любых других типов возвращается соответсвующая ошибка scan_error.

- [ ] Поддержано использование спецификаторов`d`, `s`, `f` и `u`.

  

- **Обработка ошибок**

- [ ] Повсеместное использование std::expected. Запрещено использовать исключения.

  

- **Код**

- [ ] Применены вариабельные шаблоны.

- [ ] Применены целочисленные шаблонные параметры.

- [ ] Все свободные функции помечены consteval.

  

- **Тестирование**

- [ ] Написано не меньше 10 unit-тестов для функции scan.

- [ ] Тесты покрывают использование функции для корректных и некорректных входных данных.

  

### Опциональные требования

  

- **Обработка ошибок и безопасность**

- [ ] Сompile-time проверки на корректность шаблонных параметров и результатов во всех подходящих местах.

  

- **Архитектура и код**

- [ ] Правильно применена инкапсуляция для скрытия деталей реализации в рамках файлов.

- [ ] Код соответствует стандарту C++23.

- [ ] Код следует правилам SOLID и KISS.

- [ ] Используются синонимы типов для повышения читаемости кода.

- [ ] Для большей локальности кода короткие функции оборачиваются в лямбды.

  

- **Возможности языка**

- [ ] Используются вариабельные, шаблонные и дженерик лямбды.

  

- **Тестирование**

- [ ] Написано не меньше 15 unit-тестов для функции scan.

- [ ] Тесты покрывают все корректные и некорректные сценарии использования.

  
  
  

# Статическая версия

  

## План реализации статической версии функции scan

  

1. Подготовьтесь к работе:

- Откройте [шаблон проекта реализации статического варианта функции scan](https://github.com/Yandex-Practicum/cpp-middle-project-sprint-2-static){target="_blank"}.

- Выполните инструкции в разделе `Начало работы`.

- Соберите проект и запустите приложение по шагам в разделе `Сборка проекта и запуск тестов`.

  

2. В файле types.hpp определите класс шаблонный класс `fixed_string`:

- Чтобы иметь возможность во время компиляции работать со строками и передавать их в качестве шаблонных параметров, стандартный std::string нам не подойдет. Нужна собственная реализация строки фиксированного размера.

- Определите класс `fixed_string`, задайте ему размер с помощью целочисленного шаблонного параметра и определите единственное поле - С-style массив соответствующего размера.

- Реализуйте 3 constexpr конструктора для возможности создания объекта фиксированной строки на этапе компиляции:

- конструктор, принимающий ссылку на константный массив символов, размер которого совпадает с размером класса, и копирующий значения из массива

- конструктор, принимающий ссылку на константный массив символов, размер которого не совпадает с размером класса. При этом убедитесь с помощью compile-time проверки, что размер массива меньше либо равен размеру фиксированной строки.

- конструктор от двух указателей, последовательно копирующий данные между двумя указателями во внутренний массив.

  

1. В файле types.hpp определите класс `parse_error`, как наследника `fixed_string`. Выставите ему длину, достаточную для хранения строки ошибок парсинга из функции number_placeholders в файле format_string.hpp.

  

2. В файле types.hpp определите шаблонны класс `scan_result`, который в себе будет содержать поле типа std::tuple для готовых сканированных значений и метод values для удобного доступа к сканированным значениям.

  

3. В файле format_string.hpp реализуйте шаблонный класс `format_string`, параметризованный NTTP типа `fixed_string`:

- Добавьте статическое поле класса для доступа к NTTP снаружи.

- Превратите свободную функцию `get_number_placeholders` в статический метод класса `format_string`. Реализация этой функции доступна в шаблоне проекта. Там используется класс std::expected, который мы будем подробно разбирать в одном из будущих модулей. Для его использования в проекте почитайте [документацию](https://en.cppreference.com/w/cpp/utility/expected).

- Добавьте статическое поле `number_placeholders` и инициализируйте его результатом работы статического метода `get_number_placeholders`. Сделайте compile-time проверку того, что функция успешно выполнилась.

- Реализуйте шаблонный статический метод `get_placeholder_positions`, возвращающий `std::array` из пар позиций, на которых находятся плейсхолдеры. Добавьте соответствующее статическое поле `placeholder_positions` для удобного доступа.

4. В файле format_string.hpp определите user-defined literal `_fs`, чтобы преобразовывать C-style строку в формата в объект класса format_string. Подробнее про кастомные литералы можно почитать [тут](https://en.cppreference.com/w/cpp/language/user_literal%23Standard_library).

  

5. В файле parse.hpp изучите реализацию функции get_current_source_for_parsing, которая возвращает позиции начала и конца строки с исходными данными, которые определяют границы данных для текущей итерации парсинга.

  

6. В файле parse.hpp реализуйте шаблонную функцию parse_input:

- функция должна инкапсулировать всю логику поиска данных для преобразования исходных данных на основе плейсхолдера с индексом, соответствующим целочисленному шаблонному параметру, и выполнения самого преобразования.

- функция должна быть параметризована индексом текущего обрабатываемого плейсхолдера, форматирующей строкой, строкой с исходными данными, а также типом, в который необходимо преобразовать часть исходных данных.

- с помощью готовой функции get_current_source_for_parsing получите позиции начала и конца строки с исходными данными, которые определяют границы данных для текущей итерации парсинга.

- сформируйте из этих позиций фиксированную строку.

- из форматирующей строки получите спецификатор формата(при его наличии)

- запустите парсинг фиксированной строки в конкретный тип и верните из функции полученное значение.

7. В файле parse.hpp определите семейство функций parse_value, конвертирующих подстроку исходных данных в конкретный тип.

  

8. В файле scan.hpp реализуйте главную шаблонную функцию scan:

- функция в качестве шаблонных параметров принимает форматирующую строку format_string, строку с исходными данными fixed_string и набор типов, в которые нужно конвертировать исходные данные.

- scan должна запускать функцию parse_input для каждого типа из переданного пакета типовых шаблонных параметров и индекса этого типа.

- затем агрегировать результаты работы parse_input в объект типа scan_result и возвращать его наружу.

  

9. Внедрите compile-time обработку ошибок с помощью static_assert, чтобы отлавливать некорректные входные данные. Помните, что в условии static_assert могут выполняться только константные выражения.

  

10. Финализируйте работу:

- Протестируйте функцию scan для разных входных данных

- Убедитесь, что выходные данные действительно соответствуют ожидаемым значениям.

- Убедитесь в правильной обработке пограничных случаев и ошибочных сценариев.

  
  

### Общие требования к проекту

1. Должна быть реализована функция scan, выполняющей чтение данных из исходной строки, интерпретацию данных на основе форматирующей строки и сохранение результатов интерпретации в объекты указанных типов во время компиляции.

2. В разработке должны применяться современные возможности C++23, потенциально с использованием расширений С++26, изученные идиомы, практики организации шаблонного кода.

3. Функция должна генерировать ошибку компиляции в случае некорректных данных и compile-time константу при корректных исходных данных.

### Ключевые функциональные требования

  

1. Функция scan должна выполнять сканирование строки с исходными данными на основе форматирующей строки и конвертацию в набор объектов переданных типов.

  

2. Функция scan должна выполняться строго во время компиляции. Попытка получить результат времени выполнения должна приводить к ошибке компиляции.

  

3. Форматирующая строка должна поддерживать следующие converison specifiers: `d` - в исходной строке на месте плейсхолдера находится целое число, `s` - в исходной строке на месте плейсхолдера находится строка, `u` - в исходной строке на месте плейсхолдера находится натуральное число. Поддерживать спецификатор `f` не нужно.

  

4. Функция scan должна поддерживать сканирование данных из исходной строки в следующий набор типов: int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t и std::string_view, а также cv-квалифицированные версии этих типов. Поддерживать std::string не нужно, а использование ссылочных типов нужно запретить .

  

5. Функция scan должна генерировать ошибки компиляции при некорректных исходных данных.

  

### Технические требования

  

В проекте должны применяться:

- Вариабельные шаблоны для обработки неограниченного числа типов.

- Ключевые слова constexpr и consteval для обеспечения обработки во время компиляции.

- Тесты с использованием static_assert на корректные кейсы использования функции.

- Концепты и трейты для ограничения набора типов, с которыми может работать функция.

  
  

## Чек-лист

  

### Обязательные требования

  

- **Реализация класса fixed_string

- [ ] Определен шаблон класса с необходимыми шаблонными параметрами.

- [ ] Реализованы необходимые конструкторы

  

- **Реализация класса format_string

- [ ] Определен шаблон класса с необходимыми шаблонными параметрами.

- [ ] Определены статические методы get_number_placeholders и get_placeholder_positions.

- [ ] Определены статические поля number_placeholders placeholder_positions

- [ ] Определен кастомный литерал для преобразования C-style строки в format_string.

  

- **Парсинг параметров функции scan**

- [ ] Реализована функция parse_input, преобразующая данные согласно i-ому плейсхолдеру.

- [ ] Реализовано семейство функций parse_value, инкапсулирующее логику преобразования подстроки в нужный тип.

  

- **Реализация функции scan**

- [ ] Определено тело функции scan, агрегирующей результаты работы parse_input для всех плейсхолдеров.

- [ ] Поддержано сканирование в типы int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t и std::string_view, а также cv-квалифицированные версии этих типов. Передача любых других типов должно генерировать ошибку компиляции с человекочитаемым сообщением.

- [ ] Поддержано использование спецификаторов`d`, `s` и `u`.

  

- **Обработка ошибок**

- [ ] Ошибка компиляции при некорректном вводе данных.

  

- **Код**

- [ ] Применены вариабельные шаблоны.

- [ ] Применены NTTP значения fixed_string, format_string и целых типов.

- [ ] Все свободные функции помечены consteval.

  

- **Исполнение кода**

- [ ] Код должен исполняться строго во время компиляции.

  

- **Тестирование**

- [ ] Написано не меньше 5 unit-тестов для функции scan.

- [ ] Тесты покрывают использование функции для корректных входных данных.

  

### Опциональные требования

  

- **Обработка ошибок и безопасность**

- [ ] Сompile-time проверки на корректность шаблонных параметров и результатов во всех подходящих местах.

  

- **Архитектура и код**

- [ ] Правильно применена инкапсуляция для скрытия деталей реализации как в рамках классов, так и в рамках файлов.

- [ ] Код соответствует стандарту C++23.

- [ ] Код следует правилам SOLID и KISS.

- [ ] Используются синонимы типов для повышения читаемости кода.

- [ ] Определение длинных методов классов вынесены вне тела класса для лучшей читаемости.

- [ ] Для большей локальности кода короткие функции оборачиваются в лямбды.

  

- **Тестирование**

- [ ] Написано не меньше 10 unit-тестов для функции scan.

- [ ] Тесты покрывают все корректные сценарии использования.

  

[КОММЕНТАРИЙ ДЛЯ КОНТЕНТ-АДМИНА: тип урока external_url_homework, мягкий дедлайн], это продолжение урока с описанием проектной работы, а не новый урок

  

## Сдача работы на ревью

После выполнения проекта вам необходимо будет сдать работу на ревью. Ниже подробная инструкция о том, как это сделать.

  

### GitHub

1. Сделайте ваш репозиторий с проектом на GitHub публичным. В репозитории должна отображаться вся история коммитов в Git.

2. Создайте Pull Request в вашем репозитории из ветки development в ветку main.

  

### Платформа

Чтобы отправить Pull Request на ревью:

1. Кликните на вкладку «Ревью». Там вы увидите форму для отправки ссылки.

![Форма для отправки](https://code.s3.yandex.net/middle-cpp/Рисунок1.png?etag=e9a436c51458d79514a51957731ef225)

2. Вставьте ссылку на ваш Pull Request (PR).

  

![PR](https://code.s3.yandex.net/middle-cpp/PR.jpg?etag=bcd5bfddbd959d5b1364eca111b62a24)

  

3. Нажмите «Отправить». Работа отправится на проверку.

![Кнопка «Отправить»](https://code.s3.yandex.net/middle-cpp/Кнопка.png?etag=e35ef110b0d22c8daf1ce0c3c5a2905e)

Примерно через час начнёт отображаться время отправки.

  

![Время отправки](https://code.s3.yandex.net/middle-cpp/время.png?etag=39609e6a691f2b390c24b78cbae74b0c)

Когда ревьюер приступит к проверке, это отобразится в интерфейсе формы.

![Интерфейс формы](https://code.s3.yandex.net/middle-cpp/интерфейс.png?etag=4e224af1c59be9420f42cb44629e868b)

Если у ревьюера будут замечания по коду, он оставит комментарии и отправит код на доработку.

![Есть замечания](https://code.s3.yandex.net/middle-cpp/замечания.png?etag=7abe8b92b49637534f4b89757ebdb0d4)

  

Вы можете задавать вопросы в чате когорты — скорее всего, ответы будут полезны и другим студентам.

  

После того как вы исправите код с учётом комментариев ревьюера, не забудьте закоммитить изменения. Новый коммит появится в Pull Request, и вы сможете отправить работу на повторную проверку.

  

{quiz-task}

background: |

#AACCF1

content: |

Внимание! Для повторного ревью нужно снова отправить ссылку на PR через эту форму. Только так ревьюер узнает, что вы закоммитили изменения. Иначе он не увидит вашу работу в списке ожидающих проверки.

{/quiz-task}

  

Если комментариев у ревьюера больше нет, работа будет засчитана, а спринт пройден. Это отобразится в интерфейсе Практикума.

  

![Работа засчитана](https://code.s3.yandex.net/middle-cpp/засчитано.png?etag=5012f86ff1cfedc5c97c2b388becbdb3)

  

[Кнопка] Сдать работу

  

[Кнопка] Вперёд