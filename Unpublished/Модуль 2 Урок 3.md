

#### Введение

Шаблоны - это мощный инструмент в руках разработчика. Но этот инструмент очень сложный и в нем много нюансов, которые нужно знать, чтобы использовать всю мощь шаблонов. Сегодня мы разберем некоторые такие нюасы, а именно:

- Как компилятор выводит типы шаблонных параметров для шаблонов функций и классов?
- Как помочь компилятору вывести тип возвращаемого значения функции?
- Что такое универсальный ссылки и идеальная передача?
- Что такое шаблон с точки зрения компилятора и как для него генерируется низкоуровневый код?

#### Вывод типов для шаблонов функций

Мы уже в первом уроке с вами обсуждали, что для шаблонных функций существует автоматический вывод шаблонных параметров. В тот раз мы просто упомянули этот факт и использовали его. Сейчас же более подробнее рассмотрим механизм вывода типов шаблонных параметров.

Вспомним, как это работает:

```cpp
// функция, рандомно перемешивающая последовательность элементов по указателям
template <typename Type>
void shuffle(Type* begin, Type* end);

std::array<int> nums;
shuffle<int>(nums.data(), nums.data() + nums.size()); // явно указываем тип шаблонного параметра
shuffle(nums.data(), nums.data() + nums.size()); // передаем указатели одинаковых типов, компилятор сам сможет вывести единый тип int
shuffle(nums.data(), nums.end()); // ошибка. Компилятор не может вывести единый тип на основе указателя и итератора
```

Мы можем не указывать тип шаблонного параметра шаблонной функции. В этом случае компилятор попробует сам вывести нужный тип на основе аргументов функции. Если он не сможет, то будет ошибка компиляции.

Давайте чуть нагляднее представим задачу компилятора:
```cpp
template <typename T>
void func(ParamType param);

func(expression);
```

Есть шаблонная функция с каким-то шаблонным параметром Т и параметром param с типом ParamType. Задача: по типу expression определить тип ParamType и Т. Здесь есть несколько основных кейсов, которые сейчас разберем.

1 param передается по значению.

В этом случае при передаче объекта тип шаблонного параметра получается из типа expression отбрасыванием ссылочности и верхнеуровневая константности. При передаче указателей отбрасывается константность самого указателя, но константность того, на что он указывает, сохраняется. param - это фактически новый объект, созданный на основе expression. Отдельному объекту не нужно сохранять константность оригинала

```cpp
template <typename T>
void func(T param);

int x = 27;
const int& rx = x;
const int * const cpc = &x;
func(x); // T выведется в int
func(rx); // отбрасываем константную и ссылочную часть, T выведется в int
func(cpc); // сохраняется константность типа, на который указывает указатель, но верхнеуровневая константность(константность самого указателя) отбрасывается. Т выведется в const int *
```

2 param передается по ссылке или указателю

В этом случае если тип expression - ссылка, то Т выводится из типа expression путем отрезания ссылочной части. При этом константность ссылки и объекта, на который указывает указатель сохраняется.

```cpp
template <typename T>
void func(T& param);

int x = 27;
const int& rx = x;
const int * const cpc = &x;
func(x); // T выведется в int
func(rx); // отбрасываем ссылочную часть, но константную сохраняем T выведется в const int
func(cpc); // передача указателя по ссылке разрешена, в этом случае с помощью param можно управлять оригинальным указателей. А значит Т должен быть указателем и для корректной работы вся константность должна сохраняться. Т выведется в const int * const

template <class T>
void func1(T* param);

func1(cpc); // сохраняется константность типа, на который указывает указатель, но константность самого указателя отбрасывается, так как param - копия указателя. Т выведется в const int.

```

3 param передается по константной ссылке или указателю

Здесь аналогично предыдущему кейсы, за исключением, что константность объекта при передаче по ссылке или константность объекта, на который указывает указатель, при передаче указателя не сохраняется.

```cpp
template <typename T>
void func(const T& param);

int x = 27;
const int& rx = x;
const int * const cpc = &x;
func(x); // T выведется в int
func(rx); // отбрасываем и ссылочную, и константную часть.T выведется в int

template <class T>
void func1(const T* param);

func1(cpc); // отбрасывается и константность типа, на который указывает указатель, и константность самого указателя. Т выведется в  int.

```

4 Тип param - это шаблонный класс. То есть:

```cpp
template <typename T>
void func(TemplateClass<T>& param);
```
TemplateClass может быть вектором, умным указателем и еще каким-нибудь шаблонным классом. В этом случае тип Т целиком отражает тип шаблонного параметра класса TemplateClass:

```cpp
template <typename T>
void func(TemplateClass<T>& param);

func(std::deque<double>{}); // T выведется в double
func(std::make_shared<const int>()); // T выведется в const int
```


#### Универсальные ссылки

Это последний кейс при рассмотрении вывода типов. Однако очень важный кейс. С появлением мув-семантики в С++11 у нас появились правые ссылки, которые обозначаются двойным амперсандом(&&). Мы также можем их принимать в качестве параметров функции ссылки с двойным амперсандом , но в этом случае мы будут уже так называемые универсальные ссылки. 

```cpp
template <typename T>
void func(T&& param);
```

Если передать в такую функцию lvalue / lvalue reference, то T выведется в тип ссылки и сам param будет ссылкой. А если передать в функцию rvalue reference, то Т останется без ссылочности, а param будет правой ссылкой.

```cpp
template <typename T>
void func(T&& param);

int x = 27;
const int cx = x;
const int& rx = x;

func(x); // x - это lvalue, поэтому Т выведется в ссылочный тип int&, тип param - int&
func(cx); // cx - это lvalue, поэтому Т выведется в ссылочный тип const int&, тип param - const int&
func(rx); // rx - это lvalue reference, поэтому Т выведется в ссылочный тип const int&, тип param - const int&
func(27); // литерал 27 имеет тип rvalue reference, поэтому T выведется в тип int, а тип param будет int&&
```

Универсальные ссылки - это механизм, который позволяет нам единообразно передавать в шаблонные функции, как левые ссылки, так и правые ссылки.

Важно: Для появления универсальной ссылки важен контекст вывода типов. Он есть у шаблонных функций и шаблонных методов классов, но нет у нешаблонных методов шаблонных классов. В последнем случае тип шаблонного параметра закреплен на этапе создания объекта и при вызове метода не происходит вывода типа:

```cpp
template <typename T>
struct Foo {
	void func(T&& param); // param - всегда rvalue reference
};
```

При вызове этого метода нет контекста вывода типа. тип param всегда будет правой ссылкой и такой метод не сможет принимать левые ссылки в качестве своих аргументов.

Примечание: чтобы вам было проще освоить вывод типов, можете использовать макросы-расширения компилятора, которые возвращают полную сигнатуру функции вместе с подставленными шаблонными параметрами:

```cpp
#if defined __clang__ || __GNUC__
	#define FUNCTION_SIGNATURE __PRETTY_FUNCTION__
#elif defined __FUNCSIG__
	#define FUNCTION_SIGNATURE __FUNCSIG__
#endif

template<typename T>
void func(T param) {
	// на консоль выведется сигнатура функции вместе с подставленным параметром
	std::println(FUNCTION_SIGNATURE);
}
```

Также более подробно про вывод типов вы можете прочитать у Скотта Майерса "Современный и эффективный С++".

#### Perfect Forwarding

Perfect Forwarding используется для идеальной передачи типов параметров функции при использовании универсальных ссылок. Реализуется она с помощью шаблонной функции std::forward.

```cpp
template <typename T>
void func(T&& message) {
	// используем идеальную передачу
	T tmp(std::forward<T>(message));
	// ...
}
```

Теперь в зависимости от того, какую ссылку мы передаем: левую или правую, объект tmp сконструируется либо через конструктор копирования, либо через констуктор перемещения. 

Если сравнивать с std::move, который делает каст к rvalue reference, функция std::forward делает условный каст: к lvalue reference, если мы в функцию передали lvalue или lvalue reference, и к rvalue reference, если в функцию мы передали rvalue reference.

```cpp
std::string str = "blah blah blah";
// Передаем lvalue => вызывается копирующий конструктор std::string tmp(str);
func(str);

// Передает rvalue reference => вызывается мув-конструктор std::string tmp(std::move(str));
func(std::move(str));
```
То есть std::forward выполняет проброс информации о ссылочности типа внутрь. Отсюда и название: forward.


#### auto и decltype

Начиная с C++11, мы можем объявлять переменные с помощью ключевого слова `auto` и компилятор сам выведет тип на основе инициализатора.

```cpp
auto num = 0; // тип num - int, компилятор его сам выведет
```

Механизм вывода типов тут очень похож на вывод типов в шаблонных функциях, за исключением одной детали:

```cpp
auto a = {1, 2, 3}; // тип a - std::initializer_list<int>

template<typename T>
void func(T param);

func({1, 2, 3}); // ошибка, компилятор не сможет вывести тип шаблонного параметра
```

Но c auto есть определенные сложности в работе:

```cpp
// определяем простой класс-одиночку с удаленным копирующим конструктором
struct Signleton {
	static Signleton& Get() { static Signleton sgl; return sgl;}
private:
	Signleton(){}
	Signleton(const Signleton&) = delete;
};

auto ref = Signleton::Get(); // ошибка компиляции
```

auto так же, как и при выводе шаблонных параметров при передаче аргументов по значению, отбрасывает константность. И вместо ожидаемой ссылки, ref становится копией. Но копирующего конструктора у класса нет, поэтому возникает ошибка.

С auto нужно постоянно следить за конкретным типом инициализатора. Это практически невозможно сделать в шаблонах, так как на вход нам может прийти какой угодно тип.

В этом случае помогает оператор decltype. Он позволяет определить точный тип выражения, вместе с ссылочностью и константностью:

```cpp
decltype(Signleton::Get()) ref = Signleton::Get(); 
```
Теперь тип ref совпадает с типом возвращаемого значения метода Get.


#### Вывод типа возвращаемого значения функции


Тип возвращаемого значения шаблонной функции тоже бывает непросто вывести. Если тип возвращаемого значения зависит от параметров функции, то его невозможно указать стандартным путем. Так как возвращаемое значение находится перед параметрами функции, то мы не можем использовать там еще не объявленные параметры . Чтобы решить эту проблему, можно пометить возвращаемое значения как auto и компилятор попытается сам вывести нужный тип.

```cpp
template<typename Container, typename Index> 
// тип возвращаемого значения зависит от конкретного контейнера
auto ElementAccess(Container& c, Index i) {
	return c[i];
}
```

auto позволяет не задумываться о типе возвращаемого значения.

Это будет работать. Но не во всех ситуациях.

```cpp
std::vector<int> vec{1, 2, 3};
ElementAccess(vec, 1) = 5; // ошибка компиляции, функция возвращает не ссылку, как operator[] вектора, а значение
```

Опять дело в особенностях вывода типа auto и отбрасывании ссылок. Чтобы корректно вывести возвращаемый тип шаблонной функции, который зависит от параметров функции, нужно использовать decltype + trailing return type. trailing return type - это синтаксическая конструкция, которая позволяет указывать тип возвращаемого значения функции после параметров функции:

```cpp
template<typename Container, typename Index> 
// указываем тип возвращаемого значения после параметров
auto ElementAccess(Container& c, Index i) -> decltype(c[i]) {
	return c[i];
}

std::vector<int> vec{1, 2, 3};
ElementAccess(vec, 1) = 5;
```

Теперь функция корректно возвращает ссылку на элемент вектора.

#### CTAD: автоматический вывод типов в пользовательских структурах

Автоматический вывод типов в шаблонах функций позволяет в коде использовать функции так, как будто они нешаблонные. Не нужно писать скобки и думать о типах. Компилятор все за нас сделает. 

С классами сложнее, раньше код пестрил угловыми скобками. Начиная с С++17 для классов тоже появился вывод шаблонных параметров (CTAD - Class Template Argument Deduction).

```cpp
template <typename T>
struct Wrapper {
	Wrapper(const T& value) : data{value} {}
	T data;
};

Wrapper obj{42}; // компилятор сам выведет тип Т в int

Wrapper obj1; // ошибка, должен быть инициализатор

std::vector vec{1, 2, 3}; // с классами стандартной библиотеки это тоже работает
```

Вывод типов происходит именно на основе инициализатора, поэтому его наличие обязательно для CTAD.

В большинстве случаев вам ничего дополнительного делать не придется, чтобы компилятор правильно вывел тип. Однако бывают случаи, когда ему нужна подсказка, правило, по которому бы он для конкретного типа инициализатора вывел конкретный шаблонный тип. Для этого существуют deduction guide'ы:

```cpp
template<typename T>
class Wrapper {
public:
    T value;
    Wrapper(const T& val) : value(val) {}
};

// Deduction guide для C-style строк (const char*)
Wrapper(const char*) -> Wrapper<std::string>;
```

Теперь при создании объекта класса Wrapper из C-style строки, тип поля data будет std::string.

С помощью гайдов вы можете тонко настраивать вывод типов для классов и навсегда забыть про указывание шаблонных параметров. Это сильно разгружает код, делает его более читаемым и легким в понимании.


#### Инстанцирование шаблонов

Мы долго обходили это разговор, но пришло время признаться. Шаблоны в С++ сами по себе не генерируют никакого кода при компиляции. И это нормально. В шаблоне не хватает знания о конкретных типах, поэтому компилятор физически не может сгенерировать для него код. По этой причине с шаблонами нельзя использовать стандартный подход с header + source файлами:

```cpp
// header.hpp

template<typename T>
T square(T value);

// source.cpp
#include "header.hpp"

template<typename T>
T square(T value) {
	return value * value;
}

// main.cpp
#include <print>
#include "header.hpp"

int main() {
	std::println(square(3.14));
}
```

Если использовать стандартную схему с подключением заголовочника с объявлением, и определение его в отдельной единице трансляции, то в итоге будет ошибка линковки. Не будет найдено определение шаблона. Потому что в единице трансляции source.cpp не будет сгенерировано никакого кода.

Чтобы сгенерировать код, компилятору нужен конкретный тип шаблонного параметра и определение шаблона. Тогда у него будет полная информация о всем, что происходит внутри. Инстанциация шаблона - процесс, при котором компилятор генерирует код для шаблона с конкретным шаблонным параметром.

Компилятор пытается инстанцировать шаблон, когда видит, что в коде его используют. В коде выше мы используем шаблон в функции main. Но из-за отсутствия определения шаблона или кода для конкретной инстанциации square\<double> он не сможет собрать программу.

Эта проблема решается путем помещения определения шаблона в заголовочный файл. Тогда компилятор в момент инстанцирования будет видеть определение шаблона и сможет сгенерировать для него код.

```cpp
// header.hpp
template<typename T>
T square(T value) {
	return value * value;
}

// main.cpp
#include <print>
#include "header.hpp"

int main() {
	std::println(square(3.14));
}
// Сейчас программа скомпилируется успешно
```

#### Явная и неявная инстанциация

В примере выше мы неявно инстанцировали шаблон. Простое использование шаблона с конкретным шаблонным параметром - неявная инстанциация.

Но неявная инстанциация одних и тех же шаблонов в разных единицах трансляции ведет к увеличению времени компиляции. В каждой единице трансляции компилятор будет генерировать один и тот же код.

Но если мы знаем, что часто будем использовать шаблон с каким-то конкретным шаблонным параметром, или просто знаем с каким набором типов будет использован шаблон, мы можем использовать явную инстанциацию. Это может помочь уменьшить время компиляции и размер бинарных файлов.

Мы можем явно попросить компилятор сгенерировать код для шаблона с конкретным параметром, оставить его в отдельной единице трансляции и линковать эту единицу трансляции с использующим шаблон кодом:

```cpp
// header.hpp

template<typename T>
T square(T value);

// source.cpp
#include "header.hpp"

template<typename T>
T square(T value) {
	return value * value;
}

// явная инстанциация
template double square<double>(double);

// main.cpp
#include <print>
#include "header.hpp"

int main() {
	std::println(square(3.14));
}
```

Теперь в единице трансляции source.cpp будет код для шаблона square\<double> и мы может ее линковать к использующему шаблон коду. Тогда компилятор успешно соберет код, даже при условии, что он не видит определения шаблона.


В конце, давайте повторим то, что мы сегодня узнали:

- Существуют несколько правил вывода типов шаблонных параметров функций
- Универсальные ссылки - это инструмент, позволяющий принимать аргументы разной ссылочности.
- Идеальная передача работает в тандеме с универсальными ссылками и позволяет правильно прокидывать тип аргументов функции во внутренние вызовы. 
- Trailing return type и decltype позволяют корректно выводить тип возвращаемого значения шаблонов функций.
- Для классов тоже есть вывод типов. Мы можем помочь компилятору правильно выбрать тип с помощью deduction guide'ов.
- Шаблоны сами по себе не генерируют код, для этого их нужно инстанцировать
- Явная инстанциация помогает оптимизировать время компиляции в случае обильного использования шаблонов во многих единицах трансляции.


