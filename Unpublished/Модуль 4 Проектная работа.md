# Модуль 4 Проектная работа
# Финальный проект модуля — разработка анализатора кода

- Модуль: 4 - Диапазоны
- Навык: умеет гибко обрабатывать последовательности элементов и комбинировать преобразования в pipelineэ'ы вычислений.
- Проверяемые ОРы:
  - Применяет std::views::filter, std::views::transform. Функции в файле include/analyse.hpp.
  - применяет std::ranges::views::chunk_by, Функции разбиения результатов подсчета метрик по классам SplitByClasses и файлам SplitByFiles в файле include/analyse.hpp
  - Применяет компановку адаптеров диапазонов - 4. Функции в файле include/analyse.hpp.
  - Применяет диапазонные формы алгоритмов стандартной библиотеки -  Вывод на консоль результат аггрегации метрик, реализация самих метрик
  - Применяет std::ranges::to -  Функции в файле include/analyse.hpp.



## Контент

Поздравляем, вы изучили тему «Диапазоны». Чтобы проверить полученные знания на практике, предлагаем вам выполнить проектную работу, в процессе которой вам предстоит:

1. Разработать приложение, которое будет анализировать и считать метрики для python кода; 
2. Покрыть тестами каждую метрику  с помощью фреймворка `GTest`.

Анализировать код вам нужно будет на основе AST синтаксических деревьев файлов исходного кода, которые будет генерировать утилита tree-sitter.

Ссылки на необходимые материалы вы найдёте в плане реализации проекта.


## План реализации проекта CryptoGuard

1. Подготовьтесь к работе:
   - Откройте [шаблон проекта CryptoGuard](https://github.com/Yandex-Practicum/cpp-middle-project-sprint-1){target="_blank"}.
   - Выполните инструкции в разделе `Начало работы`.
   - Соберите проект и запустите приложение по шагам в разделе `Сборка проекта и запуск тестов`.

2. Изучите проект tree-sitter :
- Прочитайте статью об AST деревьях: https://ru.wikipedia.org/wiki/Абстрактное_синтаксическое_дерево
- Изучите документацию о проекте и об утилите командной строки: https://tree-sitter.github.io/tree-sitter/index.html, https://tree-sitter.github.io/tree-sitter/cli/index.html.
- Прочитайте статью, в которой описывается функционал tree-sitter: https://habr.com/ru/articles/670140/.
- Попробуйте выделить AST дерево из python кода на этом ресурсе: https://tree-sitter.github.io/tree-sitter/playground. Проанализируйте получившееся дерево, изучите его составные элементы. Тестовый файл можете найти по пути files/sample.py в проекте Analyser.

3. Изучите класс `ProgramOptions`:
   - Изучите документацию о классе `boost::program_options` по ссылкам:
     - https://www.boost.org/doc/libs/1_63_0/doc/html/program_options.html;
     - https://www.boost.org/doc/libs/1_63_0/doc/html/program_options/tutorial.html.
   - Класс ProgramOptions позволяет приложению принимать 1 параметр командной строки: список файлов для обработки.

4. Изучите класс File:
- В этом классе инкапсулирована логика выделение AST дерева из файла и строк исходного кода.
- Обратите внимание на статическое поле - это префикс команды tree-sitter для выделения AST из файла. Вы также можете пользоваться этим префиксом в командной строке: для получения полноценной команды запуска допишите полный путь к файлу. 
- Запустите команду выделения AST в терминале в директории проекта для файла files/sample.py, которая прописана в файле tree-sitter-sample.txt  Изучите ее вывод, как устроено AST дерево, какие сущности она описывает.

5. Изучите файл include/function.hpp:
- Изучите структуру Function: она представляет собой метаданные функции(имя функции, файл, в котором она находится, и опционально имя класса), а также AST конкретно этой функции.
- Изучите класс FunctionExtractor. Он предназначен для выделения набора структур Function из объекта класса FIle. 

6. Изучите файл include/metric.hpp. В нем объявлены:
   - Cтруктура MetricResult, представляющая собой результат вычисления метрики.
   - Интерфейс IMetric, представляющая собой базовый класс для реализации вычисления конкретных метрик кода.
   - Класс MetricExtractor, который из структуры Function выделяет все зарегистрированные метрики.

7. Реализуйте необходимые компоненты для подсчета метрик:
- В файлах-заготовках директории include/metric_impl объявите наследников IMetric, которые будут ответственны за подсчет следующих метрик отдельных функций: количество строк кода без учета комментариев и пропусков строк, [цикломатическая сложность](https://ru.wikipedia.org/wiki/Цикломатическая_сложность), количество параметров. Цикломатическая сложность должна учитывать конструкции if/else, elif, while, for, try/catch/finally, match/case, assert, ternary operator.
- В файлах-заготовках директории src/metric_impl напишите определения методов наследников IMetric.
- В src/metric.cpp реализуйте методы класса MetricExtractor.

8. Изучите файл include/metric_accumulator.hpp. В нем объявлены:
- Интерфейс IAccumulator, представляющая собой базовый класс для аггрегации вычисления конкретных метрик кода.
- Класс MetricsAccumulator, который предназначен для аккумуляции переданного результата метрики с помощью подходящего аккумулятора.

9. Реализуйте необходимые компоненты для аккумуляции метрик:
- В файлах-заготовках директории include/metric_accumulator_impl объявите наследников IAccumulator, которые будут ответственны за аггрегацию результатов реализованных метрик.
- В файлах-заготовках директории  src/metric_accumulator_impl напишите определения методов наследников IAccumulator.
- Для метрик цикломатической сложности и количества строк кода аккумулятор должен возвращать сумму и среднее значение всех метрик. Для метрики количества параметров нужно считать только среднее значение всех метрик.
- Реализуйте шаблонные методы класса MetricsAccumulator в include/metric_accumulator.hpp, а нешаблонные методы - в src/metric_accumulator.cpp

10. В файле include/analyse.hpp реализуйте следующие функции:
- AnalyseFunctions, которая принимает список имен файлов и объект MetricExtractor и запускает:
	- создание структур File на основе имен файлов
	- для каждого файла с помощью FunctionExtractor выделяет список объектов Funtion
	- объединяет списки объектов Funtion в один список
	- выделяет из каждой функции метрики
	- возвращает вектор пар из объекта Function и набора результатов вычисления метрик MetricResult.
- SplitByClasses, которая:
	- отфильтровывает результат вычисления предыдущей функции, так чтобы в нем остались только методы классов.
	- разбивает отфильтрованную последовательность на части, в которых содержатся функции и результаты вычисления метрик, принадлежащие одному классу.
- SplitByFiles, которая разбивает результат вычисления AnalyseFunctions на части так, чтобы в каждой части содержались функции и результаты вычисления метрик, принадлежащие одному файлу
- AccumulateFunctionAnalysis, которая для каждого элемента результата вычисления AnalyseFunctions с помощью объекта MetricsAccumulator аггрегирует результаты вычисления метрик для каждой функции.

11. Протестируйте функционал вычисления метрик:
- в директории src/metric_impl/tests в файлах-заготовках реализуйте модульные тесты для каждой метрики. Для тестирования используйте файлы, содержащиеся в директории src/metric_impl/tests/files.

12. Протестируйте функционал аггрегации результатов вычисления метрик:
- в директории src/metric_accumulator_impl/tests в файлах-заготовках реализуйте модульные тесты для каждого аккумулятора метрик.

13. В файле main.cpp реализуйте:
- Выделения списка файлов для обработки с помощью объекта класса ProgramOptions.
- Регистрацию метрик в объект MetricExtractor.
- Запуск AnalyseFunctions.
- Вывод на консоль результаты анализа в виде:
```
path_to_file[::class_name]::function_name: 
    metric_name1: result1
    metric_name2: result2

```
- Регистрацию аккумуляторов метрик в объект MetricsAccumulator.
- Разделение результатов анализа функций по файлам с помощью SplitByFiles.
- Для результатов анализа функций из каждого файла запуск аггрегации метрик.
- Вывод на консоль результат аггрегации метрик в виде:
```
Accumulated Analysis for file path_to_file:
    aggregated_metric1: result1
    aggregated_metric2: result2
```

- Разделите результаты анализа функций по класса с помощью SplitByClasses.
- Для результатов анализа функций из каждого класса запуск аггрегации метрик.
- Вывод на консоль результатов аггрегации метрик в виде:
```
Accumulated Analysis for сlass class_name:
    aggregated_metric1: result1
    aggregated_metric2: result2
```

14. Улучшите обработку ошибок:
-  Реализуйте обработку ошибок с помощью информативных исключений типа `std::runtime_error`.

15.  Финализируйте работу:
- Протестируйте корректность функционала main.cpp на примерах разнообразных python файлов.


## Требования к результатам работы для студента

### Общие требования к проекту
1. Должно быть создано приложение для анализа кода python файлов, подсчета и аггрегации метрики кода. 
2. В разработке должны применяться современные возможности C++, изученные возможности библиотеки диапазонов, библиотеки `Boost` и `GTest`.
3. Система должна корректно вычислять и аггрегировать метрики функций.

### Ключевые функциональные требования
В системе должны быть реализованы:
1. Возможность подсчета метрик анализа кода: количество строк кода без учета комментариев и пропусков строк, цикломатическая сложность, количество параметров.
2. Цикломатическая сложность должна учитывать конструкции if/else, elif, while, for, try/catch/finally, match/case, assert, ternary operator.
3. Возможность аггрегации посчитанных метрик для конкретных файлов и классов.

### Технические требования
В системе должны применяться:
- Алгоритмы и отображения стандартной библиотеке
- Корректная обработка ошибок и исключительных ситуаций.
- Unit-тесты для проверки функциональности.

### Ограничения
Приложение должно уметь анализировать только обычные свободные функции и методы классов. Не нужно поддерживать обработку вложенных функций и декораторов.

Также запрещается использовать range-based-for циклы по диапазонам и простые циклы по индексам. Вместо этого используйте библиотеку диапазонов.

## Чек-лист 

### Обязательные требования

- **Реализация подсчета метрик**
  - [ ] В директории include/metric_impl во всех файлах заготовках объявлены наследники IMetric, которые ответственны за подсчет конкретных метрик, со всеми необходимыми методами.
  - [ ] В директории src/metric_impl во всех файлах заготовках определены методы соотвествующих наследников IMetric, которые ответственны за подсчет конкретных метрик.

- **Реализация аггрегации метрик**:
 - [ ] В директории include/metric_acumulator_impl во всех файлах заготовках объявлены наследники IAccumulator, которые ответственны за аггрегацию результатов конкретных метрик, со всеми необходимыми методами.
  - [ ] В директории src/metric_acumulator_impl во всех файлах заготовках определены методы соответсвующих наследников IAccumulator.

- **Анализ функций**:
  - [ ] В файле include/analyse.hpp реализованы функции AnalyseFunctions, SplitByClasses, SplitByFiles и AccumulateFunctionAnalysis.
  - [ ] На консоль выведены результаты подсчета метрик для всех функций и методов классов для файлов, переданных через аргументы командной строки.
  - [ ] На консоль выведены результаты аггрегации метрик методов для конкретных классов, всех функции и методов в конкретных файлах и для всех функций во всех файлах

- **Обработка ошибок и безопасность**
  - [ ] Корректная обработка нештатных ситуаций с помощью исключений

- **Архитектура и код**
  - [ ] Повсеместное применение адаптеров диапазонов и композиции отображений с помощью pipe-синтаксиса.
  - [ ] Отсутствуют range-based-for циклы и простые циклы по индексам.
  - [ ] В коде функций из файла inlcude/analyse.hpp используются только композиции отображений.

- **Тестирование**
  - [ ] Написано 10 unit-тестов для каждой метрики, по одному на каждый файл из src/metric_impl/tests/files.
  - [ ] Написано не менее 5 unit-тестов для каждого аккумулятора метрик. 
  - [ ] Тесты покрывают основные сценарии использования.

### Опциональные требования

- **Реализация подсчета метрик**
  - [ ] Дополнительно можете реализовать метрику, которая бы по названию функции определяла бы ее naming style: camel case, snake case, pascal case, lower case(все буквы строчные, без разделителей) и unknown. 
  - [ ] Для этого вам понадобится изменить структуру MetricResult, чтобы в ней могли храниться результаты вычисления метрик разных типов. В этом может помочь стандартный класс std::variant, типобезопасный аналог union, который может одновременно хранить несколько типов, заранее определенных в его шаблонных параметрах. Более подробно как работать с std::variant можно найти [здесь](https://en.cppreference.com/w/cpp/utility/variant.html). Это дополнение практически не изменит код подсчета остальных метрик, нужно будет лишь в них явно приводить результат вычисления к нужному типу через [std::get](https://en.cppreference.com/w/cpp/utility/variant/get). Для единообразного вывода значения std::variant на консоль можно использовать вот эту конструкцию: `std::visit([](auto &&val) { std::println("{}", val); }, result.value);`
  - [ ] Также нужно будет реализовать аккумулятор CategoricalAccumulator, который считает количество появлений различных naming style для всех аккумулируемых результатов метрик.
  - [ ] Заготовки файлов с объявлением и определением метрики naming style и соотвествующего аккумулятора нужно добавить в сборку cmake.

- **Обработка ошибок и безопасность**
  - [ ] Использование информативных исключений.

- **Архитектура и код**.
  - [ ] Код соответствует современным стандартам C++

- **Тестирование**
  - [ ] Реализованы юнит тесты для метрики naming style.
  - [ ] Написано не меньше 8 unit-тестов для всех аккумуляторов метрик.
  - [ ] Использованы параметрические тесты GTest
 
[КОММЕНТАРИЙ ДЛЯ КОНТЕНТ-АДМИНА: тип урока external_url_homework, мягкий дедлайн], это продолжение урока с описанием проектной работы, а не новый урок

## Сдача работы на ревью
После выполнения проекта вам необходимо будет сдать работу на ревью. Ниже подробная инструкция о том, как это сделать.

### GitHub
1. Сделайте ваш репозиторий с проектом на GitHub публичным. В репозитории должна отображаться вся история коммитов в Git. 
2. Создайте Pull Request в вашем репозитории из ветки development в ветку main.

### Платформа
Чтобы отправить Pull Request на ревью:
1. Кликните на вкладку «Ревью». Там вы увидите форму для отправки ссылки.
 
   ![Форма для отправки](https://code.s3.yandex.net/middle-cpp/Рисунок1.png?etag=e9a436c51458d79514a51957731ef225)
   
2. Вставьте ссылку на ваш Pull Request (PR).

    ![PR](https://code.s3.yandex.net/middle-cpp/PR.jpg?etag=bcd5bfddbd959d5b1364eca111b62a24)

3. Нажмите «Отправить». Работа отправится на проверку.
   
   ![Кнопка «Отправить»](https://code.s3.yandex.net/middle-cpp/Кнопка.png?etag=e35ef110b0d22c8daf1ce0c3c5a2905e)
   
Примерно через час начнёт отображаться время отправки.

  ![Время отправки](https://code.s3.yandex.net/middle-cpp/время.png?etag=39609e6a691f2b390c24b78cbae74b0c)
  
Когда ревьюер приступит к проверке, это отобразится в интерфейсе формы.
 
 ![Интерфейс формы](https://code.s3.yandex.net/middle-cpp/интерфейс.png?etag=4e224af1c59be9420f42cb44629e868b)
 
 Если у ревьюера будут замечания по коду, он оставит комментарии и отправит код на доработку.
 
 ![Есть замечания](https://code.s3.yandex.net/middle-cpp/замечания.png?etag=7abe8b92b49637534f4b89757ebdb0d4)

Вы можете задавать вопросы в чате когорты — скорее всего, ответы будут полезны и другим студентам. 

После того как вы исправите код с учётом комментариев ревьюера, не забудьте закоммитить изменения. Новый коммит появится в Pull Request, и вы сможете отправить работу на повторную проверку.

{quiz-task}
    background: |
        #AACCF1 
    content: |
Внимание! Для повторного ревью нужно снова отправить ссылку на PR через эту форму. Только так ревьюер узнает, что вы закоммитили изменения. Иначе он не увидит вашу работу в списке ожидающих проверки.
{/quiz-task}

Если комментариев у ревьюера больше нет, работа будет засчитана, а спринт пройден. Это отобразится в интерфейсе Практикума.

 ![Работа засчитана](https://code.s3.yandex.net/middle-cpp/засчитано.png?etag=5012f86ff1cfedc5c97c2b388becbdb3)

[Кнопка] Сдать работу

[Кнопка] Вперёд