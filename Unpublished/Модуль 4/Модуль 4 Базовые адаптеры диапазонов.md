
ОРы:
- понимает различия в моделях вычислений
- понимает pull модель
- применяет std::views::filter, std::views::transform
- комбинирует адаптеры с помощью функционального и pipe синтаксиса

Структура

- Мы поговорили об отображениях, которые представляют полностью весь контейнер или только его часть, а также о фабриках диапазонов. Настало время поговорить об отображениях-адаптерах, которые преобразуют диапазон на основе функции.
- std::filter
- std::transform
- Краткое введение про синтаксис композиции адаптеров. Показываем просто результат вычислений. 
- У отображений есть одна особенность - все вычисления ленивые. Чтобы это понять, разберем модели вычислений.
- рассказываем про pull и push модели вычислений на примере паттерна observer и обычной агрегации. observer - push модель(более событийно-ориентированная), агрегация - pull(работа по запросу). Расписываем различия, плюсы и минусы каждого.
- Приводим примеры для моделей при обработке последовательностей. pipes и ranges.
- в ranges в выходной последовательности любого отображения(и комбинированного) каждый элемент получается путем накладывания "призм"-отображений на элементы оригинального диапазона. Итоговое отображение сразу не знает значения элементов, которые оно содержит. Значения вычисляются по мере необходимости новых элементов, то есть строго по запросу.
- добиваем тему раскрытием вариантов комбинации адаптеров с помощью функционального и pipe синтаксиса.


Введение

Отображения позволяют не только смотреть на диапазоны и генерировать новые последовательности. Они могут еще и изменять элементы последовательности. Сегодня вы узнаете:

- что такое адаптеры диапазонов;
- для чего используются адаптеры std::views::filter и std::views::transform
- как различаются модели вычислений по характеру общения производителя и потребителя данных.
- какую модель данных представляют отображения в библиотеке ranges.
- какие 2 синтаксиса комбинации адаптеров диапазонов.

Контент

## Мощь отображений

Вся прелесть отображений в их простоте. Это просто итератор и ограничитель. Благодаря этому мы не только можем не нуждаться в контейнере, чтобы получить последовательность(с помощью фабрик диапазонов), но и изменять содержимое существующих диапазонов. Для этого существует класс отображений - адаптеры диапазонов.

Адаптеры принимают callable и позволяет преобразовывать количество и содержимое элементов последовательности в соответствии с этим callable. Существует большое количество адаптеров для разных задач. В этом уроке мы рассмотрим несколько базовых примеров.

## std::views::filter

std::views::filter позволяет отфильтровывать нужные в данный момент элементы диапазона с помощью предиката. Если предикат возвращает true, элемент остается в итоговом отображении. Если false - нет. 
К примеру мы хотим убрать из диапазона все отрицательные числа. Вот как мы это можем сделать:

```cpp
std::vector vec = {0, 5, -4, 10, 500, -7, -1, 0};
auto non_negative = std::views::filter(vec, [](const auto& elem) { return elem >= 0; });
for (const auto& elem : non_negative)
	std::print("{} ", elem);
// вывод: "0 5 10 500 0"
```

У многих адаптеров, в том числе и у std::views::filter, помимо прочих методов также есть метод base, который возвращает изначальный диапазон:

```cpp
for (const auto& elem : non_negative.base())
	std::print("{} ", elem);
// вывод: 0 5 -4 10 500 -7 -1 0 
```

## std::views::transform

std::views::transform позволяет изменять содержимое диапазона на основе функтора callable и, потенциально, даже изменять тип объектов в отображении.

Пусть у нас есть вектор чисел и мы хотим взять модуль каждого числа и обернуть его в структуру Number. Это легко можно сделать с помощью std::views::transform:

```cpp
struct Number {
	int i;
};

std::vector vec = {0, 5, -4, 10, 500, -7, -1, 0};
auto transformed = std::views::transform(vec, [](const auto& elem) { return Number{std::abs(elem)}; });
for (const auto& elem : transformed)
	std::print("{} ", elem.i);
// вывод: 0 5 4 10 500 7 1 0 
```

У этого адаптера также есть метод base:

```cpp
for (const auto& elem : transformed.base())
	std::print("{} ", elem);
// вывод: 0 5 -4 10 500 -7 -1 0 
```


## Композиция адаптеров

А что если мы хотим все вместе сделать? И отфильтровать отрицательные числа и обернуть их в структуру Number? Отображения позволяют легко это сделать с помощью композиции.

Если адаптер возвращает отображение, то его можно передать в качестве аргумента другого адаптера:

```cpp
struct Number {
	int i;
};

std::vector vec = {0, 5, -4, 10, 500, -7, -1, 0};
auto transformed = std::views::transform(std::views::filter(vec, [](const auto& elem) { return elem >= 0; }), [](const auto& elem) { return Number{elem}; });
for (const auto& elem : transformed)
	std::print("{} ", elem.i);
// вывод: "0 5 10 500 0"
```

Таким образом можно комбинировать разные адаптеры, чтобы максимально гибко изменять диапазон под ваши нужды. В примере показан так называемый функциональный синтаксис композиции адаптеров, потому что данные передаются в следующее отображение, как аргументы функции.

А вот вам вопрос на засыпку. Алгоритмы привычной нам STL на работают сразу и получают результат полностью и сразу. И из-за особенность дизайна для преобразований STL часто приходится использовать proxy объекты, которые особо не нужны в результате:

```cpp
std::vector<int> vec = {0, 5, -4, 10, 500, -7, -1, 0};
std::vector<Number> transformed;
std::vector<int> filtered_vec;
std::copy_if(vec.begin(), vec.end(), std::back_inserter(filtered_vec),
[](int n) { return n >= 0; });

std::transform(filtered_vec.begin(), filtered_vec.end(), std::back_inserter(transformed),
[](int n) { return Number{n}; });

for (const auto& elem : transformed)
	std::print("{} ", elem.i);
```

Мы видим, что вычисления идут строго по порядку, перетекая из одного вектора в другой.

А как это работает в адаптерах диапазонов и отображениях ranges? Там тоже результаты операций вычисляются по очереди?

*Кнопка* Давайте узнаем, как это работает в ranges

## Модели вычислений

Прежде чем рассказать, как работают комбинации отображений в ranges, нам нужно понимать, какие есть модели вычислений по характеру взаимодействия производителя и потребителя данных.

Всего есть 2 модели: push и pull.

## Push модель

В Push модели производитель отправляет данные потребителю, когда они готовы. Потребитель не знает, когда получит данные. Это очень похоже на рассылку некоторого события, которое содержит некую информацию. Поэтому такая модель часто используется в событийно-ориентированных архитектурах.

Самый базовый пример push-модели - паттерн Observer. В нем есть 2 сущности: слушатель и уведомитель. Слушатели подписываются на события уведомителя и пассивно ждут сигнала, чтобы начать обработку данных. Уведомитель же решает, когда наступает целевое событие и сообщает от этом всем подписанным сущностям:

```cpp
// Consumer (обработчик данных)
class NumberProcessor {
public:
	void process(int num) {
		std::println("Received: {}", num * num);
	}
};

// Producer (источник данных)
class EventNumberGenerator {
	std::vector<NumberProcessor> processors;
public:
	// подписываем обработчики чисел
	void subscribe(NumberProcessor&& processor) {
		processors.push_back(std::move(processor));
	}
	
	void generate() {
		// прbтворяемся, что сгенерировали какие-то данные
		static const std::vector<int> data = {1, 2, 3, 4, 5};
		for (int num : data) {
			for (auto& processor : processors) {
				processor.process(num); // Производитель "толкает" данные ко всем потребителям
			}
		}
	}
};

int main() {
	EventNumberGenerator generator;
	NumberProcessor processor;
	generator.subscribe(std::move(processor));
	generator.subscribe(NumberProcessor{});

	generator.generate();
}
```

Особенности push-модели:

- Производитель контролирует поток данных
- Поддерживает архитектуру "один производитель - много потребителей"
- Хорошо подходит для событийно-ориентированных систем


## Pull модель

В Pull модели потребитель запрашивает данные у производителя, когда они ему нужны. Производитель не знает, когда ему нужны данные. Без работы он лежит под солнышком, пьет лонг-айленд и ничего не делает. Работать производитель начинает только тогда, когда у него попросили данные.

Это более простая модель и здесь примером может являться обычная агрегация данных в объекте. 

Допустим у нас есть класс CreditScore, который отвечает за вычисление кредитного скора человека. Это довольно комплексный класс, в котором мы хотим сохранять итоговые значения скора в базу данных для аналитики и построения более сложных моделей, а также вычислять и сохранять какие-то метрики. Логично вынести непоследственную логику вычисления скора в отдельный класс Model, который будет заниматься только лишь вычислением скора в методе Calculate. Посмотрим на код:

```cpp
struct CreditScore {
	double Calculate(const Person& person) {
		// ... возможная предобработка данных

		// вычисляем скор
		double score = model->Calculate(data);
		// сохраняем данные в базу
		db->Save(person, score);
		// обновляем метрики
		metrics->UpdateMetrics(score);
		return score;
	}
	std::unique_ptr<Model> model;
	std::shared_ptr<DbConnection> db;
	std::shared_ptr<Metrics> metrics;
}
```

В этой картине Model - это производитель данных, а CreditScore - потребитель, который делает запрос. Модель работает только по команде потребителя и простаивает без этих команд.

Заметим, что в этом случае не может быть отношения "один производитель - много потребителей". Потребитель данных только один - тот, который делает запрос.

Особенности pull-модели:

- потребитель контролирует поток данных
- более простая архитектура решения
- ленивые вычисления


## Модели вычислений при обработке последовательностей

В С++ можно реализовать, как push, так и pull модель обработки последовательностей. 

## Pipes

Примером реализации push модели является библиотека [pipes](https://github.com/joboccara/pipes). Вот пример комбинации нескольких алгоритмов c помощью pipes:

```cpp
auto const source = std::vector<int>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto destination = std::vector<int>{};

source >>= pipes::filter([](int i){ return i % 2 == 0; })
       >>= pipes::transform([](int i){ return i * 2; })
       >>= pipes::push_back(destination);

// destination contains {0, 4, 8, 12, 16};
```

Данные из вектора source отправляются в вектор destination через пайплайн преобразований. Заметьте, что destination или пользователь destination не контролирует, когда он хочет получить данные. Он их уже по факту имеет после выполнения пайплайна.

Чуть более сложный пример:

```cpp
// трансформируем A с помощью f
A >>= pipes::transform(f)
// дальше фильтруем результат с помощью p
  >>= pipes::filter(p)
// отправляем результат в 3 получателя
  >>= pipes::fork(pipes::push_back(C),
						// еще раз фильтруем с помощью q и отправляем в D
					   pipes::filter(q) >>= pipes::push_back(D),
					   // еще раз фильтруем с помощью r и отправляем в E
					   pipes::filter(r) >>= pipes::push_back(E));
```

К последовательности A применяем трансформационную функцию f -> применяем фильтрующую функцию p -> отправляем данные в 3 получателя C, D и E -> перед отправкой данных в D и E еще раз фильтруем последовательность с помощью q и r.

В этом примере демонстрируется одна из ключевых особенностей push-модели: отношение "один производитель - много потребителей". Одни и те же данные отсылаются в разные источники.

## Ranges

Отображения ranges, в целом, и адаптеры, в частности, реализуют pull-модель. Когда мы рассматривали фабрики диапазонов, мы говорили, что элементы в них генерируются на ходу: при инкременте итератора вычисляется новый элемент последовательности. С адаптерами похожая история. Так как адаптер - это отображение, то это легковесный объект и он хранит только итератор на начало и ограничитель. Поэтому он вынужден на ходу вычислять новые элементы последовательности.

Например, std::views::transform генерирует новый элемент с помощью применения callable объекта к элементу оригинальной последовательности:

```cpp
struct Number {
	int i;
};

std::vector vec = {0, 5, -4, 10, 500, -7, -1, 0};
auto transformed = std::views::transform(vec, [](const auto& elem) { return Number{std::abs(elem)}; });

// получаем итератор
auto it = transformed.begin();
// получили первый элемент нового диапазона с помощью применения функтора
auto elem0 = *it;
// получили второй элемент нового диапазона с помощью применения функтора
auto elem1 = *(++it);
...
```

Элементы генерируются по запросу вместе с инкрементом итератора. Пользователь отображения контролирует, когда и как он хочет инкрементировать его. Отображение не знает значения новых элементов: оно лениво существует, пока ему не приказать делать полезную работу. Это яркий признак pull-модели.

## Композиция отображений

И для композиции, состоящей из нескольких отображений тоже характерна pull-модель.

В ranges в выходной последовательности любого комбинированного отображения каждый элемент получается путем накладывания "призм"-отображений на элементы оригинального диапазона. Итоговое отображение сразу не знает значения элементов, которые оно содержит. Значения вычисляются по мере необходимости новых элементов, то есть строго по запросу.

Допустим, мы хотим сгенерировать первые 10 чисел Фибоначчи. Мы можем скомбинировать несколько отображений и получить нужный результат:

```cpp
auto fibonacci = std::views::iota(0) | 
				 std::views::transform([](int n) {
					static int a = 0, b = 1;
					int next = a;
					a = b;
					b += next;
					return next;
				}) |
				 std::views::take(10);
for (const auto& elem : fibonacci)
	std::print("{} ", elem);
// вывод: 0 1 1 2 3 5 8 13 21 34 
```

Здесь фабрика std::views::iota задает порядковый элемент последовательности Фибоначчи. std::views::transform отвечает за непосредственную генерацию нужного порядкового элемента. А std::views::take - специальное отображение, которое берет из диапазона не больше, чем N элементов(если в диапазоне элементов меньше, чем N, то берет сколько есть).

Элементы не генерируются все сразу. Только при запросе нового элемента комбинированного диапазона начинается генерация с помощью наложения операций отображений друг на друга. Это позволяет, например, использовать бесконечные диапазоны(как std::views::iota в примере), потому что последовательность формируется не сразу.

В примере мы также использовали второй возможный синтаксис комбинации отображений - pipe-синтаксис. С его помощью вы более наглядно определяете последовательность преобразований(*pipe*line), которые должен пройти оригинального диапазона элемент, чтобы в итоге стать элементом выходного диапазона.

Композиции отображений - это отличный способ гибко изменять последовательность элементов. Вы не будете тратить лишнюю память, как в случае c STL, на промежуточные результаты. А также не будете делать ненужную работу и сможете использовать уникальные возможности бесконечных диапазонов.

## Заключение

Сегодня вы узнали:

- адаптеры диапазонов помогаю изменять содержимое существующих диапазонов.
- std::views::filter помогает отфильтровывать только нужные элементы.
- std::views::transform помогает преобразовывать элементы диапазона в другие значения.
- существует 2 модели вычислений по характеру отношений между производителем и потребителем данных: push и pull модель.
- в push-модели производитель контролирует поток данных и она поддерживает отношения "один производитель - много потребителей".
- в pull-модели потребитель контролирует поток данных и ей характерна ленивость вычислений.
- ranges отображения реализованы с использованием pull-модели.
- существуют 2 синтаксиса комбинации адаптеров и отображнений диапазонов: функциональный и pipe- синтаксисы.





