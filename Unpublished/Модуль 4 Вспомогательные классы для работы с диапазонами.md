
Оры:
- применяет ranges::dangling
- понимает концепцию borrowed_range
- применяет ranges::to для конвертации диапазона в контейнер

Структура:

- Возвращаемся к сигнатуре std::ranges::sort и поясняем про borrowed_iterator_t и кейс, когда передаем временное значение.
- Квиз 1
- Показываем возможную реализацию borrowed_iterator_t и находим там borrowed_range. borrowed_range - это рэндж, который не провисает.
- Квиз 2
- иногда нам нужна не просто итерация по преобразованному пайплайном отображнений диапазону, а нужно получить контейнер, содержащий преобразованные элементы. в этом помогает ranges::to. 
- Сниппет 


Введение

Чтобы удобно и безопасно работать с отображениями и алгоритмами ranges, в стандартной библиотеке есть вспомогательные классы, о которых мы сегодня и поговорим. Вы узнаете:

- Что будет, если запустить алгоритм ranges на временном объекте.
- что такое borrowed_range.
- как можно из отображения получить готовый контейнер со всеми элементами.

Контент

## borrowed iterator

Вернемся к тому, с чего начинали. А именно с сигнатуры алгоритма std::ranges::sort:

```cpp
template<std::ranges::random_access_range R, class Comp = std::ranges::less,
          class Proj = std::identity>  
requires std::sortable<std::ranges::iterator_t<R>, Comp, Proj>  
constexpr std::ranges::borrowed_iterator_t<R>  
    sort( R&& r, Comp comp = {}, Proj proj = {} );
```

В вводном уроке по диапазонам и отображениям мы сказали, что постепенно будем разбирать составные части этой конструкции. Сегодня пришел черед последнего пазла.

std::ranges::sort, в отличии от std::sort, имеет возвращаемое значение. Диапазонная сортировка возвращает итератор на конец последовательности отсортированной последовательности. Это позволяет строить на основе этого итератора логику:

```cpp
std::vector<int> v{1, 2, 1, 1, 3, 3, 3, 4, 5, 4};
// сортируем вектор и затем убираем из него все повторяющиеся подряд значения, кроме первого
const auto [first, last] = std::ranges::unique(v.begin(), std::ranges::sort(v));
// std::ranges::unique как и std::remove, возвращает итератор, начиная с которого находятся ненужные элементы, которые можно удалить
v.erase(first, last);
for (const auto& elem : v)
	std::print("{} ", elem);
// Вывод:
// 1 2 3 4 5 
```

Мы можем отсортировать последовательность и удалить все одинаковые подряд идущие элементы, кроме первого. Тем самым мы получим все уникальные элементы последовательности.

Однако std::ranges::sort возвращает не обычный итератор std::ranges::iterator_t, а std::ranges::borrowed_iterator. В чем разница?

Как вы думаете, что произойдет, если передать в std::ranges::sort временный контейнер? 

```cpp
auto it = std::ranges::sort(std::vector{2, 1, 3});
```

По идее временный объект вектора разрушится и мы получим невалидный итератор.

Будет ли опасность получить UB при работе с возвращаемым итератором it в этом случае?

*Кнопка* Хочу знать ответ!

На самом деле ничего плохого не может произойти. И за это отвечает std::ranges::borrowed_iterator. Давайте посмотрим чуть более прямолинейный пример:

```cpp
std::vector<int> foo(int n); // функция
// ищем во временном объекте вектора число и возвращаем на него итератор
auto res = std::ranges::find(foo(42), 1);
// хотим ошибку компиляции при разыменовании!
std::println("{}", *res);
```

Просто ищем во временном объекте вектора число и возвращаем на него итератор. Но компилятор же умеет отличать по категории выражения объекта, передали ли мы в алгоритм временный объект или нет. Поэтому очень хочется, чтобы при передаче в std::ranges::find временного диапазона и попытке разыменовать результирующий оператор, мы получили ошибку компиляции.

И это действительно так работает!

При попытке компиляции появится такая ошибка:
```
error: no match for 'operator*' (operand type is 'std::ranges::dangling')
```

Вот что происходит на самом деле. std::ranges::borrowed_iterator - это что-то типа std::optional. Он содержит либо нормальный итератор, либо std::ranges::dangling. Последний не содержит оператора разыменования, чтобы вы не смогли воспользоваться невалидным итератором. 

Благодаря std::ranges::borrowed_iterator при передаче временных объектов в алгоритмы ranges вы можете не переживать о инвалидации итератоов и неопределенном поведении. Вы просто не сможете использовать std::ranges::dangling и получите ошибку компиляции.

## borrowed range

Мы разобрали, для чего используется std::ranges::borrowed_iterator. Давайте теперь посмотрим, как он устроен внутри. Там кроется кое-что интересное:

```cpp
template<std::ranges::range R>
using borrowed_iterator_t = std::conditional_t<std::ranges::borrowed_range<R>, std::ranges::iterator_t<R>, std::ranges::dangling>;
```

borrowed_iterator_t - это условный тип. Когда диапазон R удовлетворяет концепту std::ranges::borrowed_range, он обращается в валидный тип итератора. И обращается в std::ranges::dangling, когда не удовлетворяет. Получается, что вся логика и магия предотвращения инвалидации итераторов основана на концепте borrowed_range. Давайте посмотрим, что он из себя представляет:

```cpp
template< class R >
concept borrowed_range = ranges::range<R> && (std::is_lvalue_reference_v<R> || ranges::enable_borrowed_range<std::remove_cvref_t<R>>);

// базово для любого заданного типа enable_borrowed_range равен false
template<class R>
constexpr bool enable_borrowed_range = false;
// чтобы выставить его в true нужно полностью специализировать этот шаблон для нужного типа
```

Тип R удовлетворяет концепту borrowed_range, если R - это левая ссылка, или для R определена явная специализация enable_borrowed_range равная true. Сейчас на примерах подробнее разберемся, что к чему.

Еще раз взглянем на этот код:
```cpp
std::vector<int> foo(int n); // функция
// ищем во временном объекте вектора число и возвращаем на него итератор
auto res = std::ranges::find(foo(42), 1);
// хотим ошибку компиляции при разыменовании!
std::println("{}", *res);
```

Основная проблема - если мы передаем в алгоритмы ranges временное значение, то результирующий итератор будет невалидным, потому что будет принадлежать уже разрушенному объекту.

Но если мы передаем в алгоритмы lvalue, то есть объекты, у которых есть имя, то никакой проблемы нет. Итераторы в этом случае будут валидными.

И мы ведь умеем отличать lvalue от rvalue. borrowed_range нам так и говорит: если мы передали левую ссылку, то мы можем не беспокоиться за инвалидацию.

Но как мы видим, это не вся картина. Для некоторых типов, даже когда мы передаем в алгоритмы их временные значения, результирующий итератор не провисает. Для таких типов специализируют enable_borrowed_range.

*Практикум* Подумайте, для каких типов вы бы специализировали enable_borrowed_range в true?

*Студент*  Кажется, я знаю!

Для любых невладеющих отображений. Дело в том, что даже если такие объекты уничтожатся, их итераторы, которые ссылаются на оригинальные последовательности, не инвалидируются.

```cpp
auto res = std::ranges::find(std::string_view("Hello, World!"), 'W');
std::println("{}", *res); // успешно выведем 'W'.
```

Не смотря на то, что в примере выше мы передаем временный объект std::string_view, C-style строка "Hello, World!" будет живой все время жизни программы и к ее элементам безопасно обращаться даже после разрушения string_view на нее.

Вот список типов, для которых в стандарте специализирована переменная enable_borrowed_range в true:
- std::basic_string_view
- std::span
- std::ranges::subrange
- std::ranges::ref_view
- std::ranges::iota_view

Концепт borrowed_range помогает гибко определять типы, для которых может происходить инвалидация итераторов. Это можно использовать для детектирования опасных ситуаций во времени компиляции.


## std::ranges::to

В некоторых практических заданиях из прошлых уроков вам нужно было разделить исходный текст-строку на кусочки. Но эти кусочки были всего-навсего диапазонами символов. Чтобы превратить эти диапазоны символов в строки нужно было писать нечто подобное:

```cpp
std::views::transform(split_text, [](auto&& range) {
	// нужно сделать так, чтобы ограничитель был типом итератора начала
	auto v = std::views::common(range);
	return std::string(v.begin(), v.end());
});
```

Не то, чтобы это сложно, но хочется чего-то стандартного для такой популярной задачи. Встречайте, std::ranges::to.

Эта функция преобразует входной диапазон в тип ее шаблонного параметра. С ее помощью код выше превращается в это:

```cpp
std::views::transform(split_text, [](auto&& range) {
	return std::ranges::to<std::string>(range);
});
```

Передаем тип std::string в качестве шаблонного параметра функции std::ranges::to и диапазон символов. И она превращает этот диапазон в строку. Легко и удобно.

Также, если вам по каким-то причинам из отображения нужно получить готовый вектор, вы тоже можете использовать эту функцию:

```cpp
auto top_transactions =
transactions | std::views::filter(filter_transactions) |
std::views::transform(transform_transactions) |
std::views::take(3) | std::ranges::to<std::vector>();
```

В конце пайплайна обработки мы вставили std::ranges::to и теперь top_transactions - не просто отображение, а полноценный вектор отборных трансформированных транзакций.

В общем, std::ranges::to помогает легко получить из диапазона любой готовый контейнер.

## Заключение

Сегодня вы узнали:

- Если запустить алгоритм ranges на временном объекте, то вернется std::ranges::dangling.
- Если пропробовать разыменовать std::ranges::dangling, то получится ошибка компиляции. Это защищает использование алгоритмов от провисающих итераторов.
- концепт borrowed_range определяет типы, для которых можно не беспокоиться о невалидных итераторов. Это левые ссылки и простые view типа std::string_view и std::span.
- из диапазона можно получить готовый контейнер со всеми элементами с помощью std::ranges::to.