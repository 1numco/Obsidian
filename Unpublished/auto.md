Вывод типов
#новичкам

С++ - строго типизированный язык, что значит, что типы всех объектов должны быть известны на этапе компиляции. Это хорошо для безопасности программы и предсказуемости поведения, но не очень хорошо с точки зрения удобства написания программы. Не всегда мне хочется писать что-то типа "im::so::tired::of::typing::long\<types\>::iterator". Точнее никогда.

Да, есть алиасы и синонимы, это нужные и полезные вещи. Но не на все же гигадлинные типы их вводить. 

Очень хочется, чтобы работу по "написанию" типов делал кто-то за нас. Ведь в конце концов, все сигнатуры функций и методов известны, нормальные пацаны используют явные плюсовые касты, инициализаторы обычно представляют из себя понятные тривиальные типы. Да, есть всякие приколы с неявным приведением типов и неэксплисит конструкторами от одного аргумента. Но попробовать-то стоит?

Так и подумали создатели С++11 и решили ввести для решения этой проблемы ключевое слово auto. На самом деле они ничего не вводили, а вдохнули новую жизнь в уже существующее ключевое слово. У нас даже пост про это есть(ССЫЛКА).

Вещь - суперполезная и нужная. Сохраняет много пальчиковых усилий ленивым разработчикам. Например, у меня есть набор коллекций данных, каждая из которых связана с определенным идентификатором. Этот набор можно описать довольно просто:

```cpp
std::unordered_map<std::string, std::vector<Customer>> data;
```

Так вот, чтобы по этой мапе проитерироваться раньше нужно было писать вот так:

```cpp
for (std::unordered_map<std::string, std::vector<Customer> >::iterator it = data.begin(); it != data.end(); it++) {...}
```

Это конечно никуда не годится, выглядит ужасно, нечитаемо, да и код повторяется. Теперь подключаем 11-у плюсы и случается магия:

```cpp
for (auto it = data.begin(); it != data.end(); it++) {...}
```

А добавив заклинание под называнием range-based-for, получим:
```cpp
for (const auto& elem: data) {...}
```

Не идеально, это вам не питон. Но уже ощутимо приятнее и короче раза в 3.

Но тут встает вопрос: а как вообще эти типы-то выводятся? Есть наверное какие-то правила, алгоритм, по которому компилятор выводит тип?

Есть. Иначе это было бы магией(хотя грустновато без нее в нашем мире).

И этот алгоритм даже не такой tricky, как, например, выбор перегрузок функции! Его можно запомнить довольно легко. Поэтому в нескольких следующих постах мы будем разбирать эту тему.

А вообще знаете, что существует 3 вида вывода типов? Может и больше, но 3 точно есть, обещаю)
Обо всем этом будем говорить в ближайшее время.

Delegate your work. Stay cool.

#cpp11 



Опасности std::unordered_map
#опытным 

Когда писал прошлый пост, я хотел сразу вставить в пример range-based-for, чтобы показать одну приколюху. Но решил, что это заслуживает отдельного поста.

В копилку полезности auto.

Вдруг вы решили не пользоваться этой фичей и пишите вот так:

```cpp
struct Customer{
	Customer(int num) : data{num} {}
	Customer(const Customer& other) {
		data = other.data;
		std::cout << "Copy ctor" << std::endl;
	}
private:
	int data;
};
std::unordered_map<std::string, std::vector<Customer>> data;
data["qwe"] = {Customer{1}, Customer{2}};
for (const std::pair<std::string, std::vector<Customer>>& item : data) {
	std::cout << "Idle print" << std::endl;
}
```

Вроде бы все хорошо и выглядит, как надо. И ожидать мы в консоли будем такой вывод:

```
Copy ctor
Copy ctor
Idle print
```

При заполнении вектора кастомеры копируются из временных объектов, вызывается копирующий конструктор с принтом, и далее вывод цикла.

Однако на самом деле вывод будет такой:

```
Copy ctor
Copy ctor
Copy ctor
Copy ctor
Idle print
```

Мы этого совсем не ожидали. Откуда еще 2 копии?!!

Дело в том, что в нашей неупорядоченной мапе хранятся не std::pair<std::string, std::vector<Customer\>>, а std::pair<const std::string, std::vector<Customer\>>. Это в приницпе особенность std::unordered_map: ключ мапы - неизменяемый объект, поэтому обобщенно мапа хранит std::pair<const Key, Value>. 

И у компилятора не получается забиндить пару с константным ключом к паре с неконстантным. Но делать-то что-то надо. Поэтому он просто делает копию пары, лежащей в мапе, и переменная цикла item ссылается на этот временный объект. Дальше временный объект уничтожается после завершения своей итерации цикла и уходит в историю, как тот, кого не ждали, кто просто так пожрал ресурсы, ничего полезного не сделал и ушел. Осуждаю таких наглецов.

Ну и естественно, эта проблема просто решается использованием ключевого слова auto.

```cpp
struct Customer{
	Customer(int num) : data{num} {}
	Customer(const Customer& other) {
		data = other.data;
		std::cout << "Copy ctor" << std::endl;
	}
private:
	int data;
};
std::unordered_map<std::string, std::vector<Customer>> data;
data["qwe"] = {Customer{1}, Customer{2}};
for (const auto& item : data) {
	std::cout << "Idle print" << std::endl;
}

```

Теперь у нас есть ожидаемый вывод.

Make your life easier. Stay cool.

#cpp11 #STL



Template type deduction
#новичкам

Пользователи 98-го стандарта недоумевали, почему они обязаны при наличии инициализатора указывать полный тип переменной при ее определении. "Если я еще раз напишу полный тип итератора, то я устрою Роскомнадзор", "Вы что, хотите, чтобы я пальцы стёр?!" и тд. У многих были такие мысли. И это, вообще говоря, было очень странно, потому что компилятор уже на тот момент мог сам выводить тип на основе типа другого выражения! 

В шаблонах.

Вам же не обязательно писать в шаблонных функциях тип шаблонного аргумента. В некоторых случаях компилятор за вас это может сделать.

```cpp
template <class Container>
size_t my_size(const Container& container)
{
	return container.size();
}

std::cout << my_size(std::vector<int>(10, 0)) << std::endl;
```

Здесь выведется 10 и, как вы видите, для функции my_size мы не указывали явным образом шаблонный тип.

Ну и раз уже есть наработанная схема, к которой разработчики уже привыкли, то почему бы именно ее не использовать в качестве основы вывода типов для auto? Этим риторическим вопросом задались контрибьютеры в 11-й стандарт и теперь у нас действительно есть ключевое слово auto, для которого вывод типов практически ничем не отличается от вывода типов для шаблонных функций!

Поэтому надо понимать, что это за зверь такой, чтобы осознанно использовать auto.

Чтобы мы все понимали, о чем конкретно будем говорить, посмотрим на следующий псевдокод:

```cpp
template <class T>
void func(ParamType param) {...}

func(expression);
```

Все будем разбирать на примере подобной шаблонной функции. Так вот процесс вывода типов ParamType и Т на основании типа выражения expression - это и есть вывод шаблонных типов.

Небольшой пример:

```cpp
template <class T>
size_t my_size(const std::vector<T>& vec) {...}

template <class T>
void fun(const T& param) {...}

my_size(std::vector<int>(10, 0));
int i = 42;
fun(i)
```

В случае c my_size ParamType - const std::vector\<T\>&, а тип T - int. В случае с fun ParamType принимает вид типа Т, обвешанного побрякушками, типа const- и ссылочного квалификаторов. Здесь ParamType = const T&, а Т = int

То есть ParamType - все то, что стоит слева от имени шаблонного параметра, и на основе выведенного ParamType уже принимается решение о типе Т. Поэтому очень важно понимать не только, какой тип имеет expression, но и какой вид принимает ParamType. Есть всего 3 мажорных варианта:

1) ParamType - указатель или ссылка, но не [универсальная ссылка](https://t.me/grokaemcpp/121).
   
2) ParamType - универсальная ссылка.
   
3) ParamType - ни указатель, ни ссылка.

Все это в  следующих постах будем раскрывать подробнее.

Use deduction. Stay cool.

#cppcore #template


Небольшой пролог для вывода типов
#новичкам

Посты дальше будут прям хардкорные, но будет очень много примеров, так что готовьтесь жестко вовлекаться в контекст и препарировать каждый пример, чтобы прям понять, как это все работает. 

А сейчас я объясню некую концепцию, которая у меня сложилась в голове по ходу  изучения нюансов вывод типов. Когда-то мне она помогла выровнять и законнектить все знания по этой теме, потому что примеров в интернете мало, иногда вкинут пару фраз про определенный кейс и все. А ты сиди и голову ломай, как этот черный ящик работает. 

Статей с таким количеством примеров, как в следующих постах, исчезающе мало, поэтому контент уникальный. Надеюсь, вам понравится)

Коротко напомню контекст. ParamType - тип выражения-параметра функции. T - шаблонный тип функции :

```cpp
```cpp
template <class T>
void func(ParamType param) {...}

func(expression);
```

Введу такую концепцию, как **слои вложенности типов**. Слои есть не у всех типов, а только у тех, у кого есть вложенность)
Вложенность актуальна в основном для указателей и шаблонных типов. Объект вложен в его указатель. Тип вложен в шаблонный контейнер(например).
Слои могут быть у типа expression и у типа param. Так вот одна из задач вывода - правильно заматчить слои этих типов друг на друга. 

Представьте, что тип expression - это капуста и листы этой капусты - слои вложенности. Чтобы из типа expression грубо получить тип Т, нужно оторвать от капусты столько слоев, сколько есть в типе ParamType. И оставшаяся качерышка - и есть выведенный тип Т. Приведу примеры.

Простой одинокий шаблонный параметр.
```cpp
template <class T>
void func(T param) {...}
```
Здесь нулевая вложенность типа параметра(нет слоев). Какую бы кракозябру вы бы туда не засунули, тип Т будет отличаться от типа  expression разве что константностью и ссылочность. От капусты ни одного листа не отрываем и в выводе типа будут участвовать все слои expression. 

Засунем туда переменную типа RandomType без вложенности - в выводе T будет полностью участвовать этот тип и по итогу Т будет равно RandomType. 
Если засунем шаблонный тип std::set\<int\> с двумя слоями вложенности: внешним для std::set и внутренним для int, то в выводе будут участвовать оба слоя и Т будет иметь такой же тип std::set\<int\>. Снова ни одна капуста не пострадала.

Дальше ссылка
```cpp
template <class T>
void func(T& param) {...}
```
Казалось бы ссылка - это уже индирекция(под капотом лежит указатель). Однако с помощью ссылки вы только непосредственно объектом можете управлять! Поэтому в этом смысле никакой индирекции нет и тут также нулевая вложенность и рассуждения, как для предыдущего примера.


```cpp
template <class T>
void func(T * param) {...}

template <class T>
void func1(std::vector<T> param) {...}
```
Указатель или вектор - уже появляется вложенность: наружный тип(указатель или шаблонный вектор) и внутренний тип. Так и получается, что у нас есть внутренний и внешний слой. И за счет того, что мы определили внешний слой(сказали, что наш параметр - указатель/вектор), в выводе параметра участвует только внутренний слой типа expression и все что в него вложено. Передам в func указатель на инт - от этой капусты отрываем внешний листок и остается тип инт, в который и выводится Т. 
Если передам двойной указатель на инт int \*\*, то мы убираем внешний слой указателя и от типа expression остается уже одинарный указатель на int \*. И соответственно Т выведется в int \*.

В чем проблема и зачем это все вводить и объяснять - большинство примеров в интернете ограничиваются лишь интами и ссылками на инты. Я же хочу разобрать чуть более сложные кейсы, которые не укладываются в стандартные объяснения происходящего.

Типы шаблонных параметров приблизительно так и выводятся, как описано в этом посте. Однако есть нюансы с константностью и ссылочностью, которые придется разобрать в следующих постах.

Поддержите пост лайками, если хотите подробного разбора этой темы.

Support hardcore stuff. Stay cool.

#cppcore #template


Как посмотреть шаблонный тип
#новичкам 

Вчера Антон сделал важное замечание, что неплохо бы показать, как самому посмотреть, во что выводится тип Т в каждом конкретном случае. Собсна, погнали.

В С++ стандартными средствами конечно можно это сделать, но решение будет довольно громоздкое и некрасивое с точки зрения пользователя.

Хотелось бы что-то очень простое, желательно вообще однострочное. Обычно таких решений в плюсах нет и надо городить огород, но не в этом случае. Благодаря препроцессору компиляторы зачастую определяют свои макросы, которые раскрываются в сигнатуру функции. В случае же с шаблонной функцией, они показывают и правильный выведенный шаблонный тип.

Для шланга и гцц этот макрос называется \_\_PRETTY_FUNCTION\_\_, а для msvc - \_\_FUNCSIG\_\_. Пользоваться ими можно примерно так:

```cpp
#if defined __clang__ || __GNUC__
	#define FUNCTION_SIGNATURE __PRETTY_FUNCTION__
#elif defined __FUNCSIG__
	#define FUNCTION_SIGNATURE __FUNCSIG__
#endif

template<class T>
void func(const T& param) {
	std::cout << FUNCTION_SIGNATURE << std::endl;
}

func(std::vector<int>{});
```

Для кланга вывод будет такой:
```
void func(const T &) [T = std::vector<int>]
```

Для msvc:
```
void __cdecl func<class std::vector<int,class std::allocator<int> >>(const class std::vector<int,class std::allocator<int> > &)
```

Тут на мой взгляд msvc предоставляет несколько более полный и понятный функционал, но кому как удобно.

Можете поиграться в [годболте](https://godbolt.org/z/xzxreG71f).

See through things. Stay cool.

#compiler #template


std::source_location::function_name (https://en.cppreference.com/w/cpp/utility/source_location/function_name)




ParamType - не cv-квалифицированная ссылка
#новичкам

[Список постов по теме](https://t.me/grokaemcpp/352) [Пост про слои](https://t.me/grokaemcpp/358)

Пойдем по порядку мажорных вариантов. Первым в очереди случай, когда ParamType - не cv-квалифицированная(без пометок const и volatile), не универсальная ссылка. Дальше только про константность буду говорить в контексте cv-квалификаторов, а на volatile забью(впрочем, ему не привыкать). 

Первый вариант может быть такой:

```cpp
template <class T>
void func(T& param) {...}
//       |  |
//     ParamType

func(expression);
// decltype(expression) - expression's type
```

Тут порядок такой: берете полный тип expression -> откидывайте от него самую внешнюю ссылочность, если она есть -> все, что осталось, запихиваете в Т. Так как ParamType не имеет слоев вложенности, то мы ничего не отрываем от типа expression. Таким образом параметр Т никак не может быть ссылочным типом, а тип ParamType - всегда ссылка. Пример:

```cpp
template <class T>
void func(T& param) {...}

int x = 42; // x is an int
const int const_x = x; // const_x is a const int
const int& const_ref_x = x; // const_ref_x is a reference to x as a const int
std::list<double> lst;

func(x); // T is int, param's type is int&
func(const_x); // T is const int, param's type is const int&
func(const_ref_x); // T is const int, param's type is const int&
func(lst); // T is std::list<double>, param's type is std::list<double>&
```

Пойдем по порядку. С переменной `x` все сильно очевидно: тип param - int&, тип Т - int. Как и с `lst`: тип param - std::list<double\>&, тип Т - std::list<double\>
Теперь добавим щепотку константности. У `const_x` нет ссылочности, поэтому запихивает полный ее тип в Т, который выведется в const int.
Для const_ref_x сначала откидываем ссылочность и все оставшееся пихаем в Т, который выведется в const int.

Давайте очень важную особенность проследим. Каждый раз, когда мы объявляем константу или константную ссылку и передаем их в шаблон, ParamType которого T&, тип Т оказывается тоже константой. Это очень важный момент для обобщенного программирования: в функцию кто-то может передать константу. И он очень естественно ожидает, что значение его переменной не изменится. Ну может и не ожидает(в плюсах нужно настроиться ожидать что угодно), но очень хочет, чтобы оно не менялось. Иначе БУМ! И вот такой механизм сохранения константности шаблонного типа и позволяет шаблонным функциям, принимающим неконстантную ссылку вида Т&, спокойно принимать в себя константные объекты и не изменять их(так как сам тип неизменяемый).

А что если ParamType будет вложенным типом?
```cpp
template <class T>
void func(std::vector<T>& param) {...}
//       |               |
//           ParamType

std::vector<int> vec(10, 0);
const std::vector<int> const_vec(10, 0);
std::vector<int>& ref_vec = vec;
int a = 0;
int b = 1;
std::vector<std::reference_wrapper<int>> vec_of_ref{a, b};

func(vec); // T is int, param's type is std::vector<int>&
func(const_vec); // ERROR!
func(ref_vec); // T is int, param's type is std::vector<int>&
func(vec_of_ref); // T is std::reference_wrapper<int>, param's type is std::vector<std::reference_wrapper<int>>&
```

В этом случае мы явно сказали, что хотим принимать какой-то вектор. Мы просто отрываем этот слой вместе со ссылочностью и оставшееся - наш тип Т.

Но! Так как тип внешнего слоя полностью специфицирован, то у нас никак не получится передать в функцию константный вектор или ссылку на константный вектор. То есть тут сама сигнатура функции подразумевает изменяемый внешний слой, а мы пытаемся туда передать неизменяемый объект. Компилятор запрещает нам такие мувы делать.

Почему в одном случае можно передать константую ссылку, а в другом нет? Все из-за волшебного типа Т, который может быть кем угодно. Ссылка Т& может быть ссылкой на любой тип, в том числе и константный. Можете прям так и читать: ссылка на что-угодно. Этот Т как бы вбирает в себя все особенности типа.
А для такого выражения std::vector\<T>& мы читаем: ссылка на вектор от чего-угодно. Внешний слой зафиксирован, а внутренний может содержать в себе что-угодно.

Еще обращу внимание, что при передачи в функцию выражения `ref_x` выведенный тип шаблонного параметра не является ссылкой. Это следствие "отбрасывания" ссылочной части. 

Protect your invariants. Stay cool.

#cppcore #template



ParamType - не cv-квалифицированный указатель

Переходим к выводу параметров для указателей. Давайте просто накидаем много указателей разных типов и посмотрим, какой тип шаблонного параметра выведется для них.

```cpp
template <class T>
void func(T* param) {...}
//       |  |
//     ParamType

int x = 42;
int * p_x = &x; // p_x is a ptr to x as int
const int * p_const_x = &x; // p_const_x is a ptr to x as a const int
int * const const_p_x = &x; // const_p_x is a const ptr to x as int
const int * const const_p_const_x = &x; // const_p_const_x is a const ptr to x as const int
int ** p_p_x = &p_x; // p_p_x is a ptr to a ptr to x as int
const int * const * const_p_const_p_const_x = &const_p_const_x; // const_p_const_p_const_x is a const ptr to a const ptr to x as const int

func(p_x); // T is int, param's type is int*
func(p_const_x); // T is const int, param's type is const int*
func(const_p_x); // T is int, param's type is int *
func(const_p_const_x); // T is const int, param's type is const int *
func(p_p_x); // T is int *, param's type is int **.
func(const_p_const_p_const_x); // T is int *, param's type is const int * const *.
```

В комментах к строчкам все расписано, что и во что выводится. Я же обращу внимание на принцип. Снова возвращаемся к капусте. ParamType - указатель, а значит от типа выражения, переданного в функцию, мы должны этот указатель и оторвать и получим тип Т. Так и происходит во всех случаях. Если передаем константный указатель - снимаем этот уровень вместе с константностью.

Здесь все просто, работает также как и со ссылками. Почти. Семантика сохранения константности шаблонного типа повторяется. То есть если указатель указывает на константный инт, то тип Т тоже будет константным. Однако, если константной ссылки не может быть(то что в народе называют константной ссылкой - это на самом деле ссылка на константный объект: сама по себе ссылка неизменяема, она просто может указывать на другой объект), то указатель может быть константным. То есть здесь уже играют роль слои вложенности. И в этом случае, константность внутреннего слоя(который ближе к самому объекту) непосредственно отражается на шаблонном параметре Т, а константность внешнего слоя  к типу Т не будет иметь отношения. 

```cpp
template <class T>
void func(std::list<T> * param) {...}
//       |              |
//           ParamType

std::list<double> lst;
std::list<std::unique_ptr<const double>> lst_of_const;
std::list<std::vector<std::unique_ptr<const int>>> lst_vec_of_const;
std::list<std::vector<std::unique_ptr<const int>>> * const const_p_lst_vec_of_const = &lst_vec_of_const;
func(&lst); // T is double, param's type is std::list<double>*
func(&lst_of_const); // T is std::unique_ptr<const double>, param's type is std::list<std::unique_ptr<const double>>*
func(&lst_vec_of_const); // T is std::vector<std::unique_ptr<const int>>, param's type is std::list<std::vector<std::unique_ptr<const int>>>*
func(const_p_lst_vec_of_const); // T is std::vector<std::unique_ptr<const int>>, param's type is std::list<std::vector<std::unique_ptr<const int>>>*
```

В этом примере у типа param аж 2 слоя вложенности определены: 1 на указатель и 2 на контейнер. От типа аргумента в начале отрезаем указатель вместе с константностью, а далее и слой с std::list. По итогу тип Т выводится в то, что стоит в треугольных скобках у листа.

Есть одна интересная деталь: сигнатура функции подразумевает, что сам указатель не будет константным, то есть его можно изменять. И если вы передадите в нее константный указатель, то эта константность очень неожиданно пропадает и расплывается в пучине правил вывода типов. Так происходит с переменными `const_p_x`, `const_p_const_x`, `const_p_const_p_const_x` и `const_p_lst_vec_of_const` Если для нешаблонной функции с параметром неконстантного указателя при передаче в нее константного указателя будет ошибка компиляции, то здесь эта штука проходит фэйс-контроль. Помните об этой об этой особенности и потенциальной опасности.

Dig deeper. Stay cool.

#template #cppcore



ParamType - cv-квалифицированный параметр
#новичкам

Рассмотрим вариант, когда ParamType - cv-квалифицированная ссылка. Тогда для вывода типа  **верхний уровень константности аргумента остается только в типе параметра функции**, а **шаблонный тип выводится без этой константности на верхнем уровне**(ПОДСЧЕРКНУТЬ). Любую ссылочность типа аргумента функции мы игнорируем.

```cpp
template <class T>  
void func(const T& param) {...}
//       |        |
//        ParamType

int x = 42; // x is an int
const int const_x = x; // const_x is a const int
const int& const_ref_x = x; // ref_x is a reference to x as a const int
std::list<double> lst;

func(x); // T is int, param's type is const int&
func(const_x); // T is int, param's type is const int&
func(const_ref_x); // T is int, param's type is const int&
func(lst)
___________________________
template <class T>
void func1(const std::shared_ptr<T>& param) {...}
//        |                         |
//               ParamType

std::list<double> lst;
std::list<const double> lst_of_const;
const std::list<const double>& const_ref_lst_of_const;
func1(lst); // T is double, param's type is std::list<double>&
func1(lst_of_const); // T is const double, param's type is std::list<const double>&
func1(const_ref_lst_of_const); // T is const double, param's type is const std::list<const double>&

```

В случае func тип param всегда будет константной ссылкой, вопрос только на что. И это что-то и будет искомым шаблонным типом. И получается он путем отбрасывания константности и ссылочности от типа аргумента функции. Для const_x откидываем константность, для const_ref_x - и константность и ссылочность. Для x и lst типы выводятся без изменений.

Когда у нас в типе param появляется вложенность, то продолжаем обращаться к аналогии с капустой. Просто снимаем весь первый слой со всеми константностями и ссылочностями и оставшееся будет типом Т. На примерах все подписано.

ParamType - cv-квалифицированный указатель.

Когда в статьях и книжках расписывают этот вариант, то очень часто отсылаются к такой форме параметра функции const T * param. И говорят, что в этом случае вывод типа шаблонного параметра мало отличается от случая cv-квалифицированных ссылок. И это действительно правда. С одним уточнением, что это указатель на константу, а не константный указатель.

В случае, когда указатель указывает на константный объект - ситуация действительно похожая на ссылки.  Отрываем один слой указательности от типа аргумента функции и от того, что осталось убираем константность - получится искомый тип Т.

```cpp
template <class T>
void func(const T * param) {...}
//        |        |
//         ParamType

int x = 42;
int * p_x = &x; // p_x is a ptr to x as int
int ** p_p_x = &p_x; // p_p_x is a ptr to a ptr to x as int
const int * p_const_x = &x; // p_const_x is a ptr to x as a const int
int * const const_p_x = &x; // const_p_x is a const ptr to x as int
const int * const const_p_const_x = &x; // const_p_const_x is a const ptr to x as const int

func(p_x); // T is int, param's type is const int*
func(p_const_x); // T is int, param's type is const int*
func(const_p_x); // T is int, param's type is const int*
func(const_p_const_x); // T is const int, param's type is const int *
func(p_p_x); // T is int *, param's type is int * const *
```

Все работает также, только добавляется прикол: если в функцию с такой сигнатурой передать константный указатель, то это не будет учитываться и param будет неконстантным указателем. Здесь как бы создается новый указатель, являющийся копией старого. Он не обязан сам быть константным, так как оригинальный указатель остается неизменным.

Теперь рассмотрим настоящие константные указатели.

```cpp
template <class T>
void func(T * const param) {...}

int x = 42;
int * p_x = &x; // p_x is a ptr to x as int
int ** p_p_x = &p_x; // p_p_x is a ptr to a ptr to x as int
const int * p_const_x = &x; // p_const_x is a ptr to x as a const int
int * const const_p_x = &x; // const_p_x is a const ptr to x as int
const int * const const_p_const_x = &x; // const_p_const_x is a const ptr to x as const int

func(p_x); // T is int, param's type is int * const
func(p_const_x); // T is const int, param's type is const int * const
func(const_p_x); // T is int, param's type is const int * const
func(const_p_const_x); // T is const int, param's type is const int * const
func(p_p_x); // T is int *, param's type is int * * const
```

Здесь все еще проще. param - всегда константный указатель, что бы вы в функцию не передали. А для вывода Т просто снимаем внешний слой указательности со всем квалификаторами и вуаля - ваш тип Т готов.

Самый душный блок из вывода типов готов, дальше будет по-веселее.

Believe in good future. Stay cool.

#cppcore #template


ParamType - универсальная ссылка
#опытным 

Один и самых интересных, сложных, непонятных и противоречивых кейсов в выводе шаблонных параметров. Да и интересный он скорее из-за всего остального. 

Только при такой сигнатуре шаблонной функции можно считать ее параметр универсальной ссылкой:

```cpp
template <class T>
void func(T&& param) {...}

func(expression);
```

То есть это rvalue reference на cv-неквалифицированный тип. Только в таком виде тип param называется универсальной ссылкой. Как говорят в школе: 
И ни в каком другом виде!

Ни
```cpp
template <class T>
void func(std::vector<T>&& param) {...}
```
Это просто rvalue reference.
Ни
```cpp
template <class T>
void func(const T&& param) {...}
```
Это тоже просто rvalue reference! Только константный.
И к последним двум кейсам применяются правила отсюда и отсюда(ссылки на посты).

Когда expression - rvalue reference, то при выводе Т отбрасывается вся ссылочность, чтобы тип ParamType был rvalue reference of T. Если тип expression - lvalue, то Т выводится в тип lvalue reference. Самое интересное, что это единственный кейс, когда тип Т выводится в ссылку. 

Есть такое правило, что & + && = &. То есть при использовании универсальной ссылке в параметре шаблонной функции при передаче туда lvalue|lvalue reference, этот параметр выводится в lvalue reference. Это происходит именно за счет того, что шаблонный тип выводится в тип lvalue reference. Условно: функция принимает Т &&, T выводится в int&, подставляем Т в параметр функции и получаем int& &&. Но такого синтаксиса нет и 2 ссылки коллапсируют в одну левую ссылку int&.


```cpp
template<typename T> void f(T&& param); // param is a universal reference

int x = 27;
const int cx = x;
const int& lrx = x;
int&& rrx = 42;

f(x); // x is lvalue, so T is int&, param's type is also int&
f(cx); // cx is lvalue, so T is const int&, param's type is also const int&
f(lrx); // lrx is lvalue, so T is const int&, param's type is also const int&
f(27); // 27 is prvalue, so T is int, param's type is therefore int&&
f(rrx); // rrx is xvalue, so T is int, param's type is therefore int&&
```

Обратите внимание на первые 3 кейса. Там Т выводится в lvalue reference тип. В двух последних Т - просто int безо всяких ссылок.

Мы на самом деле уже обсуждали универсальные ссылки в рамках серии статей про категории выражения. Вот ссылочка на эту статью https://t.me/grokaemcpp/319 с более полным описанием процессов.

В этой статье я просто хотел подсветить самые важные моменты в этой теме, которые касаются именно вывода типов.

Stay universal. Stay cool.
#cppcore #cpp11 #template

Квизы

Сейчас и завтра пойдет пачка опросов по теме вывода шаблонных типов, чтобы вы могли проявить свои знания и проверить их на практике. Идею предложил Антон в своем [комменте](https://t.me/grokaemcpp/367?comment=19900). Много постов опросников - это конечно не онлайн тренажер, но зато просто и легко в реализации. И каждый сможет попробовать.

Не будет драконьих конструкций, только все то, что мы уже знаем и разбирали на канале.

Не буду использовать телеграммные квизы с ответами, мне кажется это менее интерактивным форматом. Через пару часиков скину скопом объяснения по каждому случаю

У меня к вам всего один вопрос.

Во что выведется тип Т?



```cpp
template <class T>
void func(const std::deque<T>& param) {}

func(std::deque<const int>{});
```

const int

const int&

int 

std::deque\<const int>

ошибка компиляции



```cpp
template <class T>
void func(const std::shared_ptr<T> & ptr) {}

std::shared_ptr<const int> ptr{};
const std::shared_ptr<const int>& ref_ptr = ptr;
func(ref_ptr);
```

int

std::shared_ptr\<const int>

const int

ошибка компиляции



```cpp
template <class T>
struct Class {
	static void func(T && param) {}
};

int a = 0;
Class<int>::func(a);
```

int

int&

int&&

ошибка компиляции


```cpp
template <class T>
void func(T * ptr) {}

int a = 0;
int const * const ptr = &a;
func(ptr);
```

int const * const

int

const int

int const *

ошибка компиляции



Объяснение

Кратко пройдемся по каждому кейсу и разберемся, что к чему.

```cpp
template <class T>
void func(const std::deque<T>& param) {}

func(std::deque<const int>{});
```

Здесь казалось бы по всем правилам и канонам тип Т должен выводится в const int. Но мы с вами уже знаем, что [стандартные контейнеры не могут быть инстанцированы с константными типами](https://t.me/grokaemcpp/344), поэтому здесь будет ошибка компиляции.

```cpp
template <class T>
void func(const std::shared_ptr<T> & ptr) {}

std::shared_ptr<const int> ptr{};
const std::shared_ptr<const int>& ref_ptr = ptr;
func(ref_ptr);
```

В этом случае правильным ответом будет Т - const int. Убираем от типа ref_ptr константность и ссылочность, снимаем слой std::shared_ptr и остается const int. Довольно просто.

```cpp
template <class T>
struct Class {
	static void func(T&& param) {}
};

int a = 0;
Class<int>::func(a);
```

Все выглядит так, что param - универсальная ссылка. Однако, это не так. Универсальная ссылка имеет вид Т&&, но с оговоркой, что Т - шаблонный параметр функции/метода, а не класса. В этом случае func принимает просто rvalue reference, а мы передаем туда lvalue. Компилятор не сможет забиндить rvalue reference на lvalue и произойдет ошибка компиляции.

```cpp
template <class T>
void func(T * ptr) {}

int a = 0;
int const * const ptr = &a;
func(ptr);
```

Для начала, пусть вас не беспокоит, что const стоит после int, но перед символом указателя. Так можно делать, это просто альтернативная нотация для объявления константных типов.

То что изначальная переменная `а` имеет тип int нас не должно волновать, мы смотрим только на ptr. 

Указатель здесь копируется по значению, поэтому внешняя константность типа ptr отбрасывается при выводе типа. Снимает слой константности и получает int const.





```cpp
template <class T>
void func(std::vector<T> && param) {}

std::vector<int> vec;
func(vec);
```

int

std::vector\<int>

std::vector\<int>&

ошибка компиляции


```cpp
template <class T>
void vector(const T & param) {}

vector({1, 2, 3});
```

std::vector\<int>

int

std::initializer_list\<int>

ошибка компиляции




```cpp
template <class T>
void func(std::shared_ptr<const T> & ptr) {}

func(std::shared_ptr<const int>{});
```

int

std::shared_ptr\<int>

const int

ошибка компиляции



```cpp
template <class T>
void func(T&& param) {}

const std::vector<int> vec;
func(vec);
```

int
int&
std::vector\<int>
const std::vector\<int>
const std::vector\<int>&
ошибка компиляции



Объяснение

Пойдем по порядку

```cpp
template <class T>
void func(std::vector<T> && param) {}

std::vector<int> vec;
func(vec);
```

Снова проверка на универсальную ссылку. Только в формате Т&& параметр шаблонной функции может называться универсальной ссылкой. Здесь такого нет. 

Мы передает обычный lvalue в функцию, оно не сможет кастануться к rvalue reference, поэтому будет ошибка компиляции.

```cpp
template <class T>
void vector(const T & param) {}

vector({1, 2, 3});
```

Интересный случай. Потому что мы все знаем приколы с конструкторами вектора, и их стремлению интерпретировать набор объектов внутри фигурных скобок как std::initializer_list. Да и по правилам вывода типов auto, {1, 2, 3} тоже выведется в std::initializer_list. Но вывод в шаблонах - это другое. Компилятор не может правильно интерпретировать, что за сущность мы пытаемся засунуть в функцию, поэтому откажется это компилировать.

```cpp
template <class T>
void func(std::shared_ptr<const T> & ptr) {}

func(std::shared_ptr<const int>{});
```

Вроде как должно быть int, но если внимательно присмотреться к сигнатуре функции, то можно рассмотреть, что она принимает неконстантную ссылку. А временный объект, который мы в нее передаем, не сможет привестить к неконстантной ссылке. Поэтому будет ошибка компиляции.

```cpp
template <class T>
void func(T&& param) {}

const std::vector<int> vec;
func(vec);
```

Нет, здесь не будет ошибки компиляции. Слишком много уловок - нехорошо. Тут просто хороший кейс на проверку полноты усвоенного материала. Здесь param - универсальная ссылка. Передаем мы в функцию lvalue, а это значит, что тип Т точно будет ссылкой. Вопрос на что. Здесь никакой вложенности нет, поэтому ничего от типа vec не убираем, а только добавляем сслочность. Ответ - const std::vector\<int>&.



const rvalue reference
#опытным 

В прошлом посте мельком упомянул эту конструкцию, а в этом решил раскрыть по-подробнее.

Правые ссылки были введены в С++11 и с тех пор помогают в реализации семантики перемещения. С помощью таких ссылок мы можем убрать ненужное глубокое копирование объектов и внедрить "перемещение" одного объекта в другой. Достигается это с помощью специальных методов: конструктора перемещения и перемещающего оператора присваивания. Выглядит это так:

```cpp
struct Movable {
	Movable(int i) : num{new int(i)} {}
	Movable(Movable&& other) {
		num = other.num;
		other.num = nullptr;
		std::cout << "Don't have to copy in ctor\n";
	}
	Movable& operator=(Movable&& other) {
		if (this != &other) {
			delete num;
			num = other.num;
			other.num = nullptr;
			std::cout << "Don't have to copy in assignment\n";
		}
		return *this;
	}
	~Movable() { delete num;}
	int * num = nullptr;
}

Movable obj1{5};
Movable obj2{7};
Movable&& rvalue_ref = std::move(obj1);
Movable obj3{std::move(rvalue_ref)};
obj2 = std::move(obj3);

// OUTPUT
// Don't have to copy in ctor
// Don't have to copy in assignment
```

Эти два специальных метода всегда имеют такую сигнатуру. Даже если их генерирует за нас компилятор.

То есть по идее, правые ссылки нужны, чтобы перенести из значение текущего объекта в новый объект. И для этого первоначальный объект нужно изменить.

Так за каким хреном нам тогда нужны константный правые ссылки? Чтобы что? С первого взгляда это выглядит так: мы принимаем правые все правые ссылки в перегрузку(неконстантные ссылки биндятся к константным), но все равно копируем объект, потому что ничего другого сделать не можем. Звучит, как бред.

Но все же есть применение у этой конструкции. 

Дело в том, что T&& могут кастится к const T&, T&& и const T&&. Наиболее подходящей перегрузкой будет T&&, дальше const T&& и, наконец, const T&. А вот левые ссылки к правым вообще не могут преобразовываться. 

Соотвественно, если мы хотим принимать только lvalue в функцию и никак не пропускать правые ссылки, то "Хьюстон, у нас проблема!". Если мы просто определим перегрузку для const T&, то rvalue reference все равно смогут попадать в эту перегрузку. Что нас сильно огорчает. 

Однако мы можем совершить ход конем: пометить перегрузку const T&& удаленной. Так как удаленные функции все еще участвуют в разрешении перегрузок, то для T&& более подходящим выбором будет const T&&, нежели const T&. Но мы намеренно удаляем эту перегрузку и тогда компилятор выдает ошибку из-за того, что не может найти подходящий вариант функции.

```cpp
struct T{};

void f(T&) { std::cout << "lvalue ref\n"; }
void f(const T&) { std::cout << "const lvalue ref\n"; }
void f(const T&&) = delete; //{ std::cout << "const rvalue ref\n"; }

const T g() {
 return T{};
}

int main() {
    f(g()); // error: use of deleted function 'void f(const T&&)'
    f(T{}); // error: use of deleted function 'void f(const T&&)'
}
```

Это применение и еще парочку других мы рассмотрим на реальных примерах в следующий раз.

Remove obstructing things from your life. Stay cool.

#cppcore #cpp11 


Примеры использования const T&&
#опытным

В прошлый раз мы поговорили о том, что можно использовать константную правую ссылку для того, чтобы запретить принимать любые rvalue reference в функцию. 

Для чего это может быть нужно?

Допустим, мы храним в поле класса в каком-то виде ссылку на объект. И нам бы очень не хотелось принимать в конструкторе правые ссылки, потому что возможно сразу же после выхода из конструктора для объектов вызовется деструктор и хана этим объектам. И встречаем UB из-за хранения битой ссылки. 

Есть такой стандартный класс std::reference_wrapper и его функции помощники std::ref() и std::cref(). Поскольку std::reference_wrapper предполагает хранение ссылки только для lvalue, то стандарт удалил перегрузки std::ref() и std::cref(), которые принимают const T&&.

```cpp
template <class T> void ref(const T&&) = delete;
template <class T> void cref(const T&&) = delete;
```

По той же самой причине такая перегрузка удалена у функции std::as_const, которая формирует левую ссылку на константный тип из аргумента.

```cpp
template< class T >  
constexpr std::add_const_t<T>& as_const( T& t ) noexcept;
```

Также константные правые ссылки используются в более сложных штуках, типа std::optional, когда нужно вернуть из него значение.

```cpp
constexpr const T&& operator*() const&&;
constexpr const T&& value() const &&;
```

С этой же целью оно используется, например, и в std::get.

```cpp
template< std::size_t I, class... Types >  
constexpr const std::variant_alternative_t<I, std::variant<Types...>>&&  
    get( const std::variant<Types...>&& v );

template< class T, class... Types >  
constexpr const T&& get( const std::variant<Types...>&& v );
```

В таких случаях использование const T&& оправдано передачей информации и о ссылочности типа, и о его константности. Это важно в обобщенном программировании, потому что никто не знает с каким типом будет работать шаблонная сущность. Вы вполне можете получить константный временный объект std::optional(да и любого другого объекта), это синтаксически корректно. И чтобы геттер его внутреннего значение отражал свойства обертки, приходится перегружать эти геттеры для любых возможных параметров. Так вот например методы std::optional упомянутые выше вызовутся только для временных константных объектов. И эти свойства отображаются в возвращаемом значении.

Также не стоит забывать, что константность объекта не накладывает ультимативных ограничений на использование объекта. Есть мутабельные и статические поля, которые можно изменять, и плевать они хотели на вашу константность. А также указатели. Мы не можем менять сам указатель, но можем изменить объект, на который он указывает. Это немного расширяет спектр возможностей использования константных правых ссылок, но не прям существенно. Единственный жизненный пример, где это может органично использоваться - [pimpl idiom](https://t.me/grokaemcpp/107). Согласно этой идиоме класс хранит указатель на реализацию, в которой может лежать все, что угодно. Все операции, которые как-то изменяют состояние объекта, влияют на данные внутри указателя. Поэтому снаружи кажется, что объект и не изменился. Да и старый объект можно будет использовать. Непонятно только, зачем менять привычные традиции использования правых ссылок, но все же.

```cpp
// MyClass.hpp
class MyClass {
public:
	MyClass();
	MyClass(int g_meat);
	MyClass(const MyClass &&other); // const rvalue reference!
	~MyClass();
	int GetMeat() const;
private:
	class Pimpl;
	Pimpl *impl {};
};

// MyClass.cpp
class MyClass::Pimpl {
public:
	int meat {42};
};

MyClass::MyClass() : impl {new Pimpl} { }

MyClass::MyClass(int g_meat) : MyClass() {
	impl->meat = g_meat;
}

MyClass::MyClass(const MyClass &&other) : MyClass()
{
	impl->meat = other.impl->meat;
	other.impl->meat = 0;
}

MyClass::~MyClass() { delete impl; }

int MyClass::GetMeat() const {
	return impl->meat;
}

// main.cpp
int main() {
	const MyClass a {100500};
	MyClass b (std::move(a)); // moving from const!
	std::cout << a.GetMeat() << "\n"; // returns 0, b/c a is moved-from
	std::cout << b.GetMeat() << "\n"; // returns 100500
}
```

В общем, непонятно, зачем это нужно, однако выше приведен абсолютно валидный С++ код с перемещающим конструктором от константной правой ссылки. Еще и объект после перемещения можем использовать.

Stay useful even if nobody understands you. Stay cool.

#template #cpp11 #STL


ParamType - не ссылка и не указатель
#опытным 

```cpp
template <class T>
void func(T param) {...}

func(expression);
```

В при такой форме параметра шаблонной функции, который в данном случае не является ни ссылкой, ни указателем, мы имеем дело с передачей аргумента по значению. Все как с нешаблонными функциями.

Это значит, что param - совершенно новый объект типа Т, который создается из аргумента, переданного функции. После создания он живет своей жизнь и никак не зависит от исходного объекта. 

Есть кстати распространенное заблуждение или недоговаривание, что при передаче объекта в функцию по значению происходит копирование. Это не совсем правда. Вызывается конструктор объекта на основе переданного параметра. А вот какой именно конструктор вызовется - copy или move - определяется типом ссылочности аргумента. Передадут lvalue - вызовется copy ctor, передадут rvalue reference - вызовется move ctor. Короткий пример:

```cpp
struct Test {
	Test() = default;
	Test(const Test& other) {
		std::cout << "Copy ctor" << std::endl;
	}
	Test(Test&& other) {
		std::cout << "Move ctor" << std::endl;
	}
};

template<class T>
void fun(T t) {
	std::cout << "Hello, subscribers!!!" << std::endl;
}

int main () {
Test t;
fun(t);
fun(std::move(t))
}
```

```
Copy ctor
Hello, subscribers!!!
Move ctor
Hello, subscribers!!!
```

Как видим, при передаче аргумента через std::move происходит вызов мув конструктора. 

Кстати, недавно дошел до очень простого объяснения мув-семантики и всего, что вокруг нее вертиться. Буквально за один пост все поймут всё про нее. Если хотите такой пост - жмакайте кита)

Вернемся к шаблонам.

Как в этой ситуации выводится шаблонный тип?

Если у типа expression есть верхняя ссылочность/константность/волатильность - все в мусорку, оставшееся - тип Т.

```cpp
int x = 42;
const int cx = x;
const int& rx = x;
const int * const px = &x;

func(x); // T's and param's types are both int
func(cx); // T's and param's types are again both int
func(rx); // T's and param's types are still both int
func(px); // T's and param's types are const int*
```

Обратите внимание: хотя cx и rx представляют константные значения, param не является константой. В этом есть смысл. param — это объект, полностью независимый от cx и rx, копия cx или rx. Тот факт, что cx и rx не могут быть изменены, ничего не говорит о том, можно ли изменять param. Вот почему константность expr игнорируется при определении типа параметра: то, что expr не может быть изменено, не означает, что его копия не может быть изменена.

С указателем похожая история: он как бы копируется в функцию. В функции уже другой указатель - param - и он не обязан быть сам по себе константным. И согласно правилам вывода типов, таковым и не является.

Если шаблонный параметр немного сложнее - например, тип Т вложен в другой шаблонный тип, то возвращаемся к нашей капусте. Снимаем столько слоев с типа expression, сколько явно определено для типа param - и это будет тип Т. Аргумент передается также по значению.

```cpp
template <class T>
void func(std::vector<T> param) {...}

std::vector<int> vec;
const std::vector<const int> const_vec_to_const;
std::vector<std::vector<const int>> vec_to_vec_to_const;

func(vec); // T is int, param's type is std::vector<int>
func(const_vec_to_const); // T is const int, param's type is std::vector<const int>
func(vec_to_vec_to_const); // T is std::vector<const int>, param's type is std::vector<std::vector<const int>>
```

На этом мы заканчиваем рассматривать мажорные кейсы видов шаблонных параметров функций. Дальше будем какие-то менее встречающиеся примеры рассматривать.

Be independent subject. Stay cool.

#cppcore #template 


Move-семантика
#новичкам

ОБНОВИТЬ ГАЙД

Ох. Для начинающих вкатунов в плюсы эта тема может сниться в страшных снах. И так-то в плюсах непросто, так еще и какая-то семантика появляется, которая позволяет ускорить программы, но зачастую непонятно, что для этого нужно делать. Да и не только для вкатунов. Был тут один отец предвадителя дисептиконов, который говорил, что мув-семантика тормозит программы(локальный мем из нашего чата). Поэтому пораразбирацца в этом непростом вопросе.

Все, что с собой базово ввела мув-семантика:
1 Новый ссылочный тип - rvalue reference. Обозначается как &&.
2 2 новых специальных метода: конструктор перемещения и перемещающий оператор присваивания, которые принимают этот новый тип.
3 Функция каста к rvalue_reference - std::move.

Есть еще [универсальные ссылки](https://t.me/grokaemcpp/121), но это относится к шаблонам. Вся мув-семантика работает и без них.

Так вот . Нужно понять соотвественно 3 вещи: 
1 Когда объект имеет этот ссылочный тип. Когда он временный. То есть это либо инициализатор, либо объект, вернувшийся из функции и еще ничему не присвоенный.

2 Так называемую операцию "перемещения" выполняют только эти методы, больше ни что. Строго говоря, они могут выполнять что-угодно, но операции перемещения ресурсов происходят только в них.

3 std::move делает только статик каст в rvalue reference типу. Теперь любой объект можно обернуть в эту функцию и, даже если он не временный, его тип станет rvalue reference.

ВСЕ

Теперь следите за руками. Простая цепочка: 

1 Есть объект, ресурсы которого ему больше не нужны, и вы хотите эти ресурсы передать другому объекту. Очевидные кандидаты в такие объекты - временные объекты, но с помощью std::move это могут быть любые объекты.

2 Вы либо создаете объект на основе этого временного, либо присваиваете временный объект существующему. В этих случаях вызываются конструктор от другого объекта или оператор присваивания. И в зависимости от ссылочного типа аргумента выбирается либо перемещающий метод(если тип аргумента &&), либо копирующий метод(lvalue). То есть эти методы просто перегружены для разных ссылочных типов аргументов. И компилятор в компайл тайме выбирает нужную перегрузку - либо перемещающую, либо копирующую.

3 Перемещение ресурсов объекта происходит в перемещающих методах. Исходный объект остается без ресурсов, но в консистентном состояния, чтобы он нормально дожил до своей старости и смерти.

По итогу получаем новый или обновленный объект, который в себе содержит ресурсы объекта-донора, а объект донор оставляем доживать свои дни. 

По сути, это практически все, что вам нужно знать, чтобы понимать мув-семантику. Теперь небольшой пример:

```cpp
struct Test {
	Test() = default;
	Test(const Test& other) {
		std::cout << "Copy ctor" << std::endl;
	}
	Test& operator=(const Test& other) {
		std::cout << "Copy assign" << std::endl;
		return *this;
	}
	Test(Test&& other) {
		std::cout << "Move ctor" << std::endl;
	}
	Test& operator=(Test&& other) {
		std::cout << "Move assign" << std::endl;
		return *this;
	}
};

Test test1;
Test test2 = std::move(test1);
Test test3 = test2;
test1 = test2;
test3 = std::move(test1);

// OUTPUT:
// Move ctor
// Copy ctor
// Copy assign
// Move assign
```

Все очень просто. Если мы кастим к rvalue reference через std::move, то вызывается нужный перемещающий метод.

Чуть сложнее понимание rvalue ссылок, но тоже не рокет сайенс. Тут нужно понять пару особенностей
1 Само появление правой ссылки ничего никуда не перемещает. 
```cpp
Test&& test4 = std::move(test2);
// OUTPUT:
// <empty output>
```
2 Хоть сама правая ссылка х имеет тип rvalue reference, при использовании в выражении х она превращается в lvalue reference. Любое действие с x происходит в рамках какого-то выражения и, например, передача х в функцию происходит в рамках выражения (х), которое имеет тип lvalue reference.

```cpp
std::cout << std::is_lvalue_reference<decltype((test4))>::value << std::endl; // внимание на скобки вокруг test4. Здесь мы узнаем тип ВЫРАЖЕНИЯ, а не переменной
std::cout << std::is_rvalue_reference<decltype((test4))>::value << std::endl;
// OUTPUT:
// 1
// 0
```

Это сделано для того, чтобы разрешить копирование от правых ссылок, так как они могут биндиться к const lvalue reference.

```cpp
Test test5 = test4;
// OUTPUT:
// Copy ctor
```

3 Для того, чтобы снова разрешить перемещать данные из rvalue ссылки, нужно еще раз ее мувнуть.

```cpp
void fun(Test&& test) {
	Test test6 = test;
	Test test7 = std::move(test);
}

fun(std::move(test4));

// OUTPUT:
// Copy ctor
// Move ctor
```

Обратите внимание, что std::move(test4) никак не отразился на выводе. А внутри функции мы 2 раза создаем объекты на основе rvalue reference. Только при использовании std::move вызывается перемещающий конструктор, а без него - копирующий.

Можно это так запомнить: в любом случае для вызова перегрузки с rvalue reference параметров вам нужно передать в функцию объект, не имеющий имени. Либо инициализатор, либо возвращенный из функции. Все-таки std::move и std::forward - тоже функции и только с помощью них можно передать именованную сущность дальше, как правую ссылку.

Ну и последний момент. Не используйте std::move при возврате из функции. Есть такая штука, как [Return Value Optimization](https://t.me/grokaemcpp/136), которая позволяет избавится от лишних копирований и перемещений. std::move херит эту оптимизацию, поэтому просто возвращайте из функции объекты по значению. Более подробно в посте по ссылке. 

Ну теперь точно все. Да, может есть еще нюансы, но здесь достаточно информации для понимания 95% всего происходящего с перемещениями.

Здесь я очень поверхностно каcался категорий выражений, хотя они очень тесно связаны с мув-семантикой. У нас как раз есть совмещенный гайд по этим темам, который я обновил информацией из этого поста. Вот [ссылочка](https://t.me/grokaemcpp/168).

Understand the basics. Stay cool.

#cpp11 #cppcore #compiler 


Правила приведения ссылочных типов
#новичкам 

Это тоже один из столпов мув-семантики, который хоть и неявляется ключевым в ее понимании, но часто является камнем предкновения для полного понимания процессов, происходящих с кодом.

У нас есть 3 вида типов данных, которые нас сейчас интересуют: T, T& и T&&. Первый тип отображает обычный объект аля lvalue. Т& - lvalue reference на Т, Т&& - rvalue reference. Есть еще и их константные вариации, которые играют очень важную роль. Здесь я немного буду смешивать понятие категории выражения и типа. Пусть lvalue будет обозначать нессылочный тип именованного объекта.

При вызове функции или при создании новой переменной может происходить приведение сущностей одного типа к другому типу. Какие-то из них легальны, а какие-то запрещены. Давайте посмотрим поближе.

Если результирующий тип - lvalue reference, то приводиться к нему могут только неконстантные именованные сущности. Это только lvalue и lvalue reference. Очевидно, что неконстантный lvalue reference позволит изменять объект, чего нельзя делать с константными сущностями.

```cpp
int i = 0;
const int ci = 1;
int & ref = i; // legal, lvalue to lvalue reference
int & ref2 = ref; // legal, lvalue reference to lvalue reference
int & ref3 = 0; // ERROR, trying to bind lvalue reference to rvalue reference
int & ref4 = ci; // ERROR, trying to bind lvalue reference to const lvalue

void func(int&);
func(i); // legal;
func(ref); // legal
func(0); // ERROR
func(ci); // ERROR
```

Если результирующий тип - rvalue reference, то приводиться к нему могут только неконстантные временные сущности. Это только rvalue reference.

```cpp
int give_me_an_int();

int i = 0;
int && ref = i; // ERROR, trying to bind rvalue reference to lvalue
int & ref2 = i;
int && ref3 = ref2; // ERROR, trying to bind rvalue reference to lvalue reference
int && ref4 = 0; // legal
int && ref5 = give_me_an_int(); //legal

const int && ref6 = give_me_an_int();
std::move(ref6); // ERROR, trying to cast const rvalue reference to rvalue reference


void func(int&&);
func(i); // ERROR
func(ref2); // ERROR
func(0); // legal
func(give_me_an_int()); // legal

```

Пока все логично. lvalue к lvalue, правые ссылки к правым ссылкам. Их нельзя смешивать.

Однако все меняется на const T&. Дело в том, что к константным левым ссылкам может приводиться вообще любой тип: и lvalue, и const lvalue, и константные и неконстантные правые и левые ссылки. И это самая важная часть поста.

Для начала, понятно, почему неконстантные типы могут кастится к константным ссылочным. Невозможность изменить объект по ссылке - полезная фича, которая позволяет контролировать состояние объекта, переданного в функцию.

Но как временные объекты могут приводится к const lvalue reference? Это языковая фича. Стандарт говорит, что мы можем присвоить временный объект константной левой ссылке и тогда время жизни этого временного объекта будет завязано на время жизни ссылки. 

```cpp
int give_me_an_int();

int i = 0;
const int ci = 1;
const int & ref = i; // legal
int & ref1 = i;
const int & ref2 = ref1; //legal
const int & ref3 = ci; // legal
const int & ref4 = 1; // still legal
const int & ref5 = give_me_an_int; // still legal
const int & ref6 = std::move(i); // still legal

void func(const int&);
func(i); // legal
func(ci); // legal
func(ref); // legal
func(ref1); // legal
func(1); // legal
func(give_me_an_int()); // legal
```

Про константные правые ссылки мы уже поговорили в этом посте!!!, поэтому не буду их упоминать за редкостью использования.

Запомните: lvalue к lvalue|lvalue reference, rvalue reference к rvalue reference, а в const lvalue reference можно подсовывать что угодно.

Stay universal. Stay cool.
#cppcore #cpp11 


https://stackoverflow.com/questions/61743861/rvo-nrvo-can-not-be-disabled-in-c17-in-clang



Аргумент функции - массив

Сразу оговорюсь, что здесь речь идет про тип данных массив, а не про структуру данных или стандартный контейнер.

Массивы достались плюсам от их предка и выглядят примерно так:

```cpp
const char luntic[] = "I was born!";
```

Это набор объектов одного типа фиксированного размера.

И есть такое интересное свойство у массивов, позволяющее им мимикрировать под  указатель на его первый элемент. То есть

```cpp
const char * ptr_luntic = luntic;
```

Главное здесь помнить, что const char[] и const char * - разные типы. Но так как есть правило приведения массива к указателю, код компилируется.

Ну раз это 2 разных типа, то мы и можем объявить 2 перегрузки одной функции, которые будут принимать каждый из типов. Типа такого:

```cpp

void test_fun(int param[]) {...}

void test_fun(int* param) {...}
```

А вот и нихрена! Компилятор видит это как одну и ту же перегрузку!

Почему так?

Потому что в плюсах нет такого понятия, как функция, принимающая массив. В данном случае массив мимикрирует под указатель. То есть на самом деле, когда мы передаем массив в такую функцию, то на самом деле вот что происходит:

```cpp
int arr[5] = {};
test_fun(arr); // выглядит, как передача массива, а на самом деле делается следующее:

// test_fun(&arr[0]);
```

И легко проверить, что две перегрузки выше - одинаковые. Скомпилируем программу с первой "перегрузкой" test_fun и посмотрим, в какое внутреннее имя заманглилась функция.

На моем гцц функция имеет следующий mangled name:

```
__Z8test_funPi
```

В замангленном имени после обычного имени функции идут ее аргументы. И тут сразу видно, что функция test_fun принимает указатель на int!

Не то, чтобы до этого кому-то было дело, но эта ситуация аукается, когда мы пытаемся передать массив в шаблонную функцию. Возможные варианты развития событий рассмотрим завтра.

Differentiate things apart. Stay cool.

#compiler #cppcore



Аргумент шаблонной функции - массив

Давайте рассмотрим, во что будет выводиться шаблонный параметр функции, если ее аргументом будет массив. 

Допустим, мы решили принимать аргументы функции по значению:

```cpp
template <class T>
void func(T param) {...}

int the_most_misterious_numbers_in_universe[] = {42};
func(the_most_misterious_numbers_in_universe); // although arg is array, T is int*
```

Какой выведется тип шаблонного параметра?

Поскольку объявления параметров массива обрабатываются так, как если бы они были параметрами-указателями, тип массива, который передается в функцию шаблона по значению, считается типом указателя. Поэтому тип шаблонного параметра выведется в указатель.

Замангленное имя функции будет примерно такое:

```
__Z6funcIPiEvT_
```
Видно, что функция инстанцирована с типом указателя на инт(Pi) и типом параметра Т.

Однако плюсы не были бы плюсами, если все было бы так просто. Давайте посмотрим, что будет, если в параметр функции добавить ссылочность:

```cpp
template <class T>
void func(T& param) {...}

int the_most_misterious_numbers_in_universe[] = {42};
func(the_most_misterious_numbers_in_universe);
```

В этом случае Т выводится, как настоящий тип массива!
Вот замангленное имя функции 

```
__Z6funcIA1_iEvRT_
```

Это инстанциация(большая I) функции с шаблонным типом - int[1] массива интов с одним элементом(A1_i) и параметром шаблонном функции - ссылкой на Т( в конце RT - reference to T), то есть ссылкой на массив.

А вы не знали, что в плюсах можно объявлять функции, которые принимают ссылку на массив? Вот теперь знаете. Делается это примерно так:

```cpp
void test_fun(int (&param)[100]) {...}

// mangled name is __Z8test_funRA100_i
```

Эта функция может принимать как аргумент только массив интов на 100 элементов и ничто иное. Синтаксис выглядит токсичным, словно лаймом в глазницу капнули. Но имеем, что имеем.

Мы также напрямую можем использовать в шаблонах синтаксис объявления параметра, как ссылки на массив. Чтобы принимать массивы любого размера можно написать что-то подобное:

```cpp
template<typename T, std::size_t N>
constexpr std::size_t arraySize(T (&)[N]) noexcept
{
	return N;
}
```

Здесь определяется компайл-тайм функция, которая принимает только массивы любых типов и длин, и возвращает наружу длину переданного массива. Возвращенное значение - тоже compile-time константа, поэтому с его помощью можно, например, создать std::array:

```cpp
int c_arr[] = { 1, 3, 7, 9, 11, 22, 35 };
std::array<int, arraySize(c_arr)> cpp_arr;
```

То есть основное преимущество принимания массива по ссылке - сохранение информации о его размере.

Большинству из нас эта информация пригодится дай бог 1 раз за всю карьеру, но чем черт не шутит. А если война, а вы не готовы? Поэтому продолжаем изучать тонкости вывода шаблонных параметров.

Stay prepared. Stay cool.

#template #cppcore

Аргумент шаблонной функции - функция

Вот этот кейс точно почаще встречается, чем предыдущий. Даже в стандартной библиотеке много примеров, когда например алгоритм принимает отдельным шаблонным параметром операцию, которую нужно проделать над ренджом. Туда в том числе можно передавать и функцию, поэтому важно понимать, какие процессы там внутри происходят. 

Массивы - не единственные сущности, которые неявно косят под указатели. Функции тоже имеют такую особенность. Собственно, она и отражается на выводе типов, если передать в шаблонную сущность функцию.

```cpp
void someFunc(int, double); // someFunc is a function;
							// type is void(int, double)

template<typename T>
void f1(T param);

template<typename T>
void f2(T& param);

f1(someFunc); // param deduced as ptr-to-func;
			  // type is void (*)(int, double)
f2(someFunc); // param deduced as ref-to-func;
			  // type is void (&)(int, double)
```

Происходит на самом деле очень похожая с массивами тема: если параметр функции принимается по значению, то шаблонный тип выводится в указатель на функцию. А если принимает по ссылке, то тип выводится в ссылку на функцию.

Я бы сказал, что никакой особой разницы между двумя этими ситуациями нет.

Возможно с помощью использования ссылок на функции мы можем немного обезопасить код. Указатель может быть нулевым, а вот ссылка всегда должна указывать на валидный объект, поэтому можно не беспокоиться по поводу сегфолтов.

Если есть еще идеи по поводу различий двух кейсов - пишите в комментах. Да и вообще, расскажите про свой опыт использования ссылок на функции.

А чтобы не завершать пост на этой грустной ноте, рассажу немного про ссылки на функции, так как многие слышали про указатели на функции, но немногие слышали про их собратьев-ссылок.

Семантика для объектов тут абсолютно повторяется: ссылка - это псевдоним. Она является синонимом для функции, должна быть инициализирована сразу при создании и не может быть перенаправлена.

Определяется она примерно так:

```cpp
void func(int i, double d) { std::cout << "bla-bla" << std::endl;}
void (&rf)(int, double) = func; 
rf(42, 4.2);
// OUTPUT:
// bla-bla
```

На самом деле небольшие отличия от определения указателя на функцию:

```cpp
void (*pf)(int, double) = func; 
pf(42, 4.2);
// OUTPUT:
// bla-bla
```

Ровно как с объектами: заменяешь * в объявлении на & и переменная становится ссылкой вместо указателя.

Функция может принимать ссылку на другую функцию вот так:

```cpp
void Call( void (&rf)(int, double) )
{
    rf(42, 4.2);
}

Call(func);
// OUTPUT:
// bla-bla
```

И чтобы сильно не упарываться с объявлением можно использовать наш любимый-дорогой 11-ый стандарт с его auto:

```cpp
auto &rf = func;
rf(42, 4.2);
```

На этом самые распространенные и не очень кейсы для понимания правил вывода типов заканчиваются.

Go easy. Stay cool.

#template #cppcore #cpp11




Виды шаблонных параметров

В С++ шаблонным параметром может быть не только тип. При рассмотрении аргумента-массива мы упоминали такую функцию:

```cpp
template<typename T, std::size_t N>
constexpr std::size_t arraySize(T (&)[N]) noexcept
{
	return N;
}
```

Здесь шаблонная функция принимает шаблонный параметр N, который является числом! То есть функция может быть инстанцирована под конкретное число и для каждого отличающего числа будет своя инстанциация. Здесь мы явно не указываем это число при вызове функции, потому что оно выводится из аргумента, но все же.

В ней сочетаются сразу несколько видов шаблонных параметров. Это нормально, их все можно комбинировать. Но давайте сейчас определим, какие же все-таки виды шаблонных параметров существуют.

1 Тип. Это то, к чему мы больше всего привыкли. Однако не торопитесь думать, что здесь больше сказать нечего. Этот вид подразделяется еще на 6:

```cpp
template<class T>
class My_vector; // обычный параметр без дефолтного значения

template<class T = void>
struct My_op_functor; // параметр, имеющий значение по умолчанию

template<typename... Ts>
class My_tuple; // пак параметров-типов

template<My_concept T>
class My_constrained_vector // концепт

template<My_concept T = void>
class My_constrained_op_functor // концепт со значением по умолчанию

template<My_concept... Ts>
class My_constrained_tuple // пак параметров-концептов
```
Название параметра - алиас(typedef) для типа, с которым шаблон инстанцирован.

Но мало того, имена для параметров - вообще вещь необязательная!

```cpp
template<class>
class My_vector;
template<class = void>
struct My_op_functor;
template<typename...>
class My_tuple;
```

Такой код вполне лигитимен, если не имя параметра так и не используется.

2 Нетиповые параметры. Это значит, что шаблон инстанцируется со значением конкретного заранее определенного типа. Здесь также есть разновидности:

```cpp
template<IntegerType Size>
class My_array; // Size - конкретное значение интегрального типа IntegerType

template<IntegerType Size = 5>
class My_array; // 5 - значение по умолчанию

template<IntegerType ...Numbers>
class Integer_collection; // пак значений
```

На месте конкретного типа может стоять auto или decltype(auto).

```cpp
template<auto N>
void some_func1();

template<decltype(auto) N>
void some_func2();
```

Значения не всякого типа могут быть использованы для инстанцирования шаблонов. Ими могут быть:
lvalue ссылки
интегральные типы
указатели
перечисления
типы чисел с плавающей точкой
лямбда замыкания с пустым списком захвата
типы, у которых все базы и нестатические мемберы публичные и являются одним из типов, перечисленных выше.

3 Шаблон-шаблонные параметры. В оригинале звучит получше: "template template parameters". Эти хреновины позволяют вам принимать в качестве параметра шаблон, чей шаблонный параметр вы также хотите шаблонизировать. Синтаксис параметра примерно такой:

```cpp
template<parameter-list> type-parameter-key name
```

Могут быть такие же вариации с дефолтным значением и вариадиком.

В реальном примере это может выглядеть так:

```cpp
template<template<uint8_t> typename T, uint8_t Version>
void Foo(const T<Version>& obj){
	static_assert(Version >= 3, "Versions older than 3 are no longer handled");
	// some stuff
}
template<uint8_t Version> struct Type{};

Foo(Type<2>{}); // failed due to static_assert
Foo(Type<3>{}); // OK
```

 template-template параметры используются довольно редко. Стандартные контейнеры(которые являются очевидными кандидатами на роль этих параметров) позволяют получить типы параметров, с которыми они инстанцированы, и без этого приема. Например через value_type. 

Поэтому в комментариях можете поделиться опытом использования шаблон-шаблонных параметров.

Unload your brain using templates for your routines. Stay cool.

#cppcore #templates





Все это время мы говорили про такой вариант записи шаблона:

```cpp
template <class T>
void func(ParamType param) {...}

func(expression);
```

То есть у нас варьировался тип ParamType и тип выражения expression. А что если внутри скобок template будет не просто Т, а другая кракозябра? 
