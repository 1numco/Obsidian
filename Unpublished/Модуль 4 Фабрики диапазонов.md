
ОРы:
- применяет std::views::iota для порождения диапазона из чисел
- применяет std::views::repeat для порождения диапазона из повторений одного числа

Структура

- начинаем раскрывать тот факт, что отображения - это намного больше, чем просто средство слежки за контейнерами. Отображение знает лишь начало последовательности(итератор начала), как двигаться по последовательности(с помощью инкремента итератора) и признак окончания последовательности(ограничитель). Поэтому отображения могут быть созданы вообще без упоминания какого-либо контейнера или массива. 
- существует целый класс отображений - фабрики диапазонов. Обсудим самые полезные из них.
- приводим пример с генератором range из питона. Он тоже знает начало, конец и шаг между числами. Библиотека ranges предоставляет нам похожую сущность - std::views::iota. Теперь итерация по индексам намного проще.
- std::views::repeat. Порождает одинаковые элементы. Может использоваться для генерации тестовых данных или эмулировать поток одинаковых данных.

Контент

Отображения позволяют на лету генерировать элементы последовательности. Сегодня вы узнаете:
- как std::views:iota помогает генерировать числа.
- как std::views::repeat помогает генерировать одинаковые объекты.

## Мощь отображений

В этом уроке мы начинаем раскрывать тот факт, что отображения - это намного больше, чем "окна" в элементы контейнеров. Давайте вспомним, что представляет из себя отображение. Это легковесный, быстро-копируемый и -перемещаемый объект, который знает всего 2 вещи: итератор на начало последовательности и признак е окончания. Двигаться по последовательности view может с помощью инкремента итератора. 

Итератор в этом случае может вообще не связан ни с каким контейнером. Итератором - это просто адаптер для движения по последовательности. Эта последовательность может быть виртуальной и представлять из себя всего одно значение:

```cpp
template <typename T>
class CountingIterator {
public:
	// Типы, необходимые для итератора
	using iterator_category = std::input_iterator_tag;
	using value_type = T;
	using difference_type = std::ptrdiff_t;
	using pointer = T*;
	using reference = T&;
	
	// Конструкторы
	explicit CountingIterator(T value) : current_value(value) {}
	CountingIterator() : current_value(0) {}
	
	// Операторы
	T operator*() const {
		return current_value;
	}
	// Префиксный инкремент
	CountingIterator& operator++() {
		++current_value;
		return *this;
	}
	// Постфиксный инкремент
	CountingIterator operator++(int) {
		CountingIterator tmp = *this;
		++current_value;
		return tmp;
	}
private:
	T current_value;
};
```

Перед вами итератор, внутри которого всего лишь одно значение. В инкрементах этого итератора мы просто увеличиваем значение поля `current_value` и все выглядит так, как будто бы мы итерируемся по массиву целых чисел, начиная со значения `value`.

Вот так можно использовать этот итератор:

```cpp
for (auto it = std::counted_iterator{begin, 10}; it != std::default_sentinel; ++it)
	std::println("{}", *it);
```

Здесь используется обертка `std::counted_iterator`, чтобы задать размер последовательности.

И по сути объект `std::counted_iterator{begin, 10}` - это тоже отображение. Он знает только начало и ограничитель и позволяет генерировать последовательность из чисел. И контейнерами в этом коде даже не пахнет! Отображения, самостоятельно генерирующие последовательности, называются фабриками диапазонов.
## std::views::iota

И у такого отображения есть отличные кейсы применения. В Python, например, есть генератор range, с помощью которого обычно итерируются по индексам:

```py
for i in range(5, 10):
	print(i)
```

И того же самого мы можем добиться в С++! И нет, вам не нужно в каждом проекте реализовывать CountingIterator. Библиотека ranges предоставляет вам удобное отображение std::views::iota на такие случаи:

```cpp
std::ranges::for_each(std::views::iota(1, 10), [](int i) { std::print("{} ", i);};
```

std::views::iota принимает 2 параметра: начало последовательности и ограничитель, которые могут быть разных типов. И это отображение представляет собой диапазон от начала до ограничителя(ограничитель в диапазон не входит. Код сверху выведет:

```
1 2 3 4 5 6 7 8 9 
```

Можно также использовать range-based-for цикл:

```cpp
for(int i: std::views::iota(1, 10))
	std::print("{} ", i);
```

В таком виде итерация по индексам синтаксически эквивалентна итерации по контейнеру.

Ограничитель также не обязан быть числом, главное чтобы он был сравним с типом начала последовательности:

```cpp
struct Bound {
	int bound;
	// можно сравнивать с числом
	bool operator==(int x) const {
		return x == bound;
	}
};

for (int i : std::views::iota(1, Bound{10}))
	std::print("{} ", i);
```

С помощью std::views::iota также можно создавать бесконечные последовательности:

```cpp
for (int i : std::views::iota(1))
	std::println("{}", i);
```

Если передать всего 1 параметр, то ограничителю присваивается std::unreachable_sentinel_t и диапазон становится неограниченным. Код сверху будет печаталь на консоль инкремент числа 1, пока вы не остановите программу.

Получается, что std::views::iota позволяет унифицировать синтаксис итерации по индексам и привести его к итерации по диапазону. Это позволяет писать более выразительный код и универсально обрабатывать диапазоны разных типов.

## std::views::repeat

У std::views::iota есть соратник по задаче генерации диапазона из пустоты. Это  std::views::repeat. Судя по названию, это объект, который позволяет генерировать диапазон из повторяющихся элементов. Работает это так:

```cpp
// используем строковый литерал `sv`, чтобы привести C-style строку к std::string_view.
using namespace std::literals;
for (auto s : std::views::repeat("C++"sv, 3))
	std::print("{} ", s);
// вывод: `C++ C++ C++ `
```

std::views::repeat также принимает 2 параметра: значение объекта и ограничитель. В данном случае ограничитель - это число повторений первого параметра в диапазоне. Объект должен быть удовлетворять требованиям std::move_constructible, то есть его можно сконструировать из правой ссылки. Поэтому мы используем строковый литерал, чтобы сделать из C-style строки объект, который можно перемещать.

Можно также генерировать бесконечную последовательность, по аналогии с std::views::iota:

```cpp
using namespace std::literals;
for (auto s : std::views::repeat("C++"sv))
	std::println("{}", s);
```

std::views::repeat может использоваться для генерации повторяющихся тестовых данных:

```cpp
bool has_duplicates(const auto& range);

TEST(MyTest, DuplicatesCheck) {
    // Генерируем 100 копий числа 42
    auto test_data = std::views::repeat(42, 100);
    ASSERT_TRUE(has_duplicates(test_data));
}
```

или же для эмуляции бесконечного потока данных aka стресс-тест:

```cpp
void process_message(int msg);

void stress_test() {
    // Бесконечный поток из "1", но берем только 10'000 для теста
    auto infinite_msgs = std::views::repeat(1, 10'000);
    for (int msg : infinite_msgs) {
        process_message(msg);
    }
}
```


## Заключение

Сегодня вы узнали:

- отображения могут быть никак не связаны с контейнерами и могут даже сами генерировать последовательности. Такие отображения называются фабриками диапазонов
- std::views::iota позволяет генерировать диапазон, в котором каждый следующий элемент будет инкрементом предыдущего.
- std::views::repeat позволяет генерировать диапазон, который состоит из повторяющихся элементов.


