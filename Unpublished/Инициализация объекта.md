Правильный ответ - {мусор} {мусор} 5.

Список инициализации в конструкторе - вещь дельная, полезная и иногда без нее никуда. Но с ним есть один неприятный момент - все может пойти по шляпе, если не соблюдать одно правило. "Порядок инициализации полей в списке инициализации конструктора должен совпадать с порядком следования полей в описании класса". Но вот не все знают, что же будет, если это правило нарушить. Поэтому давайте разбираться.

Для начала приведу цитату из стандарта:

In a non-delegating constructor, initialization proceeds in the following order:

- First, and only for the constructor of the most derived class, virtual base classes 
are initialized in the order they appear on a depth-first left-to-right traversal of the 
directed acyclic graph of base classes, where “left-to-right” is the order of appearance 
of the base classes in the derived class base-specifier-list.
    
- Then, direct base classes are initialized in declaration order as they appear in the 
base-specifier-list(regardless of the order of the mem-initializer)
    
- Then, non-static data members are initialized in the order they were declared in the
 class definition (again regardless of the order of the mem-initializer()
    
- Finally, the compound-statement of the constructor body is executed.


Теперь разжуем эту сухую писанину в мягкую кашицу для лучшего усвоения.

В начале инициализируются базы класса в порядке, определяемом древовидной структурой наследования и ее проходом в глубину слева-направо. Не думаю, что сейчас надо что-то больше пояснять, как и про инициализацию статических полей. Ориентировочно 3.245 лайка на этот пост хватит, чтобы мы начали готовить про эти темы посты.

Далее инициализируются нестатические поля класса в порядке, в котором они объявлены в определении класса, и который никак не зависит от списка инициализации конструктора.

Ну и далее выполняется само тело конструктора.

Какие из этого выводы?

Самый главный - поведение абсолютно определено стандартом. Здесь нет никакого UB! Список инициализации лишь задает способ инициализации, но никак не влияет на порядок. Порядк определяется только порядком следования полей в описании класса(сверху вниз).

То есть в нашем примере в начале будет инициализировать b, потом a и, наконец, c. И не смотря на то, что в списке инициализации c стоит первым, на самом деле его инициализация будет проходить последней. А так как все остальные поля зависят от значения c и инициализируются раньше него, то в них будет содержаться мусор.

Никто нам не может запретить писать список инициализации в том порядке, в котором мы хотим. Да и непонятно, как это сделать. С точки зрения С++, код вполне корректен и может работать. Просто от этого будут последствия, но вполне предсказуемые.

Благо, к нам на помощь приходят компиляторы, которые аккуратно подскажут нам, что мы делаем чухню возможно не то, что хотим. Скорее всего компилятор вам сам кинет ворнинг, что переменная c используется неинициализированной. Чтобы точно заставить компилятор это сделать, добавьте опцию -Wall. Подробнее про ворнинги в этом цикле статей (https://t.me/grokaemcpp/31).

Также вы можете(должны?) добавить флаг компиляции, чтобы превращать все предупреждения в ошибки. Тогда вы точно ничего важного не пропустите. Как говорится, флаг -Werror вам в руки!

Можете, кстати, поделиться в комментах историями, как у вас на проектах не стоял этот флаг, рекордным количеством неисправленных ворнингов и последствиями пренебрежением предупредпреждений.

Еще есть нюансы с default member initializer и его сочетанием со списком инициализации конструктора. Короче, много нюансов, как и во всех плюсах)
В один пост все все равно не влезет. Будем разделять и властвовать!

Devide et empera. Stay cool.


Инициализация статических полей класса. Ч1

Под этот пост(https://t.me/grokaemcpp/241) вы накидали хренову гору лайков, поэтому разбираем дальше тему инициализации. Сегодня рассмотрим, как она проходит для классов со статическими полями.

Начнем с того, что все статические поля всех классов инициализируются до входа в main. Это и логично, ведь к таким полям мы в любой момент можем обратиться без объекта, просто по имени класса. Но вот в какой конкретно момент времени мы не можем сказать наверняка, это implementation defined штука. Каждый линкер вправе делать это по-своему. Единственное, что стандарт нам гарантирует:

```
Objects with static storage duration 
defined in namespace scope in the same 
translation unit and dynamically initialized 
shall be initialized in the order in which 
their definition appears in the translation unit.
```

Все статические объекты инициализируются в порядке, в котором они **определены**(не объявлены) в единице трансляции. Причем происхождение этого статического объекта не важно. Например, скомпиляровав и запустив такой пример в main.cpp:

```cpp
struct Helper {
	Helper(int num) : data{num} { 
		std::cout << "Helper " << num << std::endl;
	}
private:
	int data;
};

struct Class {
	static Helper a;
	static Helper b;
};

Helper Class::b{1};
static Helper c{2};
Helper Class::a{3};

int main() {}
```

Мы в выводе получим следующее:

```
Helper 1
Helper 2
Helper 3
```

Несмотря на то, что в классе Class поле `a` было объявлено первым, инициализируется оно самым последним, потому что оно определено самым последним. А переменная `c` вообще не относится к классу, но была проинициализирована между полями Class'а, потому что ее определение расположено между ними. 

Это происходит из-за того, что статические поля класса практически никак с этим классом не связаны. Доступ к ним разве что через имя класса. А так это обычная статическая переменная, как и любая другая.

Именно поэтому в цитате из стандарта говорится обобщенно о статических объектах. Для линкера вообще никакой разницы между переменными `a`, `b` и `c` нету. Это просто сущности с разными именами, но абсолютно равными правами. 

С инициализацией статических полей и объектов еще много нюансов, будем потихоньку все разбирать.

Define order of your life. Stay cool.

#cppcore

Инициализация статических полей класса. Ч2

Как думаете, может ли быть такое, что статическое поле класса инициализируется после **завершения** вызова конструктора класса? То есть объект уже создался, а статическое поле его класса еще не инициализированно? Подумайте пару секунд над этим вопросом самостоятельно.

После вчерашнего поста вам уже немного легче должны были даться рассуждения. Загвоздка в том, что статическое объекты инициализируются в порядке определения и не важно, какого класса эти объекты.

Посмотрим на пример.

Есть у нас класс, который сохраняет все свои инстансы по ключу в статическую мапу и все созданные инстансы доступны только через эту мапу.

```cpp
class InitializationTest {
public:
	static std::map<std::string, std::unique_ptr<InitializationTest>> map;
	static bool Create(std::string ID) {
		map.insert({ID, std::move(std::unique_ptr<InitializationTest>{new InitializationTest})});
		return true;
	}
private:
	Test() = default;
};

static bool creation_result = InitializationTest::Create("qwe");
// Somehow handle result and process object
std::map<std::string, std::unique_ptr<InitializationTest>> InitializationTest::map{};

int main() {}
```

Чтобы такое провернуть, создаем в классе статическую мапу, статический метод Create, который предоставляет доступ к созданию объектов и объявляем конструктор класса приватным, чтобы никто снаружи не смог втихаря создать объект. Таким образом, доступ к объектам есть только через метод Create и статическую мапу.

Не имея представления о нюансах инициализации, взбрело нам в голову создать b использовать объект перед определением мапы.

Запуская все это дело, получим сегфолт. И да, да, вы все правильно поняли. Все из-за порядка инициализации.

Так как линкеру пофиг на тип статических объектов, он спокойно может поставить инициализацию статического поля класса после завершения работы конструктора объекта в глобальном неймспейсе. Вот и получается конфуз: объект надо создавать, а используемое поле не инициализировано. От того и падаем.

Здесь ситуация игрушечная и довольно простая, потому что все находится в одной единице трансляции. Пример такой, потому что внутри одной единицы компиляции порядок инициализации детерминирован. Но когда мы выходим за ее пределы и пытаемся создать объект InitializationTest в другой единице трансляции в глобальном скоупе, то поведение кода начинает зависеть от линкера. Порядок создания объектов между юнитами компиляции не определен и тут все будет, как решит компановщик. Можно конечно почитать документацию и действовать в соответствии с ней. Но этот код будет непереносим, а также не защитит вас от возможных изменений в поведении линкера.

Будьте аккуратны с инициализацией статических объектов и в принципе поменьше их используйте.

Be careful. Stay cool.

Инициализация статических полей класса. Ч3

В первой части мы разобрали порядок инициализации статических поле в случае их out-of-class определения. Однако в современных плюсах редко, кто вне описания класса инициализирует статические поля. Все потому что в С++17 появились инлайн переменные, которые позволяют не нарушать ODR при наличии их определения в разных единицах трансляции. Подробнее об этом [тут](https://t.me/grokaemcpp/134). Эта фича позволила определять статические поля сразу внутри описания класса. Более подробно об этом [тут](https://t.me/grokaemcpp/135).

Ну и встает вопрос: в каком порядке инициализируются inline static class members?

В целом, ответ такой же: в порядке определения. Только эти определения теперь совмещены с объявлением, поэтому можно сказать, что инициализация происходит в порядке появления этих полей в описании класса. Спасибо Артему Кузнецову, что указал в комментариях на эту особенность)

Ну и для того, чтобы пост был не таким скучным, давайте попробуем смешать обычные статические мемберы и инлайновые и посмотрим, как эта смесь будет себя вести.

Выглядит это примерно так:

```cpp
struct Helper {
	Helper(int num) : data{num} { 
		std::cout << "Helper " << num << std::endl;
	}
private:
	int data;
};

struct Class {
	static inline Helper a{1};
	static Helper b;
	static inline Helper c{2};
};

Helper Class::b{3};

int main() {}
```

Вывод будет таким:

```
Helper 1
Helper 2
Helper 3
```

В целом, картина довольно понятная. Если линкер ставит инициализацию статиков по порядку их определения, то здесь прослеживается та же история. Первыми инициализируются инлайны по порядку появления их в классе, а последним инициализируется неинлайновое поле, даже с учетом того, что оно объявлено между двумя первыми.

Так что порядок следования определений - наше все.

Rely on explicitly stated rules. Stay cool.

#cpp17 #cppcore





static local variables

В [этом](https://t.me/grokaemcpp/137) давнишнем посте кратко резюмировали все стороны "употребления" ключевого слова static. Сегодня поговорим про статические локальные переменные.

Это довольно интересная сущность, которая сочетает в себе поведение локального объекта функции и глобальной переменной. 

От локального объекта она берет область видимости. То есть к этой переменной по имени никак нельзя обратиться вне ее функции. Можно, например, вернуть из функции ссылку на эту переменную и иметь возможность ее читать и модифицировать. Но по имени к ней можно обратиться только внутри функции. Соответственно, у static local variable нет никакого собственного типа линковки, это бессмысленно.

От глобальной переменной она берет статическое время жизни. То есть, начиная с момента своей инициализации, она продолжает существовать, пока не вызовется std::exit aka завершение программы.

Разберем немного цикл жизни такой переменной.

1) Она инициализируется при первом вызове функции. Стандарт нам говорит:
```
such a variable is initialized the first 
time control passes through its declaration; 
such a variable is considered initialized 
upon the completion of its initialization. [...] 
If control enters the declaration concurrently 
while the variable is being initialized, 
the concurrent execution shall wait for 
completion of the initialization.
```

То есть нам дается очень важная гарантия: локальные статические переменные инициализируются потокобезопасно. Это значит, что даже если несколько потоков одновременно зайдут в функцию и попытаются проинициализировать переменную, то победителем в этой истории будет только один поток, который и проведет инициализацию, все остальные будут ждать. Эта гарантия появляется вместе с появлением новой модели памяти и исполнения в С++11. И обычно реализуется с помощью паттерна блокировки с двойной проверкой.

Однако, если переменная числового типа или инициализируется с помощью константного выражения, то инициализация может произойти раньше(какой смысл ждать, если все понятно как делать и делать это просто).

2) При выходе из скоупа функции для статической локальной переменной не вызывается деструктор. Она продолжает жить не тужить и сохраняет свое значение до следующего вызова функции.
3) При повторном заходе в функцию объявление переменной просто игнорируется и выполняется весь код, помимо инициализации. Здесь мы можем повторно использовать переменную, изменить ее значение и вообще много чего с ней делать.
4) После завершения функции main переменная разрушается. Press F умершим.

Пример:

```cpp
std::string BytesToHex(const void* bytes, size_t size)
{
	if (size) {
		static const char kHexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7',
		'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'}; // initialize here once
		std::string output;
		output.reserve(size * 2);
		auto c = static_cast<const uint8_t*>(bytes);
		for (size_t i = 0; i < size; ++i) {
			uint8_t value = *(c + i);
			output.push_back(kHexDigits[value >> 4]);
			output.push_back(kHexDigits[value & 0xf]);
		}
		return output;
	}
	else {
		return "";
	}
}

int main()
{
	std::cout << BytesToHex("", 0) << std::endl; // kHexDigits do NOT initialize now
	std::cout << BytesToHex("123", 3) << std::endl; // initialize here
	std::cout << BytesToHex("abc", 3) << std::endl; // retain value
}
```

Функция BytesToHex переводит любое количество байт от заданного указателя в их hex представление. Раз мы знаем, что hex представление содержит только 16 символов и больше нигде эти символы не нужны, то очень удобно поместить массив этих символов в саму функцию в качестве локальной статической переменной. Так мы инкапсулируем данные и сохраним возможность 1 раз создать переменную и пользоваться именно этим инстансом во всех вызовах функции.

Один интересный момент, что kHexDigits инициализируется не при первом вызове функции. Потому что в первый раз исполнение не прошло через ее декларацию. И только начиная со второго вызова она начинает существовать и разрушается только после выхода из main().

Статические локальные переменные имеют массу преимуществ, по сравнению с обычными глобальными переменными. Просто тот факт, что мы можем полностью контролировать их жизненный цикл может уберечь нас от всем известных проблем с инициализацией глобальных объектов.

Take care of yourself. Stay cool.

#cpp11 #multitasking #cppcore




Цикл жизни non-local static storage duration переменных

В прошлом посте поговорили про локальные статические переменные и их цикл жизни. Сегодня в общем рассмотрим рождение и смерть всех нелокальных глобальных переменных.

Здесь важна оговорка, что объекты со static storage duration не обязаны быть помечены ключевым словом static! Этот термин употребляется для описания объектов, лишь время жизни которых является статическим. То есть более менее всех глобальных объектов. Все они существуют от момента создания до момента завершения программы. Поэтому просто написав:

```cpp
int var = 1;
```

считайте, что вы объявили переменную со static storage duration.

Для краткости, вместо "объект со static storage duration" буду писать"глобальный объект".

Так вот. Для таких объектов существует строгий порядок инициализации, который состоит из определенных шагов и подшагов.

1) Статическая инициализация. В сущности, это установление значения, которое может быть проведено во время компиляции. Состоит из двух подшагов:

Первым, если возможно, идет константная инициализация. Проводится, когда инициализатор - константное выражение.

Во всех остальных случаях проводится Zero-инициализация.

2) Динамическая инициализация. Только после того, как проведена статическая инициализация, вступает в игру динамическая. Которая и является причиной static initialization order fiasco. Потому что дает очень мало гарантий по поводу порядка инициализации, одна из которых описана [тут](https://t.me/grokaemcpp/246). Но в общем и целом, порядок инициализации глобальных объектов в разных юнитах трансляции не определен. Обычно она происходит в рантайме, но если компилятор может, то он производит ее в compile-time при наличии определенных условий.

После инициализации переменная живет в течение всего времени существования программы до тех пор, пока она не завершится. 

Если чуть подробнее, то при выходе из функции main происходят все стандартные процессы разрушения локальных переменных, но еще и вызов std::exit с возращаемым из мэйна значением в качестве аргумента. И вот std::exit одним из своих шагов триггерит вызов деструкторов глобальных объектов.

Это суперобобщенно, поэтому дальше будем раскрывать все эти стадии.

Define cycle of your life. Stay cool.

#cppcore #compiler 



Zero initialization

Решил начать в нулевой инициализации, так как она как будто бы самая простая и понятная.

Выполняется она после попытки выполнить константную инициализацию глобальных объектов и представляет из себя literally "зануление объекта".

Так как для этого вида установки значения объектам нет своего выделенного синтаксиса в языке, то вот примеры того, в каких ситуациях она может быть выполнена:

```cpp
static T object;
T();
T t= {};
T{};
CharT array[n] = "short-sequence";
```

Примеров на самом деле больше, но так описано в стандарте, поэтому надо уважить дедов. И вот почему примеров больше.

Нулевая инициализация в любом случае проводится для всех глобальных переменных, если их нельзя константно проинициализировать, раньше всех остальных видов инициализации. То есть создали вы объект в глобальном скоупе, который динамически проинициализировали(в рантайме). В констукторе можно напихать все, что угодно(чего не было в примерах выше), но этот объект все равно будет проинициализирован нулями на этапе компиляции.

Также она проводится для массивов символьных типов, если инициализирующая строка слишком короткая. Остаток будет заполняться нулями.

Ну и про "зануление". У zero-initialization следующие эффекты:

Если T - скалярный тип, объект инициализируется результатом превидения численного литерала `0` к типу T.

Если T - кастомный тип, то:
	все паддинги инициализируются битами нулями.
	для всех нестатических мемберов проводится zero-initialization(немного рекурсии, но все рано или поздно сводится к скалярным типам и массивам).
	для подобъектов каждого базы класса проводится zero-initialization.

Если Т - массив, то каждый элемент zero-инициализирутся.

Если Т - ссылка, то гоняем лысого(ЗАЧЕРКНУТЬ)ничего не делаем.

Обычно zero-инициализированные объекты находятся в .bss секции бинарника, которую иногда обзывают .zerofill секцией.

Как и говорил, довольно просто, но это знание будет полезно в дальшейших статьях.

Stay useful. Stay cool.

#cppcore



Константная инициализация. Ч1

Это первый шаг, который пытается выполнить компилятор, когда пробует инициализировать переменную. Для него требуется, чтобы инициализатор был константным выражением. То есть его можно было бы вычислить во время компиляции. И не путать с обычным const! Позже покажу почему.

Также гарантируется, что эта инициализация происходит до любой другой инициализации статиков. На практике же компиляторы вообще сразу в бинарь помещают предвычисленное значение объекта и во время выполнения с ним уже ничего не нужно делать. Пример:
```cpp
constexpr double constexpr_var{1.0};

double const_intialized_var1{constexpr_var};

const double const_var{const_intialized_var1};

double const_intialized_var2{3.0};
```

С переменной `constexpr_var` все хорошо, константа присваивается константному выражению и инициализируется эта переменная первой. Далее устанавливается значение для `const_intialized_var1`. Несмотря на то, что эта переменная не константа, ее инициализатор - константное выражение, а этого достаточно для выполнения константной инициализации. Интересно, что дальше устанавливается значение переменной `const_intialized_var2`, а не `const_var`. Хоть `const_var` и константа, ее инициализатор не является константным выражением!  У переменной `const_intialized_var1` нет пометки const(constexpr), поэтому, хоть она и проинициализирована константой, сама таковой не является. И `const_var` будет инициализироваться последней уже в рантайме.

Точнее немного не так. Она будет проиниализирована последней, но аж 2 раза! Первый раз - zero-инициализацией на этапе компиляции, второй раз - динамической в рантайме.

Чтобы не пустословить по чем зря, покажу вырезки из ассембера, которые подкрепляют мои слова. Вот чего нашел:
```
	.section	__DATA,__data
	.globl	_const_intialized_var1          ## @const_intialized_var1
	.p2align	3, 0x0
_const_intialized_var1:
	.quad	0x3ff0000000000000              ## double 1

	.globl	_const_intialized_var2          ## @const_intialized_var2
	.p2align	3, 0x0
_const_intialized_var2:
	.quad	0x4008000000000000              ## double 3

	.section	__TEXT,__const
	.p2align	3, 0x0                          ## @_ZL13constexpr_var
__ZL13constexpr_var:
	.quad	0x3ff0000000000000              ## double 1

.zerofill __DATA,__bss,__ZL9const_var,8,3 ## @_ZL9const_var
	.section	__DATA,__mod_init_func,mod_init_funcs
	.p2align	3, 0x0
	.quad	__GLOBAL__sub_I_main.cpp
```

`constexpr_var` инициализируется в текстовой секции. Не смотрите, что эта секция расположена в середине, стандарт гарантирует, что ее инициализация произойдет первой(тогда `const_intialized_var1` досталась бы фига).

Дальше мы переходим к data секции, в которой подряд инициализируются `const_intialized_var1` и `_const_intialized_var2`. И после всего этого в секции .zerofill у нас заполняется нулями `const_var`.

И в последнюю очередь, уже в рантайме, динамически инициализируется `const_var`.

```	
	.section	__TEXT,__StaticInit,regular,pure_instructions
	.p2align	4, 0x90                         ## -- Begin function __cxx_global_var_init
___cxx_global_var_init:                 ## @__cxx_global_var_init
	.cfi_startproc
## %bb.0:
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register %rbp
	movsd	_const_intialized_var1(%rip), %xmm0 ## xmm0 = mem[0],zero
	movsd	%xmm0, __ZL9const_var(%rip)
	popq	%rbp
	retq
	.cfi_endproc
```

Это рантаймовая рутина, которая запускается перед вызовом main() и инициализирует `const_var`.

Тут можно довольно простую аналогию провести. Константная инициализаци выполняется для тех объектов, которые можно пометить constexpr, и, не учитывая весь остальной код, компиляция после этого успешно завершится.

Define order of your life. Stay cool.

#cppcore #compiler

Константная инициализация. Ч2

Почему я сказал, что смысл всех этих статических иницализаций сложно понять, просто читая стандарт и другие официальные источники? А вот почему.

Примерно вот такой пример они дают:

```cpp
struct S
{
	static const int static_class_var;
};

static const int const_var = 10 * S::static_class_var;
const int S::static_class_var = 5;

int main()
{
	std::cout << &const_var << std::endl; // ODR-use
	std::array<int, S::static_class_var> a1; // OK
	// std::array<int, const_var> a2; // ERROR
}
```

И говорится, что `static_class_var` на момент создания `const_var` не имеет инициализатора. А так как компилятор в первую очередь выполняет константную инициализацию, поэтому он не может сейчас установить значение для `const_var`. Поэтому в начале инициализируется `static_class_var`. И вот уже дальше - `const_var`.

Но видимо при проведении константной инициализации компилятор только один раз проходит сверху вниз программы. По факту, `static_class_var` - константа, инициализированная константным выражением. И по всем канонам должна сама стать константным выражением. Так и получается, ведь мы можем создать std::array из нее. Но вот из `const_var` - не можем. Хотя эта переменная тоже проинициализирована константным выражением. Но так, как ее инициализация происходит после константной инициализации, то этот факт не дает ей шанса стать нормальным constant expression.

Еще более интересные вещи происходят в ассемблере.

```
	.section	__TEXT,__const
	.globl	__ZN1S16static_class_varE       ## @_ZN1S16static_class_varE
	.p2align	2, 0x0
__ZN1S16static_class_varE:
	.long	5                               ## 0x5

	.p2align	2, 0x0                          ## @_ZL9const_var
__ZL9const_var:
	.long	50                              ## 0x32
```

Это внутреннее представление этих глобальных переменных. static_class_var прям глобальная, ее могу видеть и другие единицы трансляции. Поэтому она с пометкой .globl. const_var же статическая переменная, а значит ее видно видно только из текущей единицы трансляции.

И вот мы видим порядок инициализации - в начале `static_class_var` и потом `const_var`. Проблема в том, что `const_var` выглядит такой же compile-time константой, как и `static_class_var`. Хотя по идее тут должна быть какая-нибудь zero-инициализация + динамическая в рантайме.

Но компилятору в определенных случаях разрешено устанавливать начальные значения переменным в compile-time, если он уверен, что их значения не изменится на момент начала старта программы.

Этот пример и пример из прошлого поста кстати показывают, что инициализация глобальных переменных идет не совсем сверху вниз. Для каждого этап инициализации это более менее верно, но под каждый этап попадают разные подмножества переменных. Поэтому могут возникать сайд-эффекты, подобные тем, что были в этом  посте.

Accept side affects. Stay cool.

#cpcore #compiler 



Динамическая инициализация

После статической инициализации в компайлтайме идет динамическая инициализация в рантайме. Хотелось бы сказать, что хоть здесь простой и понятный порядок, но нет. Это глобальные переменные и С++, поэтому будет немного больно.

Динамическая инициализация разделяется на 3 подгруппы:

1) Неупорядоченная динамическая инициализация. Она применяется только для статических полей шаблонных классов и шаблонных переменных, которые не специализированы явно(явно специализированные шаблоны - обычные классы). И вот порядок установки значений этих сущностей вообще неопределен. Куда понравится компилятору, туда и вставит.
2) 
3) Частично упорядоченная инициализация. Применяется для всех нешаблонных инлайн переменных. Есть 2 переменные: inline переменная А и В, которая не подходит под критерии применения первой подгруппы. Если А определена во всех единицах трансляции раньше В, то и ее инициализация происходит раньше. Здесь есть одна на\*бка, которую мы увидим в примере.
4) 
5) Упорядоченная инициализация. Вот это то, что мы упоминали [тут](https://t.me/grokaemcpp/246). Все переменные со static storage duration, которые не подходят под предыдущие подгруппы, инициализируются в порядке появления их определения в единице трансляции. Между разными единицами трансляции порядок инициализации не установлен.

Давайте на простой пример посмотрим:

```cpp
struct ShowOrderHelper {
	ShowOrderHelper(int num) : data{num} {
		std::cout << "Object initialized with data " << num << std::endl;
	}
	int data;
};

static ShowOrderHelper static_var1{3};
static ShowOrderHelper static_var2{4};

struct ClassWithInlineStaticVar {
	static inline ShowOrderHelper inline_member{1};
};

inline ShowOrderHelper inline_var{2};

template <class T>
struct TemplateClassWithStaticVar {
	static ShowOrderHelper static_member;
};

template <class T>
ShowOrderHelper TemplateClassWithStaticVar<T>::static_member{27};

int main()
{
	std::cout << &TemplateClassWithStaticVar<int>::static_member.data << std::endl; // ODR-use
	std::cout << &ClassWithInlineStaticVar::inline_member.data << std::endl; // ODR-use
}
```

Возможный вывод:

```
Object initialized with data 1
Object initialized with data 2
Object initialized with data 27
Object initialized with data 3
Object initialized with data 4
```

Здесь как раз все три типа проявляются. `static_member` - статическое поле неспециализированного явно шаблона, поэтому установка ее значения в рандомном месте происходит.

Далее мы имеем уже упорядоченные вещи. `inline_member` определен раньше, чем `inline_var`, поэтому она и инициализируется раньше.

Это понятно. Но погодите: `inline_member` и `inline_var` определены позже статиков `static_var1` и `static_var2`. Какого хера они инициализирутся раньше? Это же противоречит правилам частично упорядоченной динамической инициализации!

Вот тут-то и кроется подвох: вы наверное подумали, что из факта "если V определено раньше W, то V инициализируется раньше" автоматически вытекает, что в обратном случае V инициализируется позже. Тут вас и подловили: не вытекает. Поэтому она и называется частично упорядоченной инициализацией. В обратном случае порядок неопределен.

Теперь все понятно: `inline_member` инициализируется строго раньше `inline_var`, потому что определение стоит раньше. Но, как группа inline'ов, они расположены после `static_var1` и `static_var2` и в этом случае для них значение устанавливается в неизвестном порядке. В данном случае перед всеми инициализациями.

Ну и статики `static_var1` и `static_var2` инициализируются в ожидаемом порядке из-за применения упорядоченной инициализации.

Последние несколько постов так и наровят крикнуть: "Старайтесь не делать глобальные переменные зависимыми друг от друга!". Потому что с порядком полный беспорядок, а с перекрестными зависимостями остается только надеяться, что заговор бабки-поветухи на продуктивную работу поможет не словить багов.

Decouple your program. Stay cool.

#cpcore #cpp17






Инициализация статических полей класса. Ч4

Продолжение нелегендарной истории static class members initialization. Предыдущие части [тут](https://t.me/grokaemcpp/246), [тут](https://t.me/grokaemcpp/247) и [тут](https://t.me/grokaemcpp/248).

Я немного наврал, когда сказал, что статические переменные и мемберы инициализируются до входа в main(). Как Эдгар отметил в [своем комменте](https://t.me/grokaemcpp/246?comment=3242), на самом деле тут вот что:

```
It is implementation-defined whether 
the dynamic initialization of 
a non-block non-inline variable with 
static storage duration is sequenced 
before the first statement of main or 
is deferred. If it is deferred, it 
strongly happens before any 
non-initialization odr-use of any 
non-inline function or non-inline 
variable defined in the same 
translation unit as the variable to be 
initialized. It is implementation-defined 
in which threads and at which points in 
the program such deferred dynamic 
initialization occurs.

```

Стандарт дает на откуп реализациям вопрос о том, в какой конкретно момент времени происходит динамическая инициализация глобальных объектов. Единственное ограничение, что инициализация должна произойти до любого неинициализирующего odr-use действия над неинлайн переменными и функциями, определенными в той же единице трансляции, где переменная собирается инициализироваться. То есть до любого действия по считыванию, записи, взятию адреса и созданию ссылки от переменной или функции.

Довольно сложно воспроизвести пример, когда инициализация происходит после main(), потому что мы на это напрямую не может повлиять. Поэтому может быть вот такой потенциальный пример.

```cpp
// source.cpp
int array[] = {1, 2, 3, -1};

// main.cpp
#include <cstdio>

extern int array[];

int main(void)
{
	for (int i = 0; array[i] != -1; i++) {
		printf("%d\n", i);
	}
}
```

В мейне мы говорим, что где-то определен массив интов и внутри главной функции мы печатаем его содержимое.

Проблема в том, что не понятно, произойдет ли в source.cpp инициализация array до вызова main() или после. Если после, то мы вполне можем накнуться на неинициализированную память, что UB. 

Подливает масло в огонь вот такое утверждение:
```
If no variable or function is odr-used 
from a given translation unit, the 
non-local variables defined in that 
translation unit may never be initialized
```

То есть если никакие переменные и функции не используются в юните, где переменная должна инициализироваться, ее значение вообще может быть не установлено.

Так и происходит в source.cpp.

Такие проблемы скорее свойственны программам, использующим шареные библиотеки, потому что они сами по себе в рантайме подгружаются и непонятно когда это происходит. Да и стандарт никак не упоминает эти библиотеки, поэтому здесь большой простор для фантазии и поведения реализации.

Avoid dangerous situations with no gain. Stay cool.

#cppcore 



Вот когда точно статики инициализируются после main

Все-таки есть стопроцентный способ создать условия, чтобы этот эффект проявился.

Как вы знаете, есть 2 вида библиотек: статические и динамические. Код статических библиотек вставляется в основной код в то время, как код динамических библиотек подгружается в рантайме.

Так вот есть способы в любой момент исполнения программы руками подгрузить shared library и использовать ее символы, даже ничего не зная о ней на этапе линковки объектников!

На юниксах это системный вызов dlopen. Он принимает путь к библиотеки и возвращает ее хэндл. Через этот хэндл можно получать указатели на сущности из либы.

Естественно, что раз бинарник ничего не знал о сущностях библиотеки до ее explicit подгрузки, а библиотека просто лежала камнем в файловой системе, то буквально никакой код библиотеки не может быть выполнен до ее подгрузки. А значит, если мы открываем либу в main(), то только в этот момент начинается вся динамическая инициализация сущностей либы. А значит значение ее переменных со static storage duration устанавливается после входа в main()!

Минимальный пример:

```cpp
// lib.cpp
struct CreationMomentShower {
	Helper(int num=0) : data{num} {
		std::cout << "Created object with data " << num << std::endl;
	}
	int data;
};

struct Use {
	static inline CreationMomentShower help{6};
};

// main.cpp
#include <iostream>
#include <dlfcn.h>

int main()
{
	std::cout << "Main has already started" << std::endl;
	void* libraryHandle = dlopen("libsource.so", RTLD_NOW);
	if (libraryHandle == nullptr) {
		std::cerr << dlerror() << std::endl;
		return 1;
	}
	dlclose(libraryHandle);
}
```

Вывод:

```
Main has already started
Created object with data 6
```

Чтобы запустить это дело(на примере gcc), нужно:
1) Скомпилировать объектный файл из source.cpp g++ -c -fpic -std=c++17 source.cpp
2) Превратить его в библиотеку g++ -shared -o libsource.so source.o
3) Скомпилировать main.cpp g++ -o test main.cpp -std=c++17
4) Запустить ./test

Важно отметить, что о существовании библиотеки исполняемый файл test вообще не в курсе. Также не нужно добавлять путь до либы в какой-нибудь $LD_LIBRARY_PATH.

Если библиотеку сликовать с бинарем сразу же и подгружать ее неявно, то порядок инициализации будет снова неопределен в соотвествии с предыдущим постом. Поэтому скорее всего такого эффекта в этом случае не будет.

Вот такие интересности существуют в мире инициализации статиков.

Dig deeper. Stay cool.

#compiler 




Static initialization order fiasco

Добрались мы наконец-то до этого мерзопакостного явления. По сути, про статики мы говорили ради нескольких тем и эта одна из них.

В чем суть. Как вы уже поняли, что с порядком инициализации у статиков все очень плохо. Но внутри одной единицы трансляции он хотя бы определен и предсказуем! С божественными способностями предсказания, конечно. Ну или с томиком стандарта и нашими статьями под рукой. Но он этот порядок хотя бы какой-то есть. Один раз нормально сделай и можно надеяться на обратную совместимость языка, что все будет работать как надо.

Но вот между разными юнитами трансляции порядок вообще не определен.

Static initialization order fiasco отсылается к неопределенности в порядке, в котором инициализируются объекты со статической продолжительностью хранения в разных единицах трансляции. Если мы пытаемся создать объект в одном юните, который полагается на существующий объект в другом, то мы можем знатно утяжелить штаны, если получится так, что объект еще не существует. То есть он просто zero-инициализирован. В общем случае, поведение в такой программе неопределено.

Простейший воспроизводимый пример:

```cpp
// source.cpp
int quad(int n) {
	return n * n;
}

auto staticA = quad(5);

// main.cpp
#include <iostream>

extern int staticA;
auto staticB = staticA;

int main() {
	std::cout << "staticB: " << staticB << std::endl;
}
```

Если скомпилировать это дело как: `g++ main.cpp source.cpp`, то результат будет такой:

``staticB: 0``

А если файлы передать в другом порядке: `g++ source.cpp main.cpp`, то такой:

``staticB: 25``

Очевидно, что результат зависит от того, в каком порядке линкер увидит единицы трансляции. И это зашквар!

GCC версии до 4.7 инициализировал единицы трансляции в обратном порядке их появления в строке линковки. И в один момент это поведение поменялось на обратное, что с хренам поломало кучу проектов, которые были завязаны на инициализации именно в таком порядке.

Кстати, линкер инициализирирует единицы трансляции не в рандомном порядке. Есть разные способы: в алфавитном порядке, в передаваемом ему на вход порядке и так далее. То есть система есть, но у каждого она своя.

Это можно видеть даже на нашем примере: 

В первом случае `staticB` равен нулю, потому что main.cpp стоит первым в строке компиляции и линкер инициализирует глобальные переменные этой единицы трансляции первыми. А так как на этот момент `staticA` не получила своего окончательного значения, а была лишь [zero-инициализирована](https://t.me/grokaemcpp/260), то `staticB` инициализируется нулем.

Во втором случае source.cpp инициализируется первым и теперь все в правильном порядке. `staticB` получает свое значение от уже инициализированного `staticA`.


На эти порядке ни в коем случае нельзя надеяться! Опять же пример с гцц говорит нам, что неследование стандарту чревато надеванием кастрюли на голову и ударами по ней поварешкой.Но для понимания процессов, это примерно так происходит.

Define the order of your life. Stay cool.

#cppcore #NONSTANDARD 



Еще одно отличие С от С++

Это вот прям такое, мажорное отличие. Скажете его на собесе - все охренеют, вам руку пожмут через вебку и возьмут вас на работу сразу же.

В языке С нет проблемы Static initialization order fiasco!

Как же так? В С тоже есть статики и тоже есть разные единицы трансляции. Почему так?

```
All the expressions in an initializer for an object that has static storage duration or in an initializer list for an object that has aggregate or union type shall be constant expressions.
```


Таким образом, статическая переменная со скалярным типом может быть инициализирована только константным выражением. Это не constexpr, а просто выражение, которое компилятор в состоянии вычислить в рантайме. Если тип переменной представляет собой массив со скалярным типом элемента, то каждый инициализатор должен быть константным выражением и так далее. Поскольку такие выражения не могут ни вызывать побочных эффектов, ни зависеть от побочных эффектов, вызванных любыми другими вычислениями, изменение порядка вычисление константных выражений не влияет на результат.  А значит и никакого фиаско нет!

Единственные неконстантные выражения, которые могут быть вычислены перед main, - это те, которые вызываются из среды выполнения C. Вот почему объекты FILE, на которые указывают stdin, stdout и stderr, уже доступны для использования сразу же после начала main. 

Стандартный C не позволяет пользователям регистрировать свой собственный код запуска перед основным, хотя GCC предоставляет расширение под названием \_\_constructor\_\_ (возможна массонская связь с конструкторами из C++), которое вы можете использовать для воссоздания SIOF в C. Но это, как говорится, НЕСТАНДАРТ и у каждого свой путь в могилу.

Целью Страуструпа было сделать пользовательские типы пригодными для использования везде, где есть встроенные типы. Это означало, что C++ должен был разрешать глобальные переменные типа класса, что означает, что их конструкторы будут вызываться во время запуска программы. Поскольку в начале C++ не было функций constexpr, такие вызовы конструкторов никогда не могли быть постоянными выражениями. И так, родилось чудовище, погубившее много наших ребят - Static initialization order fiasco.

В процессе стандартизации C++ вопрос о порядке выполнения статической инициализации был спорной темой. Я думаю, что большинство наших читателей согласятся с тем, что идеальная ситуация заключается в том, чтобы каждая статическая переменная была инициализирована до ее использования. К сожалению, для этого требуется технология компоновки, которой в те дни не существовало (и, вероятно, до сих пор не существует?). Инициализация статической переменной может включать вызовы функций, и эти функции могут быть определены в другой TU, что означает, что вам нужно будет выполнить анализ всей программы, чтобы успешно отсортировать статические переменные в порядке зависимостей. Стоит отметить, что даже если бы C++ мог быть разработан таким образом, он все равно не полностью предотвратил бы проблемы с порядком инициализации. Представьте, если бы у вас была какая-то библиотека, где предварительным условием функции использования было то, что функция init() была вызвана в какой-то момент в прошлом и повлияла на нужную для инициализацию переменную. Компилятор не может увидеть такие зависимости, которые есть только у программиста в голове. По коду этого совсем не видно. Поэтому, думаю, что даже полноценный анализ кода не помог бы решить проблему.

В конечном счете, ограниченные гарантии порядка инициализации, которые мы получили в C++98, были лучшими, которые мы могли получить в данных обстоятельствах. С помощью народного "а сделали бы по-человечески", возможно, многие из нас высказали пару ласковых о том, что тот стандарт не был полным без функций constexpr и что статические переменные должны иметь только константную инициализацию. Но такого рода размышления надо оставить это нытикам и нюням. А настоящие программисты прогают на том, что есть. В тех условиях, в которых возможно.

Don't complain to your life. Work on it and stay cool.

#cppcore #goodoldc 


Решение static initialization order fiasco

Раз есть проблема - должно быть и решение. Сегодня поговорим о паре-тройке вариантов. Пост вдохновлен [этим комментом](https://t.me/c/2009887601/3248) нашего подписчика Антона.

Очевидно, что в комментах немного поразгоняли эту тему. Поэтому вот небольшое саммари, плюс немного от себя.

1) Самое очевидное - дропнуть дурнопахнущие статики. Ну или стараться по-максимуму уменьшать их количество. Человечество давно осознало, что глобальные переменные - зло, а со злом нужно бороться и побеждать его. Используйте ООП, группируйте данные вместе. И не ленитесь передавать объекты в функции. И это поможет вам избавиться о большинства глобальных переменных. Способ, я бы сказал, идеальный. Но наш мир таковым не является и в реальном коде будут продолжать жить статики и надо уметь с ними правильно обходиться.
   
2)  Делайте свои глобальные объекты constexpr. Глобальные изменяемые объекты - зло. Но вот умные константы, для которых можно проводить вычисления на этапе компиляции - нормальная тема. Константны в коде так или иначе нужны, а в современных стандартах много уделяется внимания вычислениям на этапе компиляции и не зря. Вряд ли вам на этапе инициализации программы нужно делать что-то суперсложное, зависящее от внешнего мира. Зачастую, много чего можно вычислить в compile-time и не заботиться об опасностях динамической инициализации. К тому же их инициализация безопасна и предсказуема.
   
3) Иметь один хэдэр со всеми глобальными переменными и определить их все в одной единице трансляции. В пределах единицы трансляции порядок полностью определен, поэтому никаких проблем не будет. Однако есть один момент, что это решение будет сильно связывать друг с другом несвязанный по смыслу код. Держать все переменные в одном месте может показаться удобным на первый взгляд. Это еще сильнее развязывает руки разработчикам в плане увеличения количества связей между переменными. И в будущем распутывать эти связи будет еще сложнее. Да и разрабатывать сложнее. Удобно, когда код разбит на модули и каждый модуль максимально изолирован от остальных, чтобы не провоцировать мерж конфликты. А в этот суперфайл будут лезть буквально все и будут постоянные пересечения в изменениях разных разработчиков. Плюс можно так замержиться, что можно сломать логику работы глобальных переменных и все сильно пойдет по одному месту, потому что тесты хрен напишешь на них, а отлавливать баги в глобальных переменных - очень сложно.
   
4) Construct on first use idiom. Помните, как мы говорили про то, что статические локальные переменные функций инициализируются при первом вызове функции? Так вот эту особенность можно использовать, чтобы никогда не использовать объект в неинициализированном виде. Если у вас есть переменная А, инициализация которой зависит от переменной В, то есть вероятность, что В еще не инициализирована. Тогда можно переменную В обернуть в глобальную функцию-геттер, в которой эта переменная будет хранится в виде статическом локальной переменной и ее значение будет возвращаться наружу. Таким образом любое использование переменной будет проходить через вызов этой функции и нам гарантируется, что переменная создастся в момент первого вызова функции. Техника заслуживает отдельный пост, который выйдет чуть позже.


Solve your problems. Stay cool.

#cppcore 



Construct on first use idiom

Давайте здесь по-подробнее остановимся. Вещь важная.

Название говорящее и говорит оно нам, что объект будет конструироваться при первом использовании, а не когда-то заранее. То есть это [ленивые вычисления](https://t.me/grokaemcpp/207). 

Суть в том, чтобы создавать объект только в тот момент, когда он нам понадобиться. Так мы можем четко контролировать момент его инициализации. Делается это с помощью [статических локальных переменных](https://t.me/grokaemcpp/258).

Мы помним, что они инициализируются при первом вызове функции и существуют они до смерти всей программы. Таким образом, если мы из функции будем возвращать ссылку на эту переменную, то есть сделаем такой геттер, то мы функционально будем иметь глобальную переменную, для которой мы контролируем начало ее жизни.

Вернемся к примеру и посмотрим, как это выглядит. Было так:

```cpp
// source.cpp
int quad(int n) {
	return n * n;
}

auto staticA = quad(5);

// main.cpp
#include <iostream>

extern int staticA;
auto staticB = staticA;

int main() {
	std::cout << "staticB: " << staticB << std::endl;
}

```

а теперь стало так:
```cpp
// source.cpp
int quad(int n) {
	return n * n;
}

int& GetStaticA() {
	static int staticA = quad(5);
return staticA;

}

// main.cpp
#include <iostream>

int& GetStaticA();
static auto staticB = GetStaticA();

int main() {
	std::cout << "staticB: " << staticB << std::endl;
}

```

Переменная `staticB` зависит от значения `staticA` и это может вызвать проблемы, если  инициализации `staticB` произойдет первой.

Теперь следите за руками: мы берем и оборачивает переменную, задающую значение, в функцию-геттер, которая просто выдает наружу значение этой переменной. Но инициализироваться `staticA` будет ровно в момент первого вызова функции `GetStaticA`. Таким образом, мы форсим рантайм инициализировать staticA `первым` при любых обстоятельствах.

Теперь результат компиляции не зависит от порядка файлов, которые передаются на вход. Что так `g++ main.cpp source.cpp`, что так `g++ source.cpp main.cpp`, результат будет `staticB: 25`.

Если у класса есть статическое поле и создание класса зависит от этого статического поля, то попробуйте перенести это поле внутрь статической функции(пример из [этого поста](https://t.me/grokaemcpp/247)):

```cpp
using Map = std::map<std::string, std::unique_ptr<InitializationTest>>;
class InitializationTest {
public:
	static Map& GetMap() {
		static Map map;
		return map;
	}
	static bool Create(std::string ID) {
		GetMap().insert({ID, std::move(std::unique_ptr<InitializationTest>{new InitializationTest})});
		return true;
	}
	
private:
	static Map map;
	Test() = default;
};

static bool creation_result = InitializationTest::Create("qwe");

int main() {}
```

Теперь во всех местах использования бывшего статического поля, мы вызывает статический метод. Таким образом наша мапа создается ровно по первому нашему хотению и создавать статический объект класса InitializationTest теперь абсолютно безопасно.

Если у вас есть 2 статических объекта пользовательского типа и инициализация одного из них предполагает использование другого, то можно сделать так(пример нагло украден у подписчика Бобра из [этого коммента](https://t.me/grokaemcpp/247?comment=3258))

```cpp
// singleton.h
class Singleton {
public:
    static Singleton& instance() {
        static Singleton inst{};
        return inst;
    }
    int makeSomethingUsefull(){}
private:
    Singleton() = default;
};

//another_singleton.h
#include "singleton.h"

class AnotherSingleton {
public:
    static AnotherSingleton& instance() {;
        static AnotherSingleton inst{Singleton::instance().makeSomethingUsefull()};
        return inst;
    }
private:
    AnotherSingleton(int param) : data{param} {};
    int data;
};
```

 В этом примере создание объекта класса AnotherSingleton зависит от объекта Singleton. Поэтому мы запрещаем плебесам создавать объекты класса Singleton, а создаем его один раз в статической функции геттера инстанса объекта и дальше везде используем только этот инстанс.

Но и для класса AnotherSingleton мы можем предположить, что синглтоны других классов тоже будут зависеть от AnotherSingleton. Поэтому проворачиваем ту же фишку: оборачиваем создание глобального инстанса в статическую функцию класса. И заметим, что в этой функции для создания объекта AnotherSingleton мы используем инстанс класса Singleton. И неважно как там инициализируются единицы трансляции. При первом создании объекта AnotherSingleton мы форсим создание объекта Singleton и нам не страшны никакие фиаски.

Примеров много, чтобы вы понимали, как это работает в разных случаях и выявили общие паттерны поведения в таких ситуациях, чтобы в вашем конкретном случае вы смогли использовать эту идиому правильно.

Solve your problems. Stay cool.

#cppcore #goodpractice #design 



Проблема Construct on first use idiom

Предыдущий пост показывает решение проблемы static initialization order fiasco. Однако даже этот прием имеет свои проблемы.

Дело в том, что мы сильно фокусировались на инициализации объекта и решали проблемы с ней. Но как насчет разрушения объекта? Мы подумали об этом? Not really.

Давайте возьмем классы, которые могут быть использованы для создания и статических объектов и любых других.

```cpp
// ClassA.h
class ClassA {
public:
	ClassA() = default;
	// rule 5 ...
    int makeSomethingUsefull(){}
    ~ClassA() { another_global.use_it();}
};

static ClassA& GetStaticClassA() {
	static ClassA inst{};
	return inst;
}

//another_singleton.h
#include "singleton.h"

class ClassB {
public:
    ClassB(int param) : data{param} {};
    // rule 5 ...
    ~ClassB() { another_global.use_it();}
private:
    int data;
};

static ClassB& GetStaticClassB() {;
	static ClassB inst{GetStaticClassA()).makeSomethingUsefull()};
	return inst;
}
```

У нас все также 2 класса, но они уже не синглтоны, а могут создаваться в какой угодно области, просто мы оградили себя от проблемы инициализации статиков, используя construct on first use idiom. Однако замечу, что в деструкторах наших классов они используют глобальную переменную another_global. И например, для объектов с автоматическим временем жизни это вообще не проблема, они создаются и разрушаются без проблем.

Но что же будет, если так получится, что another_global удалится раньше, чем статические объекты наших классов? Правильно. Static deinitialization order fiasco. Обращение к уже разрушенному объекту - такое же UB, как и обращение к еще не инициализированному.

Кому-то очень сильно сейчас может свести багскулы, потому что логирование в деструкторах объектов, которые могут быть статиками - очень частая вещь, а соотвественно и потенциальная проблема. Подписчики могут подтвердить это в комментах.

И это проблема не идиомы в целом, а подхода к созданию объекта. Есть и другой способ это делать:

```cpp
// ClassA.h
class ClassA {
public:
	ClassA() = default;
	// rule 5 ...
    int makeSomethingUsefull(){}
    ~ClassA() { another_global.use_it();}
};

static ClassA& GetStaticClassA() {
	static ClassA* inst = new ClassA{};
	return *inst;
}

//another_singleton.h
#include "singleton.h"

class ClassB {
public:
    ClassB(int param) : data{param} {};
    // rule 5 ...
    ~ClassB() { another_global.use_it();}
private:
    int data;
};

static ClassB& GetStaticClassB() {;
	static ClassB* inst = new ClassB{GetStaticClassA()).makeSomethingUsefull()};
	return *inst;
}
```

Обратите внимание на магию. Мы внутри статических функций определяем не статические объекты, а статические указатели, к которым при первом вызове прикрепляем динамически созданные объекты. Вроде ничего кардинально не поменялось, но это на первый взгляд.

Мы никогда не вызываем delete. В конце программы разрушится только указатель, но не объект, на который он указывает. Обычно такая ситуация называется data leak, но в этом случае "вы не понимаете, это другое". Потому что при завершении программы ОС сама освобождает всю память, которая была занята программой и на самом деле ничего не утекает. Утечка памяти - это постоянное увеличение использования памяти программы со временем ее жизни. А тут мы просто один раз захватили эту память(и только эту!), но просто не отдали. Потребление памяти в течение программы не увеличивается. Как говорится: "Это норма!".

Этот вариант конечно не подойдет для тех случаев, если вам прям обязательно вызывать деструктор для всех-превсех объектов этого класса и без этого никуда. Но он совершенно точно избавит вас от потенциальных проблем деинициализации(ее просто не будет хехе), если вам не важен деструктор статических объектов.

See drawbacks of your solutions. Stay cool.

#goodpractice #design #cppcore 



Еще один способ решения Static Initialization Order Fiasco
#опытным

Предыдущий пост навел меня на еще один метод решения SIOF. Это в догонку к (ЭТОМУ ПОСТУ С РЕШЕНИЯМИ). Правда он такой, на полшишечки. 

Суть в чем. Как верно указал наш подписчик xiran в этом комментарии https://t.me/c/2009887601/5377 - управлять временем жизни глобальных динамически созданных объектов намного проще, чем временем жизни статиков. Поэтому можно объявить не статические переменные, а статические указатели. Указатель можно инициализировать nullptr и оставить его в таком состоянии хоть на месяц. И вы можете его инициализировать в любой подходящий для вас момент времени.

Это позволит вам в одном месте инициализировать связанные объекты сразу и в том порядке, в котором это не вызовет неприятных эффектов. Вы полностью контролируете ситуацию.

```cpp
// header.hpp
struct Class {
	Class(int num) : field{num} {}
	int field;
};

// source.cpp
Class * static_ptr2 = nullptr;

//main.cpp
int * static_ptr1;
extern Class * static_ptr2;

void Init() {
	static_ptr1 = new int{6};
	static_ptr2 = new Class{*static_ptr1};
}

int main() {
	Init();
	std::cout << static_ptr2->field << std::endl;
}
```

Примерно так это все выглядит. Если раньше, при обычной инициализации статиков в разных единицах трансляции, у нас порядок зависел от разумения линкера, то сейчас как ни компилируй, как ни линкуй, как ни меняй версию компилятора - все будет работать. Расширяйте этот пример как угодно, тема рабочая.

Правда тут есть одна загвоздочка, как вы могли заметить. У нас статиками являются обычные указатели и при разрушении всех статиков освободится лишь те 8 байт, которые были отведены этому указателю и никакого delete вызвано не будет. Как бы ситуация не очень, но нам и не всегда нужны эффекты от удаления статических объектов. 

Но эту загвоздочку прекрасно решает unique_ptr. При деинициализации статиков вызовется деструктор unique_ptr, который за собой потянет деструктор объекта. Тут тоже могут быть проблемы с индирекцией данных и более медленным доступом к ним, но это настолько редкий кейс с плохим дизайном, что не хочется это даже обсуждать.

```cpp
// header.hpp
struct Class {
	Class(int num) : field{num} {}
	int field;
};

// source.cpp
std::unique_ptr<Class> static_ptr2 = nullptr;

//main.cpp
std::unique_ptr<int> static_ptr1;
extern std::unique_ptr<Class> static_ptr2;

void Init() {
	static_ptr1 = std::make_unique<int>(6);
	static_ptr2 = std::make_unique<Class>(*static_ptr1);
}

int main() {
	Init();
	std::cout << static_ptr2->field << std::endl;
}
```


Вот так это выглядит в "идеале". Можете дальше пользоваться своими глобальными переменными(осуждаем), но хотя бы безопасно.

Stay safe. Stay cool.

#cpprore #cpp11 #STL #pattern



Еще одна проблема при разрушении статиков
#опытным 

Идею для поста подкинул Михаил в этом [комменте](https://t.me/c/2009887601/3232)

Суть в чем. Все глобальные переменные, не помеченные thread_local, создаются и уничтожаются в главном потоке, в котором выполняется main(). Но использовать мы их можем и в других потоках, адресное пространство-то одно. И вот здесь скрывается опасность: мы можем использовать в другом потоке глобальную переменную, которая уже была уничтожена! 

Вы просите объяснений? Их есть у меня.

Для начала нужно понять, при каких условиях мы можем получить ситуацию, при которой статическая переменная уже удалилась, программа еще не завершилась, а другой тред продолжает использовать переменную.

По пунктам

1 Статические переменные удаляются при вызове std::exit, что происходит после завершения main(). Значит, нам нужно выйти из main'а.

2 Получается, что второй поток должен продолжать выполняться даже после завершения main. Тут только один вариант: отделить тред от его объекта, чтобы его не нужно было джойнить. Делается это с помощью метода detach().

3 Использование переменной вторым потоком должно быть между разрушением глобальной переменной и завершением std::exit, потому что эта функция завершает процесс. И естественно, что после завершения процесса уже никакие потоки выполняться не могут, их просто нет.

Вот такие незамысловатые условия. Давайте посмотрим на примере.

```cpp

struct A {
	~A() {	
		std::this_thread::sleep_for(std::chrono::seconds(5));
	}
};

struct B {
	std::string str = "Use me";
	~B() {
		std::cout << "B dtor" << std::endl;;
	}
};

A global_for_waiting_inside_globals_dectruction;
B violated_global;

void Func() {
	for (int i = 0; i < 20; ++i) {
		std::cout << violated_global.str << std::endl;
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}

int main() {
	std::thread th{Func};
	th.detach();
	std::this_thread::sleep_for(std::chrono::seconds(3)); // aka some usefull work
}
```

Быстренькое пояснение. Создал 2 простеньких класса, которые позволят наглядно показать процесс удаления переменной и использования ее после удаления. Деструктор первого класса заставляет главный тред уснуть на 5 секунд, что помещает программу в опасное состояние как раз между ее завершением и разрушением статиков. Второй класс мы как раз и будем использовать для создания шаренного объекта, который использует второй тред. У него в деструкторе выводится сообщение-индикатор удаления. Давайте посмотрим на вывод:

```
Use me
Use me
Use me
B dtor
Use me
Use me
Use me
Use me
Use me
```

Поймана за хвост, паршивка! Мы используем поле удаленного объекта, что чистой воды UB!

Собсна, это еще одна причина отказываться от статических объектов в пользу инкапсуляции их в классы и прокидывания явным образом во все нужные места. Потому что даже такая базовая вещь, как логгер, может сильно подпортить жизнь.

Если я что-то упустил, то пусть Михаил меня поправит в комментах.

Avoid dangerous practices. Stay cool.

#cppcore #cpp11 #concurrency



 Double-Checked Locking Pattern. Мотивация.
 #новичкам

Михаил на ретро предложил идею посмотреть в прошлое на определенную проблему и понять, как изменялись подходы к решению проблемы. Тут не прям сильно далеко пойдем и сильно много итераций будем рассматривать, но все же. Также были запросы на многопоточку и паттерны плюсовые. Собсна, все это комбинируя с большой темой статиков, начинаем изучать паттерн Блокировки с двойной проверкой.

Начнем с того, что в стародавние времена до С++11 у нас была довольно примитивная модель памяти, которая вообще не знала о существовании потоков. И не было вот этой гарантии для статических локальных переменных:

```
...
If control enters the declaration concurrently 
while the variable is being initialized, 
the concurrent execution shall wait for 
completion of the initialization.
```

Поэтому раньше люди не могли писать такой простой код:

```cpp
Singleton& GetInstance() {
	static Singleton inst{};
	return inst;
}
```

и надеяться на то, что объект будет создаваться потокобезопасно.

Самое простое, что можно здесь придумать - влепить замок и не париться.

```cpp
class Singleton {
public:
    static Singleton* instance() {
        Lock lock;      // scope-based lock, released automatically when the function returns
	    if (inst_ptr == NULL) {
	        inst_ptr = new Singleton;
	    }
        return inst_ptr;
    }
private:
    Singleton() = default;
    static Singleton* inst_ptr;
};
```

У нас есть какая-то своя [RAII](https://t.me/grokaemcpp/29) обертка Lock над каким-то мьютексом(до С++11 ни std::mutex, ни std::lock_guard не существовало, приходилось велосипедить(ну или бустовать, кому как удобнее)). 

Обратите внимание, как это работает. Указатели автоматически [zero-инициализируются](https://t.me/grokaemcpp/260) нулем, поэтому в начале inst_ptr равен NULL. Дальше нужно проверить, если указатель еще нулевой, то значит мы ничего не проинициализировали и нужно создать объект. И делать это должен один тред. Но куда поставить лок? На весь скоуп или только внутри условия на создание объекта?

Дело в том, что может получиться так, что несколько потоков одновременно войдут в условие. Но только один из них успешно возьмет лок. Создаст объект и отпустит мьютекс. Но другие потоки-то уже вошли в условие. И когда настанет их черед выполняться, то они просто будут пересоздавать объекты и мы получим бог знает какие сайдэффекты. Плюс утечку памяти, так как изначально созданные объект потеряется навсегда. Плюс получается, что наш синглтон не такой уж и сингл...

Именно поэтому замок должен стоять с самого начала, чтобы только один поток вошел в условие. И создал объект. А все остальные потоки будут просто пользоваться этим объектом, обходя условие.

Однако теперь возникает проблема. Нам, вообще говоря, этот замок нахрен не сдался после того, как мы создали объект. Захват и освобождение мьютекса - довольно затратные операции и не хотелось бы их каждый раз выполнять, когда мы просто хотим получить доступ к нашему объекту-одиночке. И было бы очень удобно перенести этот лок в условие. Но в текущей реализации это невозможно...

Здесь-то и приходит на помощь шаблон блокировки с двойной проверкой, о котором подробнее поговорим в следующих статьях.

Solve your problems. Stay cool.

#multitasking #cppcore #cpp11



Double-Checked Locking Pattern Classic
#опытным 

Ядро идеи этого паттерна - тот факт, что решение из предыдущего поста неоптимально. Нам на самом деле нужно всего один раз взять замок для того, чтобы создать объект и потом не возвращаться к этом шагу. Если кто-то увидит, что наш указатель - ненулевой, то он даже не будет пытаться что-то делать и сразу вернется из функции.

Поэтому в паттерне блокировки с двойной проверкой, нулёвость указателя проверяется перед локом. Таким образом мы откидываем просадку производительности для подавляющего большинства вызова геттера синглтона. Однако у нас теперь остается узкое место - момент инициализации. И вот где появляется вторая проверка(всю обертку уже не буду писать для краткости.

```cpp
static Singleton* Singleton::instance() {
	if (inst_ptr == NULL) {
		Lock lock;
		if (inst_ptr == NULL) {
			inst_ptr = new Singleton;
		}
	}
	return inst_ptr;
}
```

Таким образом, даже если 2 потока войдут в первое условие и первый из них проинициализирует указатель, то второй поток будет вынужден проверить еще раз, можно ли ему создать объект. И грустный вернется из геттера, потому что ему нельзя.

Это классическая реализация, многие подписчики, думаю, видели ее. Однако от того, что она классическая, не следует, что она корректная.

Давайте посмотрим на вот эту строчку поближе:

```cpp
inst_ptr = new Singleton;
```

Что здесь происходит? На самом деле происходят 3 шага:

1) Аллокация памяти под объект.
2) Вызов его конструктора на аллоцированной памяти.
3) Присваивание inst_ptr'у нового значения.

И вот мы, как наивные чукотские мальчики, думаем, что все эти 3 шага происходят в этом конкретном порядке. А вот фигушки! Компилятор, мать его ети. Иногда он может просто взять и переставить шаги 2 и 3 местами! И вот к чему это может привести.

Давайте посмотрим эквивалентный плюсовый код, когда компилятор переставил шаги:

```cpp
static Singleton* Singleton::instance() {
	if (inst_ptr == NULL) {
		Lock lock;
		if (inst_ptr == NULL) {
			inst_ptr = // step 3
			operator new(sizeof(Singleton)); // step 1
			new(inst_ptr) Singleton; // step 2
		}
	}
	return inst_ptr;
}
```

Че здесь происходит. Здесь просто явно показаны шаги. С помощью operator new мы выделяем память(1 шаг), дальше присваиваем указатель на эту память inst_ptr'у(шаг 3). И в конце конструируем объект. И напомню, это не программист так пишет. Это эквивалентный код тому, что может сгенерировать компилятор.

И этот код совсем не эквивалентен тому, что было изначально. Потому что конструктор Singleton может кинуть исключение и очень важно, чтобы есть он это сделает, то inst_ptr останется нетронутым. А он как бы изменяется. Поэтому, в большинстве случаев, компилятору нельзя генерировать такой код. Но при определенных условиях, он может это сделать. Например, если докажет сам себе, что конструктор не может кинуть исключение. И вот тогда происходит magic.

Тред №1 входит в первое условие, берет лок и выполняет шаги 1 и 3 и потом засыпает по воле планировщика. И мы имеем состояние, когда указатель проинициализирован, а объекта на этой памяти еще нет(шаг 2 не выполнен).

Тред №2 входит в функцию, видит, что указатель ненулевой и возвращает его наружу. А внешний код потом берет и разыименовывает указатель с непроинициализированной памятью. Уупс. UB.

Что можно сделать? Вообще говоря, ничего. Если сам язык не подразумевает многопоточности, то компилятор даже не думает о таких штуках и с его точки зрения все валидно. Даже volatile предотвращает реордеринг инструкций в рамках только одного потока. Но мы же в многоядерной среде и там существуют совершенно другие эффекты, о которых "безпоточные" С и С++ в душе не знают. Завтра чуть ближе посмотрим на конкретные проблемы, при которых мы сталкиваемся, находясь в многопоточном окружении.

Criticize your solutions. Stay cool.

#multitasking #cppcore #compiler




Что опасного в многопоточке?
#новичкам

Монстры, морские чудовища, жуткие болезни... Все это снится разработчику, ломающему голову над проблемой в его многопоточном коде. Что же такого трудного для понимания и для отлавливания может произойти?

Одна из многих проблем - когерентность кэша. У нас есть много вычислительных юнитов. У каждого из них есть свой кэш. И все они шарят общее адресное пространство процесса. Кэши напрямую не связаны с другими вычислительными юнитами, только со своими. В такой архитектуре нужно четко определить механизм, по которому изменения одного кэша станут видны другому ядру. Такие механизмы есть. Например, упрощенный вариант того, что сейчас есть - модель MESI. Непростая штука и мы пока не будем разбираться в деталях. Важно вот что: на процесс, охватывающий промежуток от изменения одной кэш линии до того, как эти изменения станут доступны другому ядру, тратится время. И это не атомарная операция! То есть нет такого, что при каждом изменении кэш линии информация об этом инциденте моментально доходит до других юнитов и они тут же первым приоритетом подгружают новое значение. Это очень неэффективно. Поэтому может случиться такая ситуация, при которой переменная в одном кэше процессора уже изменилась, а в другом кэше еще осталась ее старая копия, которая используется другим процессором. Это и есть проблема когерентности кэша.

Если с одной операцией-то тяжко, то еще более bizarre ситуация становится, когда мы начинаем рассматривать две связанных операции. Представим себе 2 переменных x и y.

```cpp
struct Class {
	Class(int a, int b, int c) : x{a}, x{b}, x{c} {}
	int x;
	int y;
	int z;
};

Class * shared;

void fun() {
	shared = new Class{1, 2, 3};
}
```

Функция fun выполняется в каком-то потоке и и меняет значения переменной. Логично, что в начале выполняется создание объекта, а потом присвоение указателя. Но это актуально лишь для этого потока и так это видит соотвествующее ядро. Мы ведь в многопоточной среде, здесь убивают... 
Может произойти так, что данные в другой процессор подтянутся в обратном порядке. То есть в начале появится инициализированный указатель, указывающий на какую-то память, а потом подтянется инфа об созданном на этой памяти объекте. Вот и получается, что этот другой поток может сделать проверку:

```cpp
if (shared) 
	// do smt with object
```
И код войдет в условие, потому что указатель ненулевой. Но память по этому указателю будет еще не инициализирована. А это, друзья, наше любимое UB.

И это в точности то, что может происходить с нашим беднягой синглтоном! Если вы думаете, что lock на мьютексе вас спасет, то нет, не спасет!

Да, лок подразумевает барьеры памяти и при unlock'e изменения флашатся. Но на незащищенном чтении-то они подтягиваются без барьеров! Это был небольшой спойлер для шарящих за барьеры. О них не сегодня.

Именно поэтому даже если мы все вместе обмажемся ~~маслом и начнем бороться~~  volatile и будем везде его пихать, то это все равно не поможет. Просто природа многопоточного мира такая и с этим надо уметь работать и решать такие проблемы.

Завтра как раз об этом и поговорим.

Be able to work in multitasking mode. Stay cool.

#concurrency #cppcore 




Рабочий Double-Checked Locking Pattern
#опытным 

Мы уже довольно много говорим о нем и его проблемах. Давайте же сегодня обсудим решение.

Общее решение для проблем с когерентностью кэшей - использование барьеров памяти. Это инструкции, которые ограничивают виды переупорядочиваний операций, которые могут возникнуть при чтении и записи шареной памяти в многопроцессорной системе. 

Даже просто применительно к этому паттерну коротко, но в деталях разобрать работу барьеров - задача нереальная, потому что барьеры памяти, сами по себе, не самая простая тема для понимания. Поэтому сегодня ограничимся лишь поверхностными пояснениями, а в будущем, уже в рамках разбора модели памяти С++, будем говорить о барьерах подробнее.

```cpp
Singleton* Singleton::getInstance() {
    Singleton* tmp = m_instance;
    ...                     // insert acquire memory barrier
    if (tmp == NULL) {
        Lock lock;
        tmp = m_instance;
        if (tmp == NULL) {
            tmp = new Singleton;
            ...             // insert release memory barrier
            m_instance = tmp;
        }
    }
    return tmp;
}
```

Вот как выглядела бы более менее работающая реализация паттерна блокировки с двойной проверкой до нашей эры(до С++11). Так как в то время в языке и стандартной библиотеке не было ничего, что связано с потоками, то для барьеров приходилось использовать platform-specific инструкции, часто с ассемблерными вставками.

Acquire барьер предотвращает переупорядочивание любого чтения, которое находится сверху от него, с любыми чтением/записью, которые следуют после барьера. Одна из проблем кода без барьеров: мы можем считать ненулевой указатель в tmp, но при этом результат операции инициализации объекта к нам еще не подтянется. Мы вернем из геттера неинициализированный указатель, что UB. Именно для предотвращения такого эффекта, в данном случае такой барьер нужен сверху для того, чтобы мы подтянули инициализированный объект из кэша другого ядра в случае, если мы все-таки считали ненулевой указатель. 

Плюс он еще нужен, чтобы мы именно первой инструкцией считывали указатель и процессор не менял местами эту операцию со следующими. Может произойти так, что процессор поставит проверки всех условий перед записью указателя в tmp и это приведет к повторной инициализации синглтона.

Release барьер предотвращает переупорядочивание любого чтения/записи, которое находится сверху от него, с любой записью, которые следуют после барьера. Здесь также 2 составляющие. Первая: предотвращает переупорядочивание иницализации синглтона с присваиванием его указателя к `m_instance`. Это дает четкий порядок: в начале создаем объект, а потом `m_instance` указываем на него. Вторая гарантирует нам правильный порядок "отправки" изменений из текущего треда в точки назначения.

И вот как выглядела бы реализация этого паттерна на современном С++, если бы статические локальные переменные не гарантировали бы потокобезопасной инициализации:

```cpp
std::atomic<Singleton*> Singleton::m_instance;
std::mutex Singleton::m_mutex;

Singleton* Singleton::getInstance() {
    Singleton* tmp = m_instance.load(std::memory_order_relaxed);
    std::atomic_thread_fence(std::memory_order_acquire);
    if (tmp == nullptr) {
        std::lock_guard lock(m_mutex);
        tmp = m_instance.load(std::memory_order_relaxed);
        if (tmp == nullptr) {
            tmp = new Singleton;
            std::atomic_thread_fence(std::memory_order_release);
            m_instance.store(tmp, std::memory_order_relaxed);
        }
    }
    return tmp;
}
```

Здесь мы только на всякий случай обернули указатель синглтона в атомик указатель, чтобы полностью быть так сказать в lock-free контексте. Барьеры на своих местах, а для залочивания мьютекса используем стандартный std::lock_guard с [CTAD](https://t.me/grokaemcpp/14) из 17-х плюсов.

Ставьте шампусик, если вам заходят такие посты с многопоточкой. Думаю, редко где в ру сегменте об этом пишут.

Establish your barriers. Stay cool.

#concurrency #cpp11 #cpp17



Ассемблер инициализации статических локальных переменных
#опытным

Пример из предыдущего поста - рабочая версия паттерна. Однако, нам, вообще говоря, можно всего этого не писать. Ведь начиная с С++11 нам гарантируют тред-сэйф инициализацию статических локальных переменных и можно просто писать:

```cpp
Singleton& Singleton::getInstance() {
    static Singleton instance;
    return instance;
}
```

Мы посмотрели, как вся защита может выглядеть на уровне С++ кода. Но в примере сверху никакой защиты на этом уровне нет. А это значит, что она лежит ниже, на уровне машинных инструкций. Которые мы можем с горем-пополам прочитать в виде ассемблера. Сейчас будет очень страшно, но я попытался оставить самые важные куски и места и опустил неважное.

```asm
Singleton::getInstance():
1 	movzbl guard variable for Singleton::getInstance()::instance(%rip), %eax
2	testb %al, %al
3	je .L19
4	movl $Singleton::getInstance()::instance, %eax
5	ret
.L19:
	...
6	call __cxa_guard_acquire
7	testl %eax, %eax
8	jne .L20
.L9:
9	movl $Singleton::getInstance()::instance, %eax
10	popq %rbx
11	ret
.L20:
12	movl $Singleton::getInstance()::instance, %esi
	{Constructor}
13	movl $guard variable for Singleton::getInstance()::instance, %edi
14	call __cxa_guard_release
	{safe instance and return}

```

Так как код оперирует объектом, а не указателем, то и в ассемблере это отражено. Но да не особо это важно. Сейчас все поймете. Для удобства обращения к коду, пометил строчки номерами.

Итак, мы входим в функцию. И тут же на первой строчке у нас появляется строжевая гвардия для переменной `instance`. Гвардия защищена барьером памяти и она показывает, инициализирована уже  `instance` или нет. Так как мы без указателей, то вместо загрузки указателя и установки барьера памяти тут просто происходит загрузка гард-переменной для `instance` в регистр eax. Дальше на второй строчке мы проверяем, была ли инициализирована `instance`. al - это младший байт регистра eax. Соотвественно, если al - ноль, то инструкция testb выставляет zero-flag и в условном прыжке на 3-ей строчке мы прыгаем по метке. Если al - не ноль,  то наш синглтон уже инициализирован и мы можем вернуть его из функции. Получается, что это наша первая проверка на ноль.

На метке .L19 мы берем лок с помощью вызова cxa_guard_acquire, которая используется для залочивания мьютексов. И снова проверяем переменную-гард на пустоту(напоминаем себе, что она в eax загружена), если до сих пор она нулевая, то прыгаем в .L20. Если уже не ноль, то есть переменная инициализирована, то проваливаемся в .L9, где кладем созданную переменную в регистр возврата значения на 9-й строчке и выходим из функции(10 и 11).

На метке .L20 мы на 12-й строчке кладем наш неинициализированный синглтон в регист для последующей обработки, а именно для конструирования объекта. На 13-й строчке кладем адрес гарда в регистр, чтобы чуть позже записать туда нунелевое значение aka синглтон инициализирован. Далее мы отпускаем лок, делаем все необходимые завершающие действия и выходим из функции.

Повторю, что тут много всего пропущено для краткости и наглядности, но вы уже сейчас можете сравнить этот ассемблер с плюсовым кодом из вчерашнего поста и сразу же заметите практически однозначное соответствие. Именно так и выглядит DCLP на ассемблере.

Для пытливых читателей оставлю [ссылочку](https://godbolt.org/z/KfPW68cjr) на годболт с примером, чтобы желающие могли поиграться.






Default member initializer
#новичкам

Представьте себе большой класс, определенный целиком в одном файле. Этак строк на 300-400. Обычно принято в таком порядке описывать класс: конструкторы, деструктор, методы и только потом поля. Вариации могут быть разными, но из моей практики одного остается неизменным: конструктор и поля находятся в разных концах тела класса. И вот бывают случаи, когда при создании объекта какие-то поля получают свое значение не из внешних параметров, а какие-то заранее заданные. Дефолтовые.

И вообще было бы очень приятненько видеть значения по умолчанию полей каждый раз, когда мы встречаем их объявления в теле класса. Если бегло читать код, то часто приходится смотреть на список полей. И было бы просто удобно не возвращаться к конструкторам каждый раз, чтобы вспомнить эти значения, а иметь их сразу рядом с объявлением полей.

Такие удобства появились у нас в C++11 - default member initializer. Это именно то, что и хотелось иметь в описанных выше ситуациях. Пример

```cpp
template<typename T>
struct Stack {
	// rule of 5
	void push(const T& elem) {...}
	void push(T&& elem) {...}
	T& front() {...}
	T& front() const {...}
	void pop() {}
	T GetMinElem() {...}
private:
	std::deque<T> container;
	T min_elem{Limit<T>::max_value};
}
```

Здесь мы создает простой шаблонный класс стека с одной особенностью: в каждый момент времени вы можете из этого стека получить самое минимальное значение из тех элементов, которые содержатся в этом стеке. Кстати, вам задачка на подумать, как такое можно сделать.

Пример здесь сильно укороченный. Если реализовывать все по чесноку, то реализация такого шаблонного класса займет приличное количество места. Вариантов методов и констукторов может быть миллион. И я не очень хочу в них возвращаться, чтобы узнать, какое изначальное состояние имеет поле min_elem. А здесь мы сразу видим: у пустого стека примем значение минимального элемента, как максимально возможное значение этого типа. Тогда при добавлении в стек первого элемента для обновления минимума мы можем пользоваться тем же условием, что и для добавления остальных элементов
```cpp
if (new_elem <= min_elem)
	min_elem = new_elem;
```

Limit\<T> - шаблонный класс, который хранит максимальное и минимальное значение для заданного шаблонного типа. Это может быть реализовано как угодно: через явные специализации, через if constexpr и так далее. Шаблонная магия в общем. Кто хочет, опять же, может в комментах попрактиковаться в реализации этого класса.

Кто не знал - пользуйтесь, вещь полезная.

Stay useful. Stay cool.

#cpp11 #cppcore



Сочетание member initialization list и default member initializer
#опытным

Вот [здесь](https://t.me/grokaemcpp/241) мы поговорили о том, почему важно соблюдать порядок следования полей класса в списке инициализации конструктора. Дело в том, что вне зависимости от того, как написан этот список, поля будут инициализироваться в порядке появления их объявления.

Также в С++11 у нас появилась фича под названием default member initializer. Это та самая штуковина, которая позволяет вам инициализировать нестатические поля класса не в конструкторе, а прям inplace. Типа того:

```cpp
struct Class {
	int field = 5;
};
```

Фича полезная, многие ей часто пользуются. Но вот возникает вопрос: как список инициализации конструктора взаимодействует с default member initializer? Если я инициализирую поля вне конструктора и компилятор видит эти значения явным образом, то возможно эти поля и получают значение первыми? Сейчас все узнаем.

Посмотрим на такой пример:

```cpp
struct Char {
	Char(char c) : field{c} {std::cout << "Char " << field << std::endl;}
	Char() = default;
	char field;
};

struct TestClass {
	TestClass() : a{'1'},
				  c{'3'},
				  e{'5'} {}
	Char a;
	Char b = '2';
	Char c;
	Char d = '4';
	Char e;
};
```

Есть простенький класс Char, который выводит на консоль момент создания объекта. И тестовый класс, на котором мы и проводим эксперимент. И в этом эксперименте мы и проверим, в каком порядке свои значения получают поля `b`  и `d`, относительно `a`, `c`, `e`. 

На самом деле здесь правило ровно такое же. Нестатические поля класса инициализируются в порядке их появления в описании класса. Поэтому вывод будет таким:

```
Char 1
Char 2
Char 3
Char 4
Char 5
```

С этим разобрались.

И тут назревает вопрос: а что будет, если я в начале проициализирую поле inplace, а потом еще раз в constructor initializer list? Какая из инициализаций победит другую? Или быть может они произойдут обе в какой-то очередности?

Выглядеть это может так:

```cpp
struct Char {
	Char(char c) : field{c} {std::cout << "Char " << field << std::endl;}
	Char() = default;
	char field;
};

struct TestClass {
	TestClass() : a{'1'},
				  b{'2'},
				  c{'3'},
				  d{'4'},
				  e{'5'} {}
	Char a;
	Char b = 'b';
	Char c;
	Char d = 'd';
	Char e;
};
```

Опять в подопытные мы взяли поля `b`  и `d` и задали им значения с помощью default member initializer. А вдогонку еще и в списке инициализации присвоили им значение. 

В такой ситуации default member initializer не играет никакой роли, блаженно складывает лапки и отдает бразды правления списку инициализации. Вывод будет тем же, что и в прошлом примере:

```
Char 1
Char 2
Char 3
Char 4
Char 5
```

Но это только список инициализации так работает. Если для инициализации поля вы используете обычный конструктор, то оно первый раз проинициализируется с помощью default member initializer(которая обязательно происходит до входа в тело конструктора), а второй раз - в теле конструктора.

```cpp
struct TestClass {
	TestClass() : a{'1'},
					c{'3'},
					d{'4'},
					e{'5'} {b = '2';}
	Char a;
	Char b = 'b';
	Char c;
	Char d = 'd';
	Char e;
};
// Output

Char 1
Char b
Char 3
Char 4
Char 5
Char 2
```

Пишите в комменты, если есть еще какие-то интересные кейсы взаимодействия этих сущностей. В будущем, разберем их на канале.

Mix things properly. Stay cool.

#cpp11 #cppcore 


Member initialization. Best practices
#новичкам

Пост по запросу подписчика. Вот его [вопрос](default member initializer).

И реально ведь непонятно, что делать. Столько разных вариантов и возможностей можно придумать для инициализации полей класса, что голова ходит кругом. Какой метод самый оптимальный? Сейчас и будем разбираться.

Здесь я буду приводить какое-то общие и распространенные принципы. К каждому можно придраться и сказать "а у нас в проекте по-другому!". Исключения и другие подходы есть везде. Если хотите высказать свои варианты - комменты открыты.

Начну с того, что нужно предпочитать инициализировать поля либо с помощью списка инициализации конструктора, либо с помощью default member initializer. Дело в том, что все поля на самом деле инициализируются до входа в конструктор! Если списком инициализации или default member initializer'ом не установлено, как поле должно инициализироваться, то в конструктор оно попадет инициализированным по умолчанию. Именно поэтому, например, не можете в конструкторе инициализировать объект класса, у которого нет конструктора по умолчанию. Будет ошибка компиляции и у вас потребуют дефолтный конструктор. Запомните: конструктор нужен для нетривиальных вещей. С простой иницализацией справятся ctor initialization list и инициализатор по умолчанию.

Далее. Остается 2 способа, как инициализировать. Какой из них выбрать и в какой пропорции смешивать?

**CppCoreGuidelies говорят нам: "Prefer default member initializers to member initializers in constructors for constant initializers".**

То есть, если инициализатор константный, то используйте default member initializer.

Причина: inplace инициализатор делает явным то, что именно эти дефолтовые значения будут использоваться во всех конструкторах. Пример:

```cpp
class X { // BAD 
	int i; 
	string s; 
	int j; 
public: 
	X() :i{666}, s{"qqq"} { } // j is uninitialized 
	X(int ii) :i{ii} {} // s is "" and j is uninitialized 
	// ... 
};
```

Как в этом случае читатель кода поймет, была ли инициализация j специально пропущена(что скорее всего не очень гуд) или было ли для `s` намеренным выставление его значения в "qqq" в первом случае и в пустую строку во втором случае(почти стопроцентный баг). Все эти ошибки могут появиться при добавлении новых полей в класс. По классике: добавили новое поле, использовали его в методах, но вот в одном месте упустили инициализацию. Кейс настолько жизненный, что мое почтение.

Более адекватный вариант:
```cpp
class X2 { 
	int i {666}; 
	string s {"qqq"}; 
	int j {0}; 
public: 
	X2() = default; // all members are initialized to their defaults 
	X2(int ii) :i{ii} {} // s and j initialized to their defaults 
// ... 
};
```

Красота. Все в одном месте, все четко и понятно. Тут используется одна фишка: у вас есть несколько конструкторов, которые могут выставлять значения полям, а могут и не выставлять. Вы в одном месте определяете дефолтные значения и в списках инициализации конструкторов переопределяете инициализирующее значение для нужного поля, так как список подавляет инициализатор по умолчанию.

Также это более читаемый вариант, так как все дефолтные значения находятся в одном месте и не нужно бегать глазами по коду в их поисках.

Используйте default member initializer и будет вам счастье!

Stay happy. Stay cool.

#cpp11 #cppcore #goodpractice 
