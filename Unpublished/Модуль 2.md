
что нужно рассказать про шаблоны




1 Шаблоны функций

ОР:
- знает, как использовать ключевое слово typename для объявления шаблона функции
- понимает приоритет при выборе подходящего кандидата для вызова функции 
- применяет ключевое слово typename для определения шаблона функции


Примерная структура:
- Проблемы дублирования кода на примере sum
- С-style решение - макросы 
- Недостатки макросов. Работают со строками, нетипобезопасны
- C++ решение - шаблоны
- Шаблоны функций на примере sum. Ключевые слова typename и class.
- Шаблоны с несколькими шаблонными параметрами на примере sum от int и double.
- Шаблоны методов. Методы - такие же функции, применяются все те же правила. Пример десериализации структуры из шаблонного key-value хранилища.
- Полная специализация на примере sum(в базовом случае принимаем по константной ссылке, а в специализированном - по значению, что более эффективно для интов).
- Перегрузка шаблонных функций.
- Порядок разрешения перегрузок.



2 Шаблоны классов и переменных

ОРы:
- знает, когда необходима частичная специализация.
- Понимает особенные возможности в реализации шаблонов классов, функций и переменных.(прим. какие виды шаблонов могут быть полностью и частично специализированы, для кого можно определять шаблоны по умолчанию и тд).
- применяет ключевое слово typename для определения шаблона переменной.
- применяет шаблон класса и шаблон функции совместно.


Примерная структура
- Шаблоны классов на примере класса Stack. (прим. Примерно скопипастить интерфейс стандартной библиотеки std::stack).
-  Шаблоны переменных. (На примере дефолтного инициализатора для различных типов).
- Шаблоны по умолчанию. В прошлом примере со стеком поставить по умолчанию std::deque. Шаблонные параметры по умолчанию также есть у шаблонов функций и переменных.
- Полная специализация также доступна для шаблонов класса и переменных. Полная специализация класса на примере array для bool. Пример полной специализации переменной - дефолтный инициализатор для любых классов без конструктора по умолчанию(цвета, даты).
-  Частичная специализация. Пример простого умного указателя типа unique_ptr для T и для T[]. Пример частичной специализации инициализатора для указателей(nullptr).Частичная специализация только у классов и переменных.
- Полностью и частично специализированные классы - совершенно другие типы, у них можно полностью менять содержимое.


Совместный пример - шаблонный класс span с несколькими шаблонными конструкторами


3 Еще о шаблонах

ОРы:
- понимает, как применять trailing return type, decltype и std::forward для реализации шаблона функции.
- применяет CTAD и deduction guide для того, чтобы явно не указывать шаблонные параметры класса.
- понимает последствия помещения определения шаблонов в заголовочные файлы.
- понимает особенности применения явной инстанциации.


Примерная структура:
- Вывод типов. Отличия вывода типов auto. Тут скорее по верхам, чтобы студент суть уловил. Без деталей, как у Майерса, чтобы все успеть.
- Универсальные ссылки. Не всегда они работают в методах, только когда есть контекст вывода типов. То есть метод сам должен быть шаблонным.
- Проблема передачи правильного типа во внутренние вызовы. std::forward. 
- Ограничения auto. Вывод типов с помощью decltype.
- Зависимые типы
- Вывод типа возвращаемого значения функции. trailing return type на примере функции sub. Для дат нужен другой тип. auto возвращаемое значение.
- auto аргументы
- CTAD. Раньше нужны были функции аля std::make_pair, чтобы не писать шаблонные параметры. Теперь этого можно не делать. Компилятору помогают Deduction guides.
- Шаблоны - это не полноценный код, их нужно обязательно инстанцировать. Явное, неявное инстанцирование, extern template. 
- В каких случаях код шаблонов должен находиться в хэдэрах


```cpp
template <typename Container, typename T>
auto insert_element(Container&& container, T&& value) 
    -> decltype(container.insert(std::forward<T>(value))) {
    return container.insert(std::forward<T>(value));
}
```


```cpp
template<typename Container>
Span(Container& container);

template<typename Container>
Span(const Container& container);

template<typename Container>
Span(const Container&) -> Span<const typename Container::value_type>;


template<typename Container>
Span(Container&) -> Span<typename Container::value_type>;
```
Дополнить Span методами для контейнеров
4 Идиомы шаблонов
- Template method pattern аля policy. Отсылка к стандартным алгоритмам. Шаблоны позволяют унифицировать все callable сущности
- Traits. Отсылки к type_traits.
- Tag dispatching
- DI с помощью шаблонов



mixin упоминаем в crtp


Идиомы вариабельных шаблонов - overloaded patter


