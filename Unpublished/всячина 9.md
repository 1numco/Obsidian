pointer to data member
#опытным 

В [этом посте](https://t.me/grokaemcpp/723) мы рассказывали о том, что с помощью ranges и и параметра проекции можно кастомизировать алгоритмы с соответствии с определенным полем класса. Например, чтобы найти в коллекции элемент с максимальным определенным полем, то можно сделать так:

```cpp
auto max = *std::ranges::max_element(payments, {}, &Payment::amount);
```

max в этом случае будет транзакцией с максимальным размером платежа.

В этой строчке используется `&Payment::amount` - указатель на поле amount в классе Payment. Но если это параметр функции, то это значение какого-то типа. Но какой тип у этого указателя?

Если про указатели на конкретные мемберы знают немногое, то это совсем дебри плюсов.

Тип указателя на поле класса определяется так:

```cpp
struct Payment {
	double amount;
	std::string category;
};

double Payment::*ptr = &Payment::amount; // Here!

Payment payment{3.14, "Groceries"};
std::cout << payment.*ptr << std::endl;
// OUTPUT:
// 3.14
```

```cpp
double Payment::*       ptr         = &Payment::amount;
// тип указателя    имя указателя    инициализатор
```

По сути это особый тип указателя, который хранит смещение поля относительно начала объекта в байтах. Это не специфицировано в стандарте, но примерно везде так работает.

Естественно, мы должны указать, на какой тип полей этот указатель может указывать. Таким образом указатель `ptr` может указывать на любое поле класса `Payment`, имеющее тип `double`. То есть:

```cpp
struct Type {
	int a;
	int b;
	float c;
};

int Type::*p = nullptr;

p = &Type::a; // OK, `a` is int
p = &Type::b; // OK, `b` is int

p = &Type::c;  // ERROR! `c` is float
```

Указателю на интовое поле нельзя присвоить указатель на флотовое. И наоборот, указатель `p` работает с любыми полями типа int.

Если вы подумали, что очень узкоспециализированная вещь, то вы правы. Чуть больше универсализации здесь могут дать шаблоны:

```cpp
// Takes pointer to any data member for any type
template<typename T, typename FieldType>
void print_field(const T& obj, FieldType T::*field) {
    std::cout << obj.*field << std::endl;
}

Payment payment{3.14, "Groceries"};
Type t(42, 69, 3.14);

print_field(payment, &Payment::amount);
print_field(payment, &Payment::category);

print_field(t, &Type::a);
print_field(t, &Type::b);
print_field(t, &Type::c);
// OUTPUT
// 3.14
// Groceries
// 42
// 69
// 3.14
```

`print_field` может печатать значение любого поля любого класса по его указателю. Обратите внимание на шаблонную сигнатуру.

Walk through the nooks and crannies. Stay cool.

#cppcore #memory 


WAT
#опытным

Спасибо, @Ivaneo, за любезно предоставленный примерчик в рамках рубрики #ЧЗХ.

Всегда ли nullptr указатель равен нулю?

Казалось бы в названии дан ответ:

```cpp
int * p = nullptr;
std::cout << std::boolalpha << (p == nullptr) << "\n";
std::cout << std::hex << std::bit_cast<std::uintptr_t>(p) << "\n";
// OUTPUT
// true
// 0
```

Но в общем случае это неправда! [Смотрим на пример](https://godbolt.org/z/d89oEaWd4):

```cpp
struct A {
    int i;
};

int main() {
    int A::* p = 0;

    std::cout << std::boolalpha << (p == nullptr) << "\n";
    std::cout << std::hex << std::bit_cast<std::uintptr_t>(p) << "\n";
    std::cout << std::boolalpha << (std::bit_cast<std::uintptr_t>(p) == 0xffffffffffffffff) << "\n";
}
// OUTPUT:
// true
// ffffffffffffffff
// true
```

nullptr указатель равен совсем не нулю, как декларировалось в начале main. 

WAT? Что за фокусы с пропажей нуля?

В недавнем посте мы рассказывали об особом типе указателя - pointer to(data)member. Этот указатель, которым и является `p` из примера, по сути хранит информацию о том, как в объекте найти нужное поле класса.

И в большинстве случаев эта информация представляет собой просто смещение поля относительно начала объекта в байтах.

Однако нулевое смещение используется для локации самого первого поля класса. Поэтому в байтовом представлении неинициализированный указатель не может быть нулем.

Вместо этого обычно используется число -1, которое в байтовом представлении как раз выглядит как все единички:

```cpp
std::cout << std::hex << static_cast<long long int>(-1) << "\n";
// OUTPUT:
// ffffffffffffffff
```

С помощью указателей на поля класса можно кстати наглядно изучать выравнивание и упаковку полей с объект:

```cpp
struct Type {
    double a;
    char b;
    float c;
    long long d;
    short e;
    unsigned f;
};

std::cout << std::dec << std::bit_cast<std::uintptr_t>(&Type::a) << "\n";
std::cout << std::dec << std::bit_cast<std::uintptr_t>(&Type::b) << "\n";
std::cout << std::dec << std::bit_cast<std::uintptr_t>(&Type::c) << "\n";
std::cout << std::dec << std::bit_cast<std::uintptr_t>(&Type::d) << "\n";
std::cout << std::dec << std::bit_cast<std::uintptr_t>(&Type::e) << "\n";
std::cout << std::dec << std::bit_cast<std::uintptr_t>(&Type::f) << "\n";

// OUTPUT:
// 0
// 8
// 12
// 16
// 24
// 28
```

Опять же, интересный уголок плюсов.

Walk through the nooks and crannies. Stay cool.

#cppcore #memory


Сколько весит объект полиморфного класса?
#новичкам 

Частый вопрос с собеседований про размеры объектов различных классов. Даже в бэкэндерских конторах, в которых никогда в жизни не учитывали эти размеры. Но такие вопросы раскрывают знание базы, а считается, что без ее знания вы не можете писать нормальный код.

У нас уже был пост про [размер объекта пустого класса](https://t.me/grokaemcpp/156). А что если это будет класс с виртуальными методами? Сколько тогда будет весить этот класс?

```cpp
struct SomeClass {
	
	virtual ~SomeClass() = default;
	
	virtual void Process() {
		std::cout << "Process" << std::endl;
	}
};
```

Мы знаем, что для каждого класса, имеющего виртуальные методы, создается глобальная таблица виртуальных функций. В ней находятся конкретные адреса виртуальных методов конкретно этого класса. И именно к ней обращаются, когда хотят порешать вопросики, какой метод вызвать.

Таблица одна на все объекты заданного класса. И им каким-то образом нужно получить доступ к этой таблице.

Учитывайте, что нельзя захардкодить эту информацию по статическому типу объекта(например SomeClass& или SomeClass*), потому что под его личиной может скрываться наследник. 

Значит надо ее класть в каждый объект. И самое простое - положить в них указатель на свою таблицу виртуальных функций. Так и делают на самом деле. Этот указатель называют vptr.

Соответственно размер класса зависит от битности системы. Для 64-бит указатель имеет размер 8 байт(64 бита) поэтому и [размер класса SomeClass будет 8 байт](https://godbolt.org/z/hzYKbvr6e).

```cpp
std::cout << sizeof(SomeClass) << std::endl;
// OUTPUT
// 8
```

Пустые наследники SomeClass кстати тоже будут иметь размер 8 из-за того, что им нужно лишь другое значения указателя.

Если вы добавите еще полей, то размер увеличится в соответствии с размером дополнительных полей и выравниванием. Если вы сделаете множественное наследование, то тоже увеличится, но об этом как-нибудь потом поговорим.

Be lightweight. Stay cool.

#cppcore #interview 


join
#опытным 

Как прекрасно сделан в питоне метод join у строки. Чтобы соединить список строк разделителем нужно просто написать:

```python
my_list = ["John", "Peter", "Vicky"]
x = " ".join(myTuple)
print(x)
# OUTPUT
# John Peter Vicky
```

И как же сложно того же результата достичь в плюсах!

То делают через потоки:

```cpp
std::string join(const std::vector<std::string>& vec, const std::string& delimiter) {
    if (vec.empty()) return "";
    
    std::ostringstream oss;
    oss << vec[0];
    
    for (size_t i = 1; i < vec.size(); ++i) {
        oss << delimiter << vec[i];
    }
    
    return oss.str();
}
```

то через std::accumutate:

```cpp
std::string join(const std::vector<std::string>& vec, const std::string& delimiter) {
    if (vec.empty()) return "";
    
    return std::accumulate(
        std::next(vec.begin()), vec.end(),
        vec[0],
        [&delimiter](const std::string& a, const std::string& b) {
            return a + delimiter + b;
        }
    );
}
```

Ну вы что! Стандартная строка же себе не может позволить иметь метод join, принимающий коллекцию строк и возвращающий объединенную строку с разделителями. Это же не универсально и никому не надо...

Но в С++23 наконец-то появилось хоть что-то похожее на адекватное решение. Используем std::views::join_with:

```cpp
std::string join(const std::vector<std::string> &vec,
                 const std::string &delimiter) {
    return vec | std::views::join_with(delimiter) |
           std::ranges::to<std::string>();
}
```

Можете обмазать все это шаблонами с головы до пят, чтобы получить универсальное решение, либо использовать прям inplace, код и так довольно понятный.

И жизнь стала чуть-чуть счастливее...

Make thing simple. Stay cool.

#cpp23



Уплощаем многомерный массив
#опытным 

Иногда у вас есть коллекция элементов, для каждого из которых вы выполняете операцию, возвращающую вектор значений:

```cpp
std::vector<int> Process(const std::string& str);

std::vector<std::string> elems = ...;

auto result_view = elems | std::views::transform([](const std::string& str) {
	return Process(str);
})
```

Итоговое отображение result - это по факту набор векторов, как из него удобно получить плоский вектор интов?

С помощью С++20 отображения std::views::join:

```cpp
std::vector<int> Process(const std::string& str);

std::vector<std::string> elems = ...;

auto result = elems | std::views::transform([](const std::string &str) {
                      return Process(str);
                  }) |
                  std::views::join | std::ranges::to<std::vector>();

std::print("{}", result);
```

Это все сработает и на экране появлятся заветные чиселки

Если у вас элементы, которые хотелось бы переместить, а не скопировать, то можно добавить еще отображение as_rvalue:

```cpp
auto result = elems | std::views::transform([](const std::string &str) {
                      return Process(str);
                  }) |
                  std::views::join | std::views::as_rvalue |
                  std::ranges::to<std::vector>();
```

Если хочется чистого кода без циклов, то рэнджи для этого и сделаны.

Don't stuck in a loop. Stay cool.

#cpp20


Константная мапа
#новичкам 

Определяете вы какое-нибудь отображение в коде:

```cpp
using CommandCreator = std::function<std::unique_ptr<ICommand>(const std::vector<std::string>&)>;
const std::unordered_map<std::string, CommandCreator> commands = {
	{"create", [](const std::vector<std::string>& vec){return std::make_unique<CreateCommand>(vec)}},
	{"delete", [](const std::vector<std::string>& vec){return std::make_unique<DeleteCommand>(vec)}},
	{"save", [](const std::vector<std::string>& vec){return std::make_unique<SaveCommand>(vec)}}
};
```

Никаких больше команд вы не обрабатываете, отображение константно.

И вот вы хотите получить доступ к элементам мапы:

```cpp
auto command = commands[command_name](vec);
command->Execute();
```

И тут бац! И ошибка компиляции о том, что нет такого оператора[], который бы принимал константную std::unordered_map.

Почему так? У вектора же есть.

Проблема тут комплексная.

[Здесь](https://t.me/grokaemcpp/574) мы рассказали о том, что operator[] у мапы имеет одну особенность. Если вы ему передаете новый ключ, то он изменяет мапу и вставляет в нее элемент с этим новым ключом и дефолтным значением.

Это сделано по всей видимости по причине универсализации поведения между операторами[] для большинства контейнеров. Обычно operator[] не бросает никаких исключений. Он может приводить к неопределенному поведению, как например у вектора при доступе за границу массива. Но он не бросает. 
И в случае мапы не очень понятно, что делать, если переданного ключа нет, бросать нельзя и хочется сохранить идентичность интерфейса по всему STL с возвратом ссылки.
Вот и решили конструировать объект налету.

Но для константного оператора вообще непонятно, что делать, если ключа нет, бросать нельзя, нужно возвращать ссылку, да еще и изменять мапу нельзя. Поэтому решили проблему гениально: вообще не вводить эту версию оператора.

В условиях отсутствия константного operator[] для std::map и std::unordered_map вы можете использовать либо метод at(), который бросает std::out_of_range, если ключа нет. Или find(), который вернет итератор на конец мапы в этом же случае:

```cpp
auto command = commands.at(command_name)(vec);
command->Execute();
// or
if (auto it = commands.find(command_name); it != commands.emd()) {
	auto command = it->second();
	command->Execute();
} else {
	std::cout << "ERROR" << std::endl;
}
```

Find compromis. Stay cool.

#STL


WAT
#опытным 

Спасибо, @Ivaneo, за любезно предоставленный примерчик в рамках рубрики #ЧЗХ.

"Век живи - век учись" - сказал Луций Сенека.

"Век живи - век учи С++" - реалии нашей жизни.

Просто посмотрите на следующий код:

```cpp
struct Foo
{
	void Bar();
};

void Foo::Foo::Foo::Foo::Foo::Foo::Foo::Foo::Foo::Foo::Foo::Foo::Bar()
{
    printf("Foofoo!");
}

int main()
{
    Foo f;
    f.Bar();
    return 0;
}
```

И он [компилируется](https://godbolt.org/z/ddhdbfKMj).

WAT?

Это называется injected class name. Имя класса доступно из скоупа этого же класса. Так сделано для того, чтобы поиск имени `X` внутри класса `X` всегда разрешался именно в этот класс

Такое поведение может быть полезно в таком сценарии:

```cpp
void X() { }
class X {
public:
	static X Сreate() { return X(); }
};
```

injected class name гарантирует, что из метода `Сreate` будет возвращен именно инстанс класса Х, а не результат вызова функции Х.

Это также полезно внутри шаблонов классов, где имя класса можно использовать без списка аргументов шаблона, например, используя просто Foo вместо полного идентификатора шаблона Foo<blah, blah, blah>.

Ну и побочным эффектом такого поведения является возможность написания длиннющей цепочки из имен класса.

Так что это не у вас в глазах двоится, это плюсы такие шебутные)

Find yourself within. Stay cool.

#cppcore


Как динамически выделить память на стеке?
#опытным 

В книжке "Вредные советы для С++ программистов" от PVS-студии есть такой вредный совет: массив на стеке - это лучшее решение.

Типа выделение памяти в куче - это зло. char c[256] хватит всем, а если не хватит, то потом поменяем на 512. В крайнем случае – на 1024.

Да, использование буферов, фиксированного размера действительно ведет в проблемам в коде. Запилили новую фичу, изменили размер данных, а забыли поменять размер массива. Пожалуйста, UB.

Но возникает вопрос: а как тогда можно динамически выделять память на стеке? Ведь стандартные C-style массивы работают только с известными в compile-time размерами.

Пара способов есть, но они с "нюансом":

- Variable Length Array. Вы просто берете и создаете массив переменного размера:

```cpp
void foo(size_t n) {
	float array[n];
	// ....
}
```

Круто!

Да, но это не часть стандарта С++) Это фича языка С, доступная с С99. Однако GCC например поддерживает ее, как компиляторное расширение языка и вы сможете g++'ом сгенерировать код выше.

- alloca. Функция, которая аллоцирует заданное количество байт на стеке:

```cpp
void *alloca(size_t size);

void foo(size_t n) {
	float *array = (float)alloca(sizeof(float) * n);
}
```

Память, выделенная alloca автоматически освобождается при выходе из функции.

Эта также нестандартная функция, которая не является даже частью ANSI-C стандарта, но  поддерживается многими компиляторами(в т.ч. является частью Linux API).

Ну и на этом все.

Стандартных решений нет. И на это есть причина. Дело в том, что такой код провоцирует возникновение в программах уязвимостей.

В стандарте MISRA C есть правило MISRA-C-18.8, указывающее не использовать VLA. Другие руководства, такие как SEI CERT C Coding Standard (ARR32-C) и Common Weakness Enumeration (CWE-129), не запрещают использовать эти массивы, но призывают проверять перед созданием их размер.

Засунули в программу большой запрос и получили переполнение стека. Это вариант DoS-атаки уровня приложения.

На счет alloca вообще есть интересные интересности. Представьте себе, что будет если компилятор попытается встроить код этой функции:

```cpp
void DoSomething() {
   char* pStr = alloca(100);
   //......
}
```

в вызывающий код:

```cpp
void Process() {
   for (i = 0; i < 1000000; i++) {
     DoSomething();
   }
}
```

Так как память, выделенная alloca освобождается только после завершения функции, а не выходе из скоупа, то получает взрыв размера стека.

И теперь представьте лицо программиста, который написал этот код с учетом вызова alloca именно во фрейме функции DoSomething. 

Манипуляции со стеком - не очень безопасно, поэтому ничего такого и не вводят в плюсы.

Be safe. Stay cool.

#NONSTANDARD #goodoldc 


Двойной unlock
#опытным 

Если не пользоваться RAII, то можно наткнуться на массу проблем. Все знают про double free. Но менее известна проблема double unlock.

Все просто, вы используете ручной lock-unlock мьютекса и возможно попадаете в ситуацию двойного освобождения:

```cpp
void unsafe_function(int value) {
    mtx.lock();
    
    if (value < 0) {
        std::cout << "Error: negative value\n";
        mtx.unlock();
        // forget to return!
    }
    
    shared_data = value;
    std::cout << "Data has updated: " << shared_data << std::endl;
    
    mtx.unlock();  // second unlock
}
```

Практически всегда двойной unlock происходит из-за некорректного кода в той или иной степени. Забыть вызвать return кажется детской проблемой, но если вы например не написали тесты на эту ветку, то возможно вы наткнетесь на проблемы только в проде.

А проблемы могут быть примерно любыми. Потому что двойной unlock мьютекса - UB по стандарту. Соответственно, можете получить много непрятностей, от сегфолта до бесконечного ожидания.

Поэтому просто используйте RAII и спина болеть не будет:

```cpp
void safe_function(int value) {
    std::lock_guard lg{mtx};
    
    if (value < 0) {
        std::cout << "Error: negative value\n";
        return;
    }
    
    shared_data = value;
    std::cout << "Data has updated: " << shared_data << std::endl;
}
```

Use safe technics. Stay cool.

#concurrency #cpp11 


enum class
#новичкам

Перечисления пришли в С++ еще из С и отлично живут. Однако плюсовикам не очень с ними комфортно работать с силу наследования слабой типизации и неявных преобразований enum'ов в числовые типы и в другие enum'ы

В С++11 появился новый тип перечислений - scoped enumerations. Или ограниченные областью видимости перечисления. Определяются они так:

```cpp
enum class Enumeration {CATEGORY1, CATEGORY2, CATEGORY3};
```

Он решает две большие проблемы обычных перечислений:

- Обычные перечисления неявно преобразуются в int и обратно, что вызывает ошибки, когда не предполагается использование перечисления в качестве целого числа.

Можно например попробовать получить следующее значение перечисления, просто прибавив единицу:

```cpp
enum Color { RED, GREEN, BLUE };

Color c = RED;
Color next = c + 1;  // Implicit conversion to int and visa versa!
```

Что значит прибавить красному цвету единицу - решительно непонятно.

Неявные преобразования enum class'ов же запрещено:

```cpp
enum class Color { RED, GREEN, BLUE };

Color c = Color::RED;
Color next = c + 1; // ERROR!
```

Если вам сильно нужно преобразовать перечислитель к числу, то вы это должны сделать явно:

```cpp
Color c = Color::RED;
Color next = static_cast<Color>(static_cast<int>(c) + 1);
```

- Обычные перечисления экспортируют свои перечислители в окружающую область видимости, вызывая конфликты имён с другими сущностями в этой окружающей области:
```cpp
enum Color { RED, GREEN, BLUE };
 
enum TrafficLight { RED, YELLOW, GREEN }; // ERROR!

void graphics_library() {
    Color c = RED;
}
```

У soped enum'ов такой проблемы нет. Имена перечислителей находятся в скоупе своего перечисления:

```cpp
enum class Color1 { RED, GREEN, BLUE };
enum class Color2 { RED, GREEN, BLUE };

void graphics_library() {
    Color1 c1 = Color1::RED;
    Color2 c2 = Color2::RED;
}
```

И все прекрасно компилируется.

С учетом неймспейсов и любви к явным кастам в коммьюнити, в С++ лучше использовать enum class'ы вместо обычных перечислений.

Protect your scope. Stay cool.

#cppcore #cpp11


WAT. enum struct
#опытным 

В прошлом посте мы рассказали про enum class. И в 99.999% случаев эту сущность будут писать в коде именно, как enum class\.

Но можно написать enum struct и это тоже будет [работать](https://godbolt.org/z/KTEPq9G9j)!

```cpp
enum class FileMode { Read, Write, Append };
enum struct LogLevel { Debug, Info, Warning, Error };

int main() {
	FileMode mode = FileMode::Read;
	LogLevel level = LogLevel::Info;
	std::cout << (mode == FileMode::Read) << std::endl;
	std::cout << (level == LogLevel::Info) << std::endl;
}
```

Немного кто знает вообще о существовании такой конструкции. Свойства enum struct абсолютно аналогичны enum class и структуры перечислений были введены просто для консистентности и поддержания паритета в возможности использования двух ключевых слов.

Вот такой короткий и бесполезный факт из мира плюсов)

Be useful. Stay cool.

#fun #cpp11


Размер enum'а
#опытным 

Перечисления - это по факту именованные числа. Каждому перечислителю ставится в соответствие число, к которому перечислитель может приводиться. Оно либо указывается явно, либо проставляется компилятором.

Но тогда встает вопрос: а сколько весит enum? Мы же про эффективность и хотим, чтобы данные занимали минимально возможное пространство.

Мы можем явно написать:

```cpp
enum MY_FAVOURITE_FRUITS
{
    E_APPLE      = 0x01,
    E_WATERMELON = 0x02,
    E_COCONUT    = 0x04,
    E_STRAWBERRY = 0x08,
    E_CHERRY     = 0x10,
    E_PINEAPPLE  = 0x20,
    E_BANANA     = 0x40,
    E_MANGO      = 0x80,
    E_MY_FAVOURITE_FRUITS_FORCE8 = 0xFF // 'Force' 8bits, how can you tell?
};
```

Мы как бы явно говорим, что ограничиваем размер enum'а 8-ью битами. Но будет ли его размер реально 8 бит?

Не факт. Компилятор может выбрать любой подходящий по размеру тип, главное, чтобы он мог вместить все элементы перечисления. Это может быть char, short или int. И все это разного размера.

Неприятно, что на это нельзя было влиять.

Но прочь неприятности, потому что в С++11, помимо enum class появилась возможность указания размера scoped и unscoped enum'ов:

```cpp
enum class E_MY_FAVOURITE_FRUITS : unsigned char
{
    E_APPLE        = 0x01,
    E_WATERMELON   = 0x02,
    E_COCONUT      = 0x04,
    E_STRAWBERRY   = 0x08,
    E_CHERRY       = 0x10,
    E_PINEAPPLE    = 0x20,
    E_BANANA       = 0x40,
    E_MANGO        = 0x80,
    E_DEVIL_FRUIT  = 0xFF
};
```

И теперь вы может контролировать и сами задавать размер перечисления.

Control your size. Stay cool.

#cpp11



Удобно превращаем enum в число
#опытным 

В прошлом посте мы выяснили, что с С++11 можно самостоятельно указывать нижележащий тип, который и хранит все элементы enum'а.

Но вот представьте себе, что вам где-то нужно получить числовое представление одного из перечислителя. К какому типу кастовать?

Это важно, потому что scoped enum неявно не приводится к числам. Нам нужно явно указывать тип:

```cpp
enum class ColorMask : std::uint32_t
{
	red = 0xFF, 
	green = (red << 8), 
	blue = (green << 8), 
	alpha = (blue << 8)
};

// std::cout << ColorMask::red << std::endl; // ERROR
std::cout << static_cast<int>(ColorMask::red) << std::endl;
```

Если вам просто нужно вывести число в поток, то кастуйте к инту, ничего страшного не будет. Однако математические операции над полученным числом могут доставить неприятности, если тип будет не тот и будут использоваться сужающие-расширяющие преобразования.

Современные IDE-шки возможно будут вам показывать нужный тип, а возможно и нет. Хочется стандартного решения.

С++11 также вводит тип шаблонный тип std::underlying_type, который предоставляет зависимый тип type, содержащий подкапотный тип enum'a:

```cpp
enum e1 {};
enum class e2 {};
enum class e3 : unsigned {};
enum class e4 : int {};

constexpr bool e1_t = std::is_same_v<std::underlying_type_t<e1>, int>;
constexpr bool e2_t = std::is_same_v<std::underlying_type_t<e2>, int>;
constexpr bool e3_t = std::is_same_v<std::underlying_type_t<e3>, int>;
constexpr bool e4_t = std::is_same_v<std::underlying_type_t<e4>, int>;

std::cout
        << "underlying type for 'e1' is " << (e1_t ? "int" : "non-int") << '\n'
        << "underlying type for 'e2' is " << (e2_t ? "int" : "non-int") << '\n'
        << "underlying type for 'e3' is " << (e3_t ? "int" : "non-int") << '\n'
        << "underlying type for 'e4' is " << (e4_t ? "int" : "non-int") << '\n';

// OUTPUT
// underlying type for 'e1' is non-int
// underlying type for 'e2' is int
// underlying type for 'e3' is non-int
// underlying type for 'e4' is int
```

Соответственно, для каста нужно сделать такую штуку:

```cpp
auto num = static_cast<std::underlying_type_t<ColorMask>>(ColorMask::red);
```

Плохо, что это очень громоздкая конструкция, где к тому же типы повторяются. Поэтому в С++23 ввели хэлпер-сахарок std::to_underlying, который за нас все это делает:

```cpp
auto num = std::to_underlying(ColorMask::red);
```

Красота!

Know your type. Stay cool.

#cpp11 #cpp23


magic_enum
#опытным 

Много раз уже упоминали эту библиотечку в комментах, пора удостоить ее отдельного поста.

В чем проблема: хочется enum сериализовывать/десериализовывать в строку и из строки. То есть значение перечислителя заменить его строковым представлением в коде.

Такая задача требует рефлексии, которая в С++ только в 26 стандарте появится. Рефлексия - способность программы знать о том, как она написана на языке программирования.

Ну то есть, если у вас нет С++26, то нужно терпеть и писать костыли. Что делается обычно:

```cpp
enum class Color { RED, GREEN, BLUE };

std::unordered_map<Color, std::string> map = {{Color::RED, "RED"}, {Color::GREEN, "GREEN"}, {Color::BLUE, "BLUE"}};

std::cout << map[Color::RED] << std::endl;
```

Для больших перечислений опупеете писать эти мапы, плюс код в принципе засоряется ими.

Но на любую проблему стандартных плюсов найдется своя библиотека, которая ее решит. В этом случае пригодится magic_enum.

Это хэдэр-онли С++17 библиотечка, которая предоставляет статическую рефлексию для перечислений и работает без макросни в интерфейсе и без бойлерплейта.

Простой пример:

```cpp
Color color = Color::RED;
std::string color_name = magic_enum::enum_name(color);
assert(color_name == "RED);
```

Как это работает?

magic_enum рассчитан на работу с небольшими enum'ами. По дефолту интервал underlying значений от -128 до 127. 

Если сильно упрощенно, то magic_enum пытается инстанцировать специальную функцию для каждого значения из этого интервала. Так как шаблонный параметр будет NTTP, его значение будет вшито в саму сигнатуру функции. А ее можно получить с помощью  \_\_PRETTY_FUNCTION__ или \_\_FUNCSIG__:

```cpp
template <auto V>
constexpr std::string_view get_enum_name() {
	return extract_name(__PRETTY_FUNCTION__);
}
```

Только для реально существующих перечислителей \_\_PRETTY_FUNCTION__ будет содержать имя. Так и происходит маппинг значений перечислителей на их имена.

Вот примеры сигнатуры функции для существующего и несуществующего перечислителя:

```cpp
enum class Color { RED, GREEN, BLUE };

constexpr Color c = static_cast<Color>(4);
get_enum_name<c>(); // constexpr void get_enum_name() [with auto V = (Color)4]
get_enum_name<Color::GREEN>(); // constexpr void get_enum_name() [with auto V = Color::GREEN]
```

Чтобы это все реализовать и вместе собрать нужно еще много шаблонной магии, но суть такова.

magic_enum еще много чего умеет:

- обратный маппинг имен на значения перечисления

```cpp
std::string color_name{"GREEN"};
auto color = magic_enum::enum_cast<Color>(color_name);
if (color.has_value()) {
  // color.value() -> Color::GREEN
}
```

- доступ к элементам перечисления по индексу
```cpp
std::size_t i = 0;
Color color = magic_enum::enum_value<Color>(i);
```

- можно получить количество элементов enum'а:
```cpp
constexpr std::size_t color_count = magic_enum::enum_count<Color>();
```

- io операторы:
```cpp
using magic_enum::iostream_operators::operator<<; // out-of-the-box ostream operators for enums.
Color color = Color::BLUE;
std::cout << color << std::endl; // "BLUE"
```

и много чего еще.

Обзор фукнциональности можно найти в [репе на гитхабе](https://github.com/Neargye/magic_enum?tab=readme-ov-file). Обратите особое внимание на [ограничения библиотеки](https://github.com/Neargye/magic_enum/blob/master/doc/limitations.md).

Use magic. Stay cool.

#tools #template 


using enum
#опытным 

Scoped enum'ы - это конечно здорово. Явные преобразования, области видимости...

Давайте вот про последнее подробнее. Например, мы хотим обрабатывать http запросы:

```cpp
HttpResponse handleRequest(const HttpRequest& request) {
    if (request.method != "GET" && request.method != "POST") {
        return HttpResponse(HttpStatus::WrongMethod, "Method not allowed");
    }
    
    if (!request.headers.contains("Content-Type")) {
        return HttpResponse(HttpStatus::BadRequest, "Missing Content-Type");
    }
    
    if (request.body.size() > MAX_BODY_SIZE) {
        return HttpResponse(HttpStatus::ContentTooLarge, "Payload too large");
    }
    
    if (!authService.validateToken(request.token)) {
        return HttpResponse(HttpStatus::Unauthorized, "Unauthorized");
    }

    return Process(request);
}
```

По контексту понятно, что первым аргументом конструктора HttpResponse будет enum статуса. Но все равно продолжаем указывать скоуп перечислителей, потому что мы определили HttpStatus как enum class. Это немного засоряет код, я хочу фокусироваться на смыслах, а не на типах.

Кто-то скажет: используй обычные enum'ы и не нужно будет ничего приписывать спереди. Но тогда мы теряем все преимущества enum class'ов.

Хочется рыбку съесть, сидя на обоих стульях.

Вот можно было бы как с пространствами имен написать using EnumType...

И с С++20 так можно делать! А работает это ровно так, как ожидается:

```cpp
HttpResponse handleRequest(const HttpRequest& request) {
	using enum HttpStatus; // Here!
    if (request.method != "GET" && request.method != "POST") {
        return HttpResponse(WrongMethod, "Method not allowed");
    }
    
    if (!request.headers.contains("Content-Type")) {
        return HttpResponse(BadRequest, "Missing Content-Type");
    }
    
    if (request.body.size() > MAX_BODY_SIZE) {
        return HttpResponse(ContentTooLarge, "Payload too large");
    }
    
    if (!authService.validateToken(request.token)) {
        return HttpResponse(Unauthorized, "Unauthorized");
    }

    return Process(request);
}
```

Убралось повторение кода и можно сфокусироваться на логике.

Focus on the meaning. Stay cool.

#cpp20






Мувать не всегда дешево
#новичкам 

С приходом мув семантики настали "прекрасные плюсы будущего". Нет никакого копирования, чудо-оптимизации бороздят просторы стека и кучи. Не жизнь, а сказка.

Но мир не такой уж солнечный и приветливый. Это очень опасное...

Если вы придерживаетесь RAII, пользуетесь контейнерами и умными указателями, то вы практически никогда не определяете самостоятельно специальные методы класса и, в частности, конструктор перемещения и оператор перемещающего присваивания. Компилятор сгенерирует их за вас, ленивых дядь. 

Рано или поздно вы немного отрываетесь от "низов": вас уже не интересует КАК конкретно эти методы реализованы. Вы оперируете более высокоуровневыми сущностями и полагаетесь на компилятор.

И вот вы в ситуации, когда у вас есть данные, обернутые в класс, которые легально по контексту кода можно мувнуть или скопировать. Условно говоря, у вас есть функция Process, которая принимает данные по значению, чтобы поддержать оба варианта передачи: копирование и мув:

```cpp
void Process(Data data);
```

Что выбрать?

"Конечно мувнуть, это же не долгое копирование, выполнится быстро" - вот к таким не совсем корректным мыслям может привести "оторванность от низов".

Кажется, что у некоторых людей есть ощущение, что данные из одного объекта как-то  перетекают в другой объект и это происходит очень быстро. 

Но это не так! Перемещение - это **поверхностное копирование**. 

Возьмем простой пример:

```cpp
struct Data {
	int a;
	double b;
};

Data obj1{3, 3.14};
Dara obj2 = std::move(obj1);
```

Что будет происходить при перемещении `obj1`? Копирование `a` и `b`.

Чуть сложнее:

```cpp
struct Data {
	std::array<int, 5> arr;
};

Data obj1{.arr = {1, 2, 3, 4, 5}};
Dara obj2 = std::move(obj1);
```

Что будет при перемещении `obj1`, а значит и `arr`? Тоже копирование! std::array - это массив, фиксированного размера, расположенный на стеке. Как вы собираетесь его перемещать в другой объект? Под другой объект уже выделена своя память на стеке, вы не можете один кусок стека переместить в другой. Вы можете только скопировать значения.

Можно еще занулить конечно, что обычно этого не происходит из соображений перфоманса.

Получается, что реально "переместить" вы можете только данные, выделенные на куче. И то они никуда не перемещаются. Вы просто копируете указатель из одного объекта в другой, при этом сами данные никак не затрагиваются.

```cpp
struct Data {
	std::string * str;
	// member functions for making it work properly
};

Data obj1{.str = new std::string("Hello, World!")};
Dara obj2 = std::move(obj1);
```

`obj2` теперь имеет такое же значение указателя str, как и `obj1`, но сама строка оказалась нетронутой.

Более того. Даже если вы используете std::string, то не всегда мув будет быстрее копирования! Thanks to [SSO](https://t.me/grokaemcpp/11).

Получается, что никто никуда не течет. Все так же пресловуто копируется, кроме динамических данных под указателями.

Теперь снова актуализируем вопрос: мувать или копировать?

И ответ уже не плоскости оптимизации, а в плоскости логики кода. Перемещайте, когда вам в текущем скоупе объект больше не нужен и копируйте, если нужен. Тогда вы не пытаетесь оптимизировать код, а передаете владение объектом другому коду. Редко, когда вы на авито продаете вещи, чтобы заработать. Вы их продаете, чтобы от лишнего избавиться и дать их тем, кому они нужны, особой выгоды не ожидая. Вот здесь примерно это и должно происходить.

Think logically. Stay cool.

#cppcore #cpp11




Передача владения
#новичкам 

Захотелось совсем немного развить тему предыдущего поста.

В целом, мув семантика она не столько про оптимизацию(для этого есть например [rvo/nrvo](https://t.me/grokaemcpp/136)), сколько про передачу владения объектами. И то, что std::move ничего не мувает хорошо укладывается в эту концепцию. Не данные перемещаются, а передается владение данными. 

```cpp
void bar(std::vector<int>&& vec) {
	// do nothing
}
void foo() {
	std::vector<int> vec = {1, 2, 3};
	bar(std::move(vec));
}
```

Здесь мы передаем владение вектором из foo в bar. Заметьте, что bar оперирует правой ссылкой, то есть никакие перемещающие конструкторы не вызывались. Но такая сигнатура говорит о главном: bar ожидает эксклюзивного права владения над этим вектором. Вы должны явно мувнуть объект, чтобы вызвать bar. И не важно, что он дальше bar с этим вектором делает. Может ничего не сделает, а может и использует как-то данные. Но так решил автор кода: вызов bar предполагает передачу ему владения вектором.

Другой пример:

```cpp
std::vector<int> double_elements(std::vector<int> vec) {
    for (auto& elem: vec) {
	    elem *= 2;
    }
    return vec;
}

void foo() {
	std::vector<int> vec = {1, 2, 3};
	{
		auto doubled = double_elements(vec);
		std::println("{}", doubled);
	}
	vec.push_back(4);
	{
		auto doubled = double_elements(std::move(vec));
		std::println("{}", doubled);
	}
}

```

Функция double_elements принимает вектор по значению и возвращает набор из удвоенных элементов.

Функция foo 2 раза вызывает удвоение значений элементов. По логике функции foo, ей еще нужен vec в целости и сохранности(нужно доложить в него элемент). Поэтому она и передает vec в double_elements по значению. Но после второго вызова vec ей больше не нужен. Поэтому можно передать владение им в double_elements: возможно он им распорядится лучше.

Еще одна вещь, которая подчеркивает передачу владения: moved-from объект практически никак в общем случае нельзя безопасно использовать, кроме как безопасно разрушить или переприсвоить(в комментах под прошлым постом более конкретно обсуждали этот момент). Даже если функция принимает rvalue reference, это не значит, что она не изменяет объект: возможно внутренние вызовы это делают. 

Поэтому можно принять за правило, что, передав владение, вы больше физически не имеете права пользоваться объектом. Это как продав компанию, вы бы продолжили иметь то же влияние на нее. Нетушки. Либо крестик снимите, либо трусы наденьте. Либо передали владение и забыли, либо скопировали и дальше попользовались.

Give away what you don't need. Stay cool.

#cppcore #cpp11




![[Pasted image 20251017225433.png]]

![[Pasted image 20251019124247.png]]
Атрибуты лямбды
#опытным 

Во вчерашнем посте код с картинки реально компилируется и, если вы не поняли, что это за чертовщина, то следующие несколько постов будут для вас.

В С++11 у нас появилась возможность указывать атрибуты для функции. Например:

```cpp
[[nodiscard]] int ComplicatedCompute() {
	return 2*2;
}

ComplicatedCompute(); // you got warning: ignoring return value of 'int ComplicatedCompute()', declared with attribute `nodiscard`
```

Вы можете пометить возвращаемое значение функции, как то, которое нельзя игнорировать, и компилятор даст вам по сопатке, если вы его все же заигнорите.

Ну это функции. А как же лямбды? Хочется и для них указывать атрибуты.

И атрибуты для возвращаемого значения лямбды завезли в С++23. Выглядит это так:

```cpp
auto complicated_compute = [] [[nodiscard]] () { return 2 * 2; };

complicated_compute(); // warning: ignoring return value of 'main()::<lambda()>', declared with attribute 'nodiscard'
```

После скобок для захвата вы указываете список атрибутов в квадратных скобках. Выглядит интересно. Не очень элегантно, но интересно.

Одни скажут: "усложнение синтаксиса!". Другие скажут, что давно пора лямбды подтягивать ко всем возможностям обычных функций. 

Тут как бы все просто: не хотите - не используйте. У лямбды и так полно опциональных обвесок, одним больше, одним меньше. Можно определить шаблонную лямбду и обвесить ее всякими концептами с trailing return type. И это будет страшный зверь. Можно сделать отдельный пост, как может выглядеть ультимативная лямбда.

Ну а если вы хотите немного больше синтаксически говорить кодом, то теперь можете использовать атрибуты для лямбд.

Don't ignore. Stay cool.

#cpp23


Атрибуты везде
#опытным

Используют атрибуты не только лишь все, мало кто знает, куда их можно пихать.

Есть на самом деле 3 легальных места для навешивания атрибутов на функцию.

1 Перед типом возвращаемого значения:

```cpp
[[deprecated]] int foo() { return 42; }
```

Тогда он применяется к самой функции.

2 Перед именем функции:

```cpp
int foo [[deprecated]] () { return 42; }
```

Теперь он тоже применяется к самой функции.

3 После параметров:

```cpp
int foo() [[gnu::deprecated]] { return 42; }
```

Тогда атрибут применяется к типу функции, а не к самой функции. Разница вот в чем:

```cpp
int foo() [[gnu::deprecated]] { return 42; }

int main() {
	foo(); // no warnings
	using FuncType = decltype(foo); // use of type is deprecated
}
```

Обычный вызов функции прекрасно компилируется. Но вот использование типа функции через decltype помечается как устаревшее.

Причем gcc и clang по-разному интерпретируют эту ситуацию. Clang говорит, что gnu::deprecated нельзя применять к типам и игнорирует атрибут. Вот [ссылка на годболт](https://godbolt.org/z/Khabv1jrE) для интересующихся.

Соответственно, в лямбде в тех же местах можно ставить атрибуты:

```cpp
auto complicated_compute = [] [[nodiscard]] () [[gnu::deprecated]] {
	return 2 * 2;
};
```

Признавайтесь, знали?)

Have your own opinion. Stay cool.

#cppcore

![[Pasted image 20251204105426.png]]


Множество атрибутов
#опытным 

Если вы хотите указать несколько атрибутов для вашей функции, вы можете использовать следующий синтаксис:

1 Списочный. Внутри одних скобок перечисляете все атрибуты:

```cpp
[[gnu::always_inline, gnu::const, gnu::hot, nodiscard]] int f();
```

2 Многоскобочный. Для больших любителей квадратов. Очень больших:

```cpp
[[gnu::always_inline]] [[gnu::hot]] [[gnu::const]] [[nodiscard]] int f();
```

Больше квадратных скобок!

Также если вы используете несколько атрибутов из какого-то одного неймспейса, то можете использовать директиву using:

```cpp
[[using gnu : always_inline, const, hot]] [[nodiscard]] int f();
```

Но тогда котлеты отдельно, мухи отдельно. Все атрибуты одного неймспейса нужно уносить в отдельные скобки. Это фича С++17.

Что интересно, вы можете написать полную чупуху:

```cpp
[[crypto, is, the, best, investment]] int f();
```

И это скомпилируется! Стандарт поддерживает любые implementation-defined атрибуты. Причем неизвестные атрибуты просто игнорируются. Правда игнор спровождается варнингами, которые тем не менее можно скрыть опциями, подобным -Wno-attributes.

Таким образом, если ваш код компилируется под разные системы, то вы можете не стесняясь использовать дублирующие атрибуты, предоставляемые разными компиляторами. Так на любой платформе можно получить одинаковое поведение.

Love squares. Stay cool.

#cppcore #cpp17


Атрибуты параметров функции
#новичкам 

Атрибуты можно также применять к параметрам функции. Это помогает чуть полнее в коде для пользователей функции аннотировать некоторые свойства параметров.


```cpp
class Interface {
public:
    virtual void method(int param) = 0;
};

class Implementation : public Interface {
public:
    void method(int param) override {
        // this implementation doesn't use param so mark it
    }
};
```

Вы определили какой-то интерфейс с методом, принимающим один параметр. И в какой-то момент появилась необходимость создать наследника, реализующего этот интерфейс, однако реализации не нужен параметр param. Возможно Implementation - это какой-то мок, у которого в принципе пустая реализация.

Если вы активно используете варнинги компилятора и прочие линтеры, при попытке собрать такой код вы скорее всего увидите предупреждение/ошибку компиляции. Чтобы ее стало все чётенько, может пометить `param` атрибутом maybe_unused, тем самым явно указав компилятору, что параметр не используется намеренно. И проблема исчезнет.

Однако из стандартных атрибутов по сути имеет смысл использовать только этот самый maybe_unused. 

Атрибуты - это не только средство общения с компилятором, но и средство налаживания коммуникации между автором кода и его пользователями/читателями.

Например:

```cpp
size_t safe_strcpy(
    [[gnu::nonnull]] char* dest,
    [[gnu::nonnull]] const char* src,
    size_t dest_size
);
```

Вы поместили в хэдэр такое объявление, тем самым явно сказав пользователю и компилятору, что указатели не должны быть нулевыми. Если компилятор докажет в compile-time, что в функцию передали nullptr, то он выкинет предупреждение. Ну а пользователь четко по сигнатуре видит, что функция не ожидает нулевой указатель и как порядочный гражданин не будет его передавать.

Annotate your code. Stay cool.

#cppcore



Парсим ужас
#новичкам 

Вот мы и рассмотрели все необходимые компоненты, чтобы понять, что написано здесь:

```cpp
[[]][[]]int main()[[]]{{[][[]]([[]]auto[])[[]][[]]{{{}}}(main);}}
```

Если включить clang-format, то код преобразится во что-то такое:

```cpp
/*1*/[[]][[]] int main()/*2*/[[]] {
    {
        []/*3*/[[]](/*4*/[[]] /*5*/auto [])/*6*/[[]][[]] {
            {
                {}
            }
        }/*7*/(main);
    }
}
```

Давайте посмотрим, откуда так много скобок:

1 Перед типом возвращаемого значения main определены 2 пустые области для указания атрибутов функции main. 

2 Перед телом функции main определена пустая область для атрибутов, применяемых к типу функции main.

3 После блока захвата лямбды определена пустая область для атрибутов, применяемых к самой лямбде.

4 Внутри списка параметров лямбды определена пустая область для атрибутов, применяемых к единственному параметру лямбды.

5 Сама лямбда является generic и принимает массив неизвестного типа.

6 Перед телом лямбды определены 2 пустые области для атрибутов, применяемых к типу лямбды.

7 Вызываем лямбду с помощью указателя на функцию main.

8 Ну и разбавили это дело несколькими лишними скоупами по пути.

Не так уж и сложно оказалось)

Так, новичковая часть закончилась.
#опытным

Интересно, что этот код [компилируется](https://godbolt.org/z/o61Yzq5s4) на gcc, но не на clang. 

cppinsights показывает, что лямбда раскрывается во что-то такое:

```cpp
class __lambda_5_17
{
  public: 
  template<class type_parameter_0_0>
  inline /*constexpr */ auto operator()(auto *) const
  {
	{
	  {
	  };
	};
  }
  private: 
  template<class type_parameter_0_0>
  static inline /*constexpr */ auto __invoke(auto * __param0)
  {
	return __lambda_5_17{}.operator()<type_parameter_0_0>(__param0);
  }
  
  public:
  // /*constexpr */ __lambda_5_17() = default;
  
};
```

Как интерпретировать эту штуку - дело нетривиальное и по ходу компиляторы это делают по-разному. Видимо gcc при попытке инстанцировать шаблон с параметром int() выводит auto как тот же самый тип функции int() и в итоге лямбда принимает указатель на функцию. А clang при попытке инстанцировать шаблон выводит тип параметра функции как массив функций int() и не может принять main в качестве такого параметра.

Пишите ваше мнение, кто прав, кто виноват)

Deal with horrible things step by step. Stay cool.

#cppcore #compiler




![[Pasted image 20251022213840.png]]

Увидел тут в одной запрещенной сети такой пост с картинкой выше:

```
Пожалуй, брошу еще один камень в огород любителей длинных строк в коде.  
  
На скриншоте первый фрагмент -- это оригинальный код, а второй -- это как бы я его записал. ИМХО, разница очевидна и она не в пользу оригинального 😎  
  
Если же попытаться говорить объективно, то с кодом должно быть комфортно работать в любых условиях. Хоть на 13.3" ноутбуке, хоть на 34" 5K дисплее. А длинные строки этому физически препятствуют.
...
```

Кажется, что людям свойственно обсуждать давно решенные проблемы😅

Причем подобные вопросы(форматирование) можно вообще обсуждать сколько угодно и по каждому отдельно взятому кусочку кода. Программисты любят холивары, для некоторых день без холивара был прожит зря.

Друзья, любые вопросы по форматированию решаются настройкой clang-format. Надо его просто установить, поставить нужные правила(вот здесь можете один раз похоливарить всей командой, но один раз!) и радоваться жизни. Для vscode можно поставить расширение и настроить его, чтобы форматирование применялось на каждое сохранение файла. Ну или используйте любой другой линтер на ваш вкус.

С этого вообще должен начинаться каждый новый проект и без линтера любой старый проект превращается во франкенштейна, в котором разные части написаны в разных стилях.

А вы как считаете: разница очевидна и она не в пользу оригинального?😆

Don't reinvent the wheel. Stay cool.

#tools #goodpractice 


Оборачиваем вспять байты
#новичкам 

Когда мы низкоуровнево работаем с сетью, то надо понимать, что в данных, полученных по сети, нужно реверсировать порядок байтов, чтобы правильно интерпретировать значения. Также реверсировать порядок нужно. Это происходит из-за того, что в стеке протоколов TCP/IP принят порядок Big-endian - старший байт хранится по младшему адресу. А на большинстве хостов(десктопов и серверов) - Little-endian: младший байт хранится по младшему адресу.

Соответственно нужны функции для реверсирования байтов. Обычно для этого используют либо компиляторные интринсики:

```cpp
### GCC/Clang

uint16_t swapped16 = __builtin_bswap16(value);
uint32_t swapped32 = __builtin_bswap32(value); 
uint64_t swapped64 = __builtin_bswap64(value);

### MSVC:

uint16_t swapped16 = _byteswap_ushort(value);
uint32_t swapped32 = _byteswap_ulong(value);
uint64_t swapped64 = _byteswap_uint64(value);
```

Либо системное апи:

```cpp
#include <arpa/inet.h>  // Linux/macOS
// или
#include <winsock2.h>   // Windows

uint16_t network_to_host16 = ntohs(value);
uint16_t host_to_network16 = htons(value);

uint32_t network_to_host32 = ntohl(value);
uint32_t host_to_network32 = htonl(value);

uint64_t network_to_host64 = ntohll(value);
uint64_t host_to_network64 = htonll(value);
```

Либо какое-нибудь библиотечное решение:

```cpp
#include <boost/endian/conversion.hpp>

uint32_t value = 0x12345678;
uint32_t swapped = boost::endian::endian_reverse(value);

uint32_t to_big = boost::endian::native_to_big(value);
uint32_t to_little = boost::endian::native_to_little(value);
```

Но в С++23 появилась стандартная функция для разворачивания порядка байтов!

```cpp
template< class T >
constexpr T byteswap( T n ) noexcept;
```

Работает она только для интегральных типов и вот ее возможная реализация:

```cpp
template<std::integral T>
constexpr T byteswap(T value) noexcept
{
    static_assert(std::has_unique_object_representations_v<T>, 
                  "T may not have padding bits");
    auto value_representation = std::bit_cast<std::array<std::byte, sizeof(T)>>(value);
    std::ranges::reverse(value_representation);
    return std::bit_cast<T>(value_representation);
}
```

Результат у нее собственно ровно тот, который и ожидается:

```cpp
template<std::integral T>
void dump(T v, char term = '\n')
{
    std::cout << std::hex << std::uppercase << std::setfill('0')
              << std::setw(sizeof(T) * 2) << v << " : ";
    for (std::size_t i{}; i != sizeof(T); ++i, v >>= 8)
        std::cout << std::setw(2) << static_cast<unsigned>(T(0xFF) & v) << ' ';
    std::cout << std::dec << term;
}
 
int main()
{
    static_assert(std::byteswap('a') == 'a');
 
    std::cout << "byteswap for U16:\n";
    constexpr auto x = std::uint16_t(0xCAFE);
    dump(x);
    dump(std::byteswap(x));
 
    std::cout << "\nbyteswap for U32:\n";
    constexpr auto y = std::uint32_t(0xDEADBEEFu);
    dump(y);
    dump(std::byteswap(y));
 
    std::cout << "\nbyteswap for U64:\n";
    constexpr auto z = std::uint64_t{0x0123456789ABCDEFull};
    dump(z);
    dump(std::byteswap(z));
}

// OUTPUT
// byteswap for U16:
// CAFE : FE CA
// FECA : CA FE
 
// byteswap for U32:
// DEADBEEF : EF BE AD DE
// EFBEADDE : DE AD BE EF
 
// byteswap for U64:
// 0123456789ABCDEF : EF CD AB 89 67 45 23 01
// EFCDAB8967452301 : 01 23 45 67 89 AB CD EF
```

Как всегда стандарт запаздывает лет на 10-15-20, но хорошо, что все-таки завезли эту полезную функцию, которую можно кроссплатформенно использовать.

Use standard solutions. Stay cool.

#cpp23


Мок собеседования
#новичкам #опытным 

Представьте, что вы вкатун в АйТишку плюсовую. Прочитали несколько книжек, прошли кучу бесплатных курсов и дописали свой первый пет-проект. 

Пора бы попробовать устроиться на работу. Но учеба и учебные проекты - это одно, а собеседования - это совсем другое. Надо знать, как их проходить, это отдельная наука.

Но как узнать, как проходить собесы, если никогда их не проходил?

Для этого существуют мок-собеседования. То есть дословно "имитация" собеседования.

В идеале его проводить с живым человеком, например вашим ментором или любым другим опытным чуваком, который изъявляет желание.

Но если вы стеснительный волк-одиночка, к тому же еще и бедный(за занятия с ментором нужно платить), то и для вас есть вариант.

В сети лежит куча готовых мок-собеседований по С++ на позиции разных уровней.

На самом деле видео мок-собесов - не бомже-вариант, а маст хэв для любого человека, неуверенного в своих скиллах прохождения собеседований. Весь из себя сеньор, выходивший на рынок 10 лет назад, тоже скорее всего для себя что-то подчерпнет.

Даже в русскоязычном пространстве можно найти много таких видосов. Основные мок-интервьюеры у нас это:

- [Ambushed raccoon](https://youtube.com/@ambushedraccoon6408?si=RsmutwBq15Uoj8TM)
- [Владимир Балун](https://www.youtube.com/@vladimir_balun_programming)

Ну а мы за вас собрали подборку всех(или почти всех) мок-собесов на русском языке по С++ и разбили их по уровням.

Junior:

- https://www.youtube.com/watch?v=_-EkLLZ5svk
- https://www.youtube.com/watch?v=H1mIHJxnm9E
- https://www.youtube.com/watch?v=PQ1C_0EAHFI
- https://www.youtube.com/watch?v=BCpHj698D8U
- https://youtu.be/7g8HufwNa0g?si=XVKRsuoHN20MJx3i
- https://youtu.be/a18qTcWn-II?si=OttfqKh0bHLjueOY
- https://www.youtube.com/live/rLOgkn6xVQA?si=lFqwGf_Wsr8IohHo
- https://youtu.be/VfoxaNLVtmQ?si=elt-OyZWB5tXp5hI


Middle:

- https://www.youtube.com/watch?v=nMdNehH8-Ss
- https://www.youtube.com/watch?v=Ed37R0FvkQ8
- https://www.youtube.com/watch?v=IDqMy4_xkb4
- https://www.youtube.com/watch?v=BOUEbS5L4-8
- https://www.youtube.com/watch?v=PwVMcxCBIkg
- https://www.youtube.com/watch?v=Np6UrKN6ZbA
- https://www.youtube.com/watch?v=1Ez3kbK_3bI
- https://www.youtube.com/watch?v=s6BXbEPaw5g
- https://www.youtube.com/watch?v=yfoFtu28n4o
- https://www.youtube.com/watch?v=cT3fonCyxJk
- https://www.youtube.com/watch?v=xwb2FAKxCUo
- https://www.youtube.com/watch?v=bOgz4K-ARzQ
- https://www.youtube.com/watch?v=wR4VRCp_BYo
- https://youtu.be/5enBKMwOST0?si=i-5mdyrxeeFiZKo1


Senior:

- https://www.youtube.com/watch?v=OwMEK_W8Ysw
- https://www.youtube.com/watch?v=dZpe58HKX-8
  
Просто вопросы и задачи с собесов:

- https://www.youtube.com/watch?v=boYk6gFg84E
- https://www.youtube.com/watch?v=ViHNB0_1j90
- https://www.youtube.com/watch?v=aYM7lksQ8yg
- https://www.youtube.com/watch?v=UdY_YMFx7SY
- https://www.youtube.com/watch?v=PStQ4jhhz08
- https://www.youtube.com/watch?v=wMYfg_iPqMQ


Просмотрев эти видосы(возможно по нескольку раз) и переписав ответы на все вопросы себе в тетрадочку или файлик, вы будете знать ответы на 95% устных вопросов, которые вам будут задавать в условной компании Х. 

Возможно вы не все будете до конца понимать, но уж очень глупых ошибок точно не совершите.

Ну а для любителем native english есть канал [Кодингового Иисуса](https://www.youtube.com/@CodingJesus). Он постоянно у себя на стримах спрашивает у людей за плюсы. В основном люди валятся на простых вопросах, но практика языка вам будет точно обеспечена.

Еще раз. Смотреть эти видосы нужно примерно всем, кто задумывается о смене работы. Кому-то вспомнить, кому-то заполнить пробелы, кому-то понять, что все совсем плохо и садиться учить базу. Каждый найдет себе занятие по душе.

Practice makes perfect. Stay cool.

#interview 


Bootstrap
#новичкам 

Если вы когда-нибудь заходили в исходники своего компилятора, то могли заметить, что его исходный код написан на С++.

Также возможно вы слышали, что компилятор java написан на java.

Если вдуматься в эти факты, то невольно задаешься вопросом: а как это вообще возможно? Нельзя же себя поднять за волосы из болота.

Вообще-то барон Мюнхгаузен смог и мы сможем.

Нужно лишь немного опоры. Чуть-чуть оттолкнуться.

Давайте пройдем весь процесс от и до.

1 Вы решили написать свой язык самый лучший язык во всей вселенной P&Rust. Разработали синтаксис и правила языка, пару раз пооргазмировали от его крутости.

2 Дальше вам нужно уметь конвертировать код на новом языке в программу. Выхода нет: вы быстренько пишите простой компилятор или интерпретатор P&Rust на уже существующем языке. Пусть для определенности вы написали компилятор на С. Компилируете его каким-нибудь gcc и у вас появляется первый компилятор языка P&Rust. Это так называемый компилятор начальной загрузки или bootstrap компилятор.
Отлично! Вы можете писать программы на новом языке!

3 Но компилятор - это же тоже программа. Теперь вы можете на P&Rust написать компилятор P&Rust и скомпилировать его bootstrap компилятором. В итоге у вас получится рабочий компилятор P&Rust, написанный на языке P&Rust! Вот яйцо и родило яйцо.

4 В дальнейшем вы можете развивать компилятор, используя сам язык P&Rust и перекомпилируя его самим собой.

Весь этот процесс называется bootstrapping.

Первый компилятор и jvm были написаны на С. Первый компилятор С был написан на ассемблере. Pascal'я - на Fortran.

Интересно, что clang изначально был написан на урезанной версии С++, которая компилировалась и на gcc, и на msvc. Поэтому clang можно использовать на винде.

Преимущества бутстраппинга:

- Это демонстрирует зрелость и самодостаточность языка. Можно развиваться самостоятельно и не зависеть от других технологий.

- Разработчики компилятора могут использовать все возможности языка, для которого они пишут компилятор.

- Тестирование возможностей языка. Если вам недостаточно инструментов в языке, чтобы написать компилятор, значит язык нужно дорабатывать.

- Упрощается разработка. Не нужно знать несколько языков.

А вот как бутстрапился С++ разберем в следующем посте.

Be self-sufficient. Stay cool.

#tools #compiler


История компилятора С++
#новичкам 

С++ начал свой путь в 1979 году, когда Бьерн Страуструп работал над своей диссертацией. Он назвал его "С с классами". Это была довольно примитивная версия С++, были просто добавлены классы, их методы, возможность наследования и другие более минорные фичи. Никакого полиморфизма и шаблонов. Для компиляции этой версии было достаточно написать препроцессор для С компилятора, который бы транслировал инструкции С++ в С-шный код. Этот препроцессор + С-компилятор назывался CPre.

Но Бьерн не забросил свою разработку и в 1982 году разработал улучшенную версию С с классами и назвал ее С++. Она уже включала виртуальные функции, перегрузку функций и операторов, ссылки, стандартные функции работы с памятью(new/delete).

И CPre уже не справлялся с такими мощными фичами. Да он и изначально был довольно костыльным, потому что не было работы с типами, которой быть и не могло на этапе препроцессинга. Нужно было делать лексический и синтаксический анализ, строить ast дерево программы, чтобы поддерживать типобезопасность.

Но хотелось сохранить возможность получения С-шного кода из С++, потому что это способствовало более быстрому распространению языка и его можно было использовать в новых модулях старых проектов.

По сути нужен был полноценный компилятор, преобразующий С++ код в С. И им стал Cfront.

Вот теперь пошли интересности.

Первая версия простейшая версия языка С++ и компилятора Cfront была написана на "С с классами" и скомпилирована CPre. В дальнейшем мощные фичи в язык добавлялись уже с помощью Сfront, который писался на предыдущей версии С++. CPre не вывозил возросшей сложности.

Ну хорошо, Бьерн у себя на домашнем компьютере с определенной архитектурой имеет свежайшую версию Cfront, которая написана на С++. С++ уже не может быть скомпилирован CPre. Как получить компилятор на другой архитектуре?

Здесь помогла именно трансляция С++ в С код. При компиляции свежей версии Cfront на выходе на самом деле получается Сшный код. Если этот код чуть причесать и убрать оттуда платформозависимые решения, то можно принести его на компьютер с другой архитектурой, скомпилировать его существующим там С-компилятором и получить готовый Cfront, умеющий компилировать С++. 

Таким образом распространялись версии компилятора под разные архитектуры.

Cfront успешно развивался еще несколько лет, но у него были объективные недостатки:

- скорость компиляции в С/С++ и так не славится скорость, так тут еще и двухступенчатая компиляция была
- при попытке компиляции ошибки показывались в сгенерированном C-коде, а не в исходном C++, что затрудняло отладку.
- некоторые возможности C++ было сложно или невозможно реализовать через трансляцию в C. С не всесилен и довольно лаконичен в используемых инструментах.

В итоге при попытке добавить в язык исключения Cfront умер...

Но благо разработчики прониклись С++ и поняли, что для быстрой и полноценной работы с С++ им нужен полноценный компилятор С++ в асм. Ну а дальше начал разрастаться зоопарк плюсовых компиляторов, некоторые умирали, а некоторые дожили до наших дней.

The end.

Know that everything has its limits. Stay cool.

#tools #compiler


Наследие Cfront. this
#новичкам 

Cfront был первым компилятором С++. И это оказало большое влияние на то, какие подходы к компиляции C++ используют другие компиляторы. В следующих нескольких постах мы обсудим наследие, которое после себя оставил Cfront.

Главное, о чем надо помнить в этой серии - Cfront компилировал С++ код в С. То есть все концепции языка С++, которыми Cfront оперировал, можно было представить в С коде. Некоторые такие представления перетекли в стандарт, некоторые остались на уровне реализации.

Сегодня поговорим про такую привычную и базовую вещь, как this или неявный указатель на объект класса в методах.

Мы уже написали несколько постов о том, как можно вызывать методы классов с помощью указателя на функцию и объекта класса(или указателя на него). [Тык](https://t.me/grokaemcpp/67), [тык](https://t.me/grokaemcpp/74) и [тык](https://t.me/grokaemcpp/720). Но здесь повторим более наглядно чтоли.

Вот у Cfront на входе есть С++ код:

```cpp
class Point {
    int x, y;
public:
    Point(int x, int y) : x(x), y(y) {}
    int get_x() const { return x; }
    int get_y() const { return y; }
    void move(int dx, int dy) { x += dx; y += dy; }
};
```

У каждого класса есть конструктор, деструктор и набор методов. Все это компилировалось в обычные функции, которые первым аргументом принимали неявный указатель this на экземпляр сишной структуры:

```c
struct Point {
    int x;
    int y;
};

void Point_ctor(struct Point* this, int x, int y) {
    this->x = x;
    this->y = y;
}

int Point_get_x(const struct Point* this) {
    return this->x;
}

int Point_get_y(const struct Point* this) {
    return this->y;
}

void Point_move(struct Point* this, int dx, int dy) {
    this->x += dx;
    this->y += dy;
}

void Point_dtor(struct Point* this) {}
```

Константность метода регулировалась константностью указателя this.

Если есть класс, значит должно быть использование:

```cpp
void foo() {
	Point p = Point(1, 2);
	p.move(2, 3);
	printf("%d/n", p.get_x());
}
```

Этот код превращался в нечто подобное:

```c
void foo() {
	struct Point p;
	Point_ctor(&p, 1, 2);
	Point_move(&p, 2, 3);
	printf("%d/n", Point_get_x(&p));
	Point_dtor(&p);
}
```

Заметьте, что в конце любого скоупа, в котором был создан объект компилятором вставлялся вызов деструктора, тем самым обеспечивая идиому RAII.

Have a legacy. Stay cool.

#cppcore #goodoldc #compiler



Наследие Cfront. Наследование
#новичкам 

Сорри за тавталогию, но мимо этой темы мы не можем пройти(хотя я бы прошел, если бы не @shumilkinad, спасибо ему)

В раннем С++ уже были классы и наследование, но в С этого не было. Как же можно транслировать наследование классов в С'шный код?

Простая агрегация и никакого мошенничества. 

Все классы в С++ - это простые С-структуры с отдельным набором функций, принимающих cv-специфицированный указатель на инстанс структуры(это мы выяснили в прошлом посте). Наследники же в начале объекта хранят все поля базового класса. Так давайте просто первым полем наследника сделаем инстанс базовой структуры. Таким образом мы обеспечим вложенность объектов с любым количеством наследований.

Вот есть пара родитель-наследник:

```cpp
class Base {
public:
    int x;
    Base(int a) : x(a) {}
};

class Derived : public Base {
public:
    int y;
    int z;
    Derived(int a, int b) : Base(a), y(b) {
		z = x + y;
	}
};
```

Примерно в такой код они транслировались:

```c
struct Base {
    int x;
};

struct Derived {
    struct Base _base;  // embedded base object
    int y;
    int z;
};

/* Функции-конструкторы */

void Base_constructor(struct Base* this, int a) {
    this->x = a;
    
    // Constructor body (if presented)
}

void Derived_constructor(struct Derived* this, int a, int b) {
    // Init base object
    Base_constructor(&this->_base, a);
    
    // Init fields of derived object
    this->y = b;
    
    // Constructor body
    this->z = this->_base.x + this->y;
}
```

Первым полем структуры Derived - структура Base.

Конструкторы же - это отдельные функции. Но в С++ очень важен порядок вызовов конструкторов и деструкторов.

Поэтому конструктор самого базового класса только инициализирует свои поля и дальше выполняет инструкции из тела конструктора. При создании же наследников в начале вызывается конструктор базового класса и лишь потом инициализация полей и выполнение тела.

Разрушение же объекта выполняется в обратном порядке. Трусы снимаются только после штанов, раньше не получится.

```cpp
class Base {
public:
    ~Base() { 
        // Destructor Base body
    }
};

class Derived : public Base {
public:
    ~Derived() {
        // Destructor Derived body
    }
}
```

Превращается в:

```c
struct Base {
};

struct Derived {
    struct Base _base;

};

void Base_destructor(struct Base* this) {
    // Destructor Base body
}

void Derived_destructor(struct Derived* this) {
	// Destructors execute in reverse order
	
    // Destructor Derived body
    
    Base_destructor(&this->_base);
}
```

Новичкам особенно будет полезно понимать, как простой код С++ может быть написан на С, чтобы досканально понимать все абстракции языка и какие действия скрыты от наших глаз.

Have a legacy. Stay cool.

#cppcore #goodoldc #compiler




Наследие Cfront. Полиморфизм
#новичкам 

Часто мы говорим о каких-то вещах в С++ и можем сказать, как они работают под капотом. Но стандарт языка не говорит о том, как компиляторы должны реализовывать те или иные фичи. Он только задает требование. Тем не менее подходы к реализации некоторых фичей повторяются в разных компиляторах. И отчасти это так из-за влияния Cfront. 

Сегодня поговорим конкретно про динамический полиморфизм.

В С++ классический динамический полиморфизм подтипов синтаксически реализуется через виртуальные функции.

```cpp
class Person {
protected:
    std::string name;
    int age;

public:
    Person(const std::string &n, int a) : name(n), age(a) {}

    virtual std::string getRole() const { return "Person"; }

    virtual void describe() const {
        std::cout << name << " (" << age << " years)";
    }

    virtual ~Person() = default;
};

class Employee : public Person {
    std::string position;

public:
    Employee(const std::string &n, int a, const std::string &pos)
        : Person(n, a), position(pos) {}

    std::string getRole() const override { return "Employee"; }

    void describe() const override {
        std::cout << name << " (" << age << " years) - " << position;
    }
};
```

Мы более подробно разбирали суть фичи в одном из [предыдущих постов](https://t.me/grokaemcpp/790). Сейчас мы поговорим, как примерно Cfront преобразовывал этот С++ код в С код.

Две основные идеи:

1 Для каждого полиморфного класса формируется статическая таблица виртуальных функций. Это по сути массив указателей на виртуальные "методы" класса, которые Cfront представлял в виде обычных функций. Порядок методов в таблице определялся порядком их объявления в классе.

2 Нужно каким-то образом связать таблицу для класса с объектом этого класса. Для этого использовалось неявное дополнительное поле класса - указатель на таблицу виртуальных функций или vptr.

Вот как Cfront преобразовывал код выше(примерно, детали могут отличаться):

```c
struct Shape {
    // pointer to vtable
    void (**vptr)();
    
    // Shape data
    int x;
    int y;
};

struct Circle {
    // Base object
    struct Shape base;
    
    // Circle own data
    double radius;
};
```

Здесь мы видим вложенность данных, которое обеспечивает наследование.

В самом первом базовом классе появлялся указатель vptr, который в конструкторе инициализируется правильным адресом нужной таблицы. void (\*\*vptr)() - это тип указателя на указатель на функцию, возвращающую void и не принимающую аргументов. 

Но погодите, виртуальные методы как минимум принимают один неявный аргумент this, а как максимум могут самые разнообразные сигнатуры иметь. Почему указатель имеет такой тип?

Ну а как вы еще засунете в один массив разные функции. Их кастили к одному общему типу void(\*)(), только так это было возможно:

```c
// VTable for Person
void (*Person_vtable[])() = {
    (void(*)())Person_getRole_impl,
    (void(*)())Person_describe_impl
};

// VTable for Employee  
void (*Employee_vtable[])() = {
    (void(*)())Employee_getRole_impl,
    (void(*)())Employee_describe_impl
};

char* Person_getRole_impl(const struct Person* this) {
    return "Person";
}

void Person_describe_impl(const struct Person* this) {
    printf("%s (%d years)", this->name, this->age);
}

char* Employee_getRole_impl(const struct Person* this) {
    const struct Employee* emp = (const struct Employee*)this;
    return "Employee";
}

void Employee_describe_impl(const struct Person* this) {
    const struct Employee* emp = (const struct Employee*)this;
    printf("%s (%d years) - %s", emp->base.name, emp->base.age, emp->position);
}
```

Cfront генерировал Сишные реализации методов и клал их в массив, попутно приводя к типу void(\*)().

Ну а в месте вызова метода компилятор же знал сигнатуру вызываемого метода, поэтому он делал обратный каст к сигнатуре метода:

```c
void print_info(const struct Person* person) {
    char* (*getRole_func)(const struct Person*) = 
        (char* (*)(const struct Person*))person->vptr[0];
    printf("Role: %s\n", getRole_func(person));
    
    void (*describe_func)(const struct Person*) = 
        (void (*)(const struct Person*))person->vptr[1];
    describe_func(person);
    printf("\n");
}
```

В те времена С не был стандартизирован и правила преобразования типов были несколько мягче, поэтому такая магия с приведениями работала.

В современных компиляторах нет надобности вырабатывать Сишный код, но тем не менее концепция таблиц виртуальных функций и указателей на них осталась.

Have a legacy. Stay cool

#cppcore #goodoldc #compiler 


Современные таблицы виртуальных функций
#опытным 

С++ давно ушел от компиляции в С. Но таблицы виртуальных функций, как средство реализации динамического полиморфизма, остались в большинстве компиляторов. 

Как устроены vtables сейчас, когда С++ напрямую компилируется в ассемблер?

Идея все та же: 
- на каждый полиморфный класс создается своя vtable. 
- Она представляет собой просто массив адресов. В ассемблере адреса нетипизированные, поэтому они просто лежат там чиселками. 
- в каждом объекте хранится vptr - указатель на эту таблицу.
- vtpr инициализируется в самом базовом классе его адресом его vtable и затем каждый конструктор наследника присваивает в него адрес своей таблицы. 
- на каждый вызов виртуального метода в С++ в ассемблере делается call соответствующего адреса.

Реализации вносят свои особенности, но это ядро остается неизменным.

Вот примерчик(можете смотреть на [годболте](https://godbolt.org/z/PcYa3Tacv)):

```cpp
class Person {
protected:
    std::string name;
    int age;
public:
    Person(const std::string &n, int a) : name(n), age(a) {}
    virtual std::string getRole() const { return "Person"; }
    virtual std::string getName() const { return name; }
    virtual void describe() const {
        std::cout << name << " (" << age << " years)";
    }
    virtual ~Person() = default;
};

class Employee : public Person {
    std::string position;
public:
    Employee(const std::string &n, int a, const std::string &pos)
        : Person(n, a), position(pos) {}
    std::string getRole() const override { return "Employee"; }
    void describe() const override {
        std::cout << name << " (" << age << " years) - " << position;
    }
};

int main() {
    Person * p = new Employee("Steven", 42, "CEO");
    p->describe();
    std::cout << p->getName() << std::endl;
}
```

Будем сейчас разбирать gcc-шный асм.

Вот так выглядят таблицы для обоих классов:

```asm
vtable for Person:
.quad 0
.quad typeinfo for Person
.quad Person::getRole[abi:cxx11]() const
.quad Person::getName[abi:cxx11]() const
.quad Person::describe() const
.quad Person::~Person()

vtable for Employee:
.quad 0
.quad typeinfo for Employee
.quad Employee::getRole[abi:cxx11]() const
.quad Person::getName[abi:cxx11]() const
.quad Employee::describe() const
.quad Employee::~Employee()
```

quad - это 64-битное число. Видно, что таблицы - это статические массивы. 

Первым числом у них является offset to top, это число нужно для корректной работы множественного наследования, не будем вдаваться в детали. 

Второй число - адрес расположения информации о динамическом типе(RTTI) объекта. Эта информация нужна, например, для dynamic_cast'а.

Дальше расположены адреса виртуальных функций нужных классов. Заметьте, что адреса расположены в порядке объявления виртуального метода в классе. Если в дочернем классе переопределяется метод, то в его vtable указатель родительского метода заменяется на переопределенный(методы `getRole` и `describe`). Если наследник не переопределяет метод, то в таблице остается указатель на родительский метод(`getName`).

В конструкторе Employee происходит такое:

```asm
; Сначала вызывается конструктор Person (устанавливает vptr Person)
call    Person::Person(...) [base object constructor]

; Затем перезаписывается vptr на таблицу Employee
mov     edx, OFFSET FLAT:vtable for Employee+16
mov     rax, QWORD PTR [rbp-24]
mov     QWORD PTR [rax], rdx
```

Вызывается конструктор базового класса и сразу же после этого переприсваивается vptr на таблицу класса Employee.

Ну а виртуальный вызов выглядит просто как call нужного адреса:

```asm
mov     rax, QWORD PTR [rbp-40]    ; Загружаем указатель p
mov     rax, QWORD PTR [rax]       ; Загружаем vptr (указывает на vtable+16)
add     rax, 16                    ; Смещаемся к 4-му слоту (describe)
mov     rdx, QWORD PTR [rax]       ; Загружаем адрес функции describe
mov     rax, QWORD PTR [rbp-40]    ; Загружаем this (указатель p)
mov     rdi, rax                   ; Передаем this как первый параметр
call    rdx                        ; Виртуальный вызов describe
```

Компилятору достаточно лишь правильно положить аргументы функции в правильные регистры, согласно calling conventions. Какие аргументы нужно подготовить компилятор знает заранее, так как сигнатура виртуальных методов одинакова для всех переопределенных вариантов. Остается лишь call'ьнуть нужный указатель и происходит виртуальный вызов. 

Подкапотоное устройство полиморфизма часто спрашивают на собесах. Теперь вы знаете, как отвечать почти на полный спектр вопросов по этой теме.

Know whats under the hood. Stay cool.

#compiler #cppcore


Переустановка vptr.


Наследие Cfront. Перегрузка
#новичкам 

В С нет перегрузки функций, поэтому там люди вынуждены каким-то образом руками разделять имена функций.

Вместо

```cpp
void print(int x);
void print(float x);
```

Там пишут:

```c
void print_int(int x);
void print_float(float x);
```

Плюс линкеры работают с именами символов. А имя функции в С не включает в себя параметры. Поэтому во всей программе не может быть двух функций с одинаковыми именами. Линкер их банально не различит и выдаст ошибку множественного определения.

А в С++ была перегрузка и надо было каким-то образом плюсовые перегруженные функции превращать в неперегруженные сишные. Для этого было придумано декорирование имен или name mangling.

Ну самый простой способ - добавлять к конце функции ее параметры в закодированном виде: ИмяФункции_ТипыПараметров:

```c
void draw(int x, int y);
void draw(double x, double y);

// Cfront mangling:
draw_i_i          // draw(int, int)
draw_d_d          // draw(double, double)  
```

Так как у нас не может быть двух перегрузок с разными возвращаемыми значениями, то кодирование типа возврата не нужно.

Но 2 разных класса тоже могут иметь методы с одинаковым названием. Поэтому манглинг должен учитывать и имя класса:

```cpp
void Circle::paint(Color c);
void Square::paint();
Rectangle::~Rectangle();
Shape::~Shape();

// transform into

void Circle_paint_Color(struct Circle* this, Color c);
void Square_paint(struct Square* this);
void Rectangle_dtor(struct Rectangle* this);
void Shape_dtor(struct Shape* this);
```

Но помимо параметров функций и классов есть же еще и пространства имен. Они помогают разграничить скоуп существования имен. И названия пространства имен тоже манглировались в имена функций:

```cpp
namespace Graphics {
    class Canvas {
        void clear();
    };
}

// transform into

void Graphics_Canvas_clear(struct Canvas* this)
```

Когда появились шаблоны, Cfront и их манглировал:

```cpp
template<typename T>
class Stack {
    void push(T value);
};

Stack<int> stack;

// transforms into

Stack_int_push_i(int value);
```

Конкретные преобразованные имена могут быть не такими, какими их генерировал Cfront, но главное уловить идею.


В современных компиляторах тоже делается манглинг имен, чтобы линкер не ругался на одинаковые символы:

```cpp

void Circle::rotate(int);

// transforms into 

_ZN6Circle6rotateEi

// Разбор:
_Z                   - префикс C++
N                    - вложенное имя
6Circle              - длина=6, "Circle"  
6rotate              - длина=6, "rotate"
E                    - конец аргументов
i                    - тип int
```

Шаблоны, неймспейсы, noexcept и const квалификаторы - все вшивается в имя символа.

Вы также можете вручную управлять манглингом: включать и выключать его:

```cpp
extern "C" void c_function();   // Без манглинга: _c_function
extern "C++" void cpp_function(); // С манглингом: _Z10cpp_functionv
```

Это нужно для совместимости ABI интерфейсов, предоставляемых библиотеками.

Have a legacy. Stay cool

#cppcore #goodoldc #compiler 



Наследие Cfront. Компоновка
#новичкам 

С++ оказывал влияние не только на компиляторы, но и на линковщики.

Если в первых версиях языка и компилятора Cfront Бьерн сфокусировался на ООП и полиморфизме, то дальше были введены шаблоны и inline функции.

Шаблоны и inline функции просто исходя из своей механики работы предполагают то, что конкретные инстанциации и определения inline функций могут находиться в нескольких единицах трансляции в рамках одной программы.

Но в С был и есть One Definition Rule, который запрещал иметь более одного определения сущности в рамках одной программы.

Поначалу для решения этой проблемы использовались разные хаки: от макросов и магии с именами до ручной инстанциации шаблонов в одном cpp файле.

Это конечно было неудобно, но благо С++ становился все более популярным и влиятельным. Поэтому команда Cfront начала активно взаимодействовать с разработчиками линковщиков для того, чтобы ввести так поддержку слабых символов. Их в программе может быть сколько угодно, линковщик выберет один любой из них и будет ссылать на этот символ все заглушки. Главное, чтобы все определения символа были одинаковыми, иначе UB.

Также в С++ появились глобальные объекты. А глобальные объекты требуют своей инициализации(то есть выполнения кода до main). В сижке такого нет, там исполнение пользовательского кода начинается с вызова main. Кстати поэтому в С нет [SIOF](https://t.me/grokaemcpp/279).

Поэтому приходилось извращаться. Формировать массив конструкторов глобальных объектов и вызывать его первой инструкцией main. Разрушение происходило в конце main с помощью массива деструкторов.

Но это костыль и нужно было нормальное решение и им стали секции .ctors/.dtors в объектных и бинарных файлах. Эти код из этих секций выполняется до и после main соответственно.





Cppfront
#опытным 

Есть интересный проект у Герба Саттера -  компилятор cppfront. По аналогии с Cfront, который компилировал С++ в С, cppfront компилирует экспериментальный синтаксис Cpp2 в наш привычный C++.

Cpp2 - это можно сказать очень сахарный и слегка преобразованный С++. Герб говорит, что это не наследник и не соперник С++. Он помогает С++ эволюционировать, проверяя на нем функциональность, которую предлагают внести в С++.

Если просто: Герб и другие активные деятели С++ из комитета и не совсем придумали Cpp2 и написали препроцессор, который преобразует новый синтаксис в старый С++. 

Как обычно завозятся фичи в стандарт: пишется огромный документ, где словами объясняется как должна работать фича. Но проверить на практике механизмы ее работы работы нельзя, можно лишь мысленные эксперименты проводить. 

С появлением Cppfront, если кто-то хочет завести в стандарт С++ какую-то новую функциональность(например [pattern matching](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2688r3.html)), то ее можно относительно быстро реализовать в Сpp2 и поиграться с ней на практике. Коммьюнити может почелленджить решение и его использование, прочекать граничные и сложные случаи и тд. 

То есть не нужно трогать существующие компиляторы, стандартные библиотеки, разбираться в синтаксическом анализе, копаться в кишках реализации и тд. Просто пишешь парсер и фичу уже можно потрогать руками.

И это будет работать на любой платформе, где есть С++ компилятор!

Простой пример кода на Cpp2:

```cpp
#include <iostream>
#include <string>

name: () -> std::string = {
    s: std::string = "world";
    decorate(s);
    return s;
}

decorate: (inout s: std::string) = {
    s = "[" + s + "]";
}

auto main() -> int {
    std::cout << "Hello " << name() << "\n";
}
```

Видно, что добавлены всякие аннотации, универсальные инициализации переменных и функций. Внутреннее наполнение функций примерно такое же, но под другой оберткой.

И очень прикольно, что вы сами можете поиграться с Cpp2 в [годболте](https://godbolt.org/z/M6vE4PvKc) и посмотреть какой будет итоговый С++ код.

Вот ссылочка на [гитхаб](https://github.com/hsutter/cppfront) и на [доку](https://hsutter.github.io/cppfront/).

Help to evolve. Stay cool.

#compiler 


Что не так с модулями?
#опытным 

Модули появились как одна из мажорных фич С++20, которая предоставляет чуть ли не другой подход к написанию С++ кода.

Модули - это новая фундаментальная единица организации кода, которая должна дополнить и в идеале(в мечтах комитета) заменить старую концепцию заголовочных файлов.

Если по простому, то модуль - это такой бинарный черный ящик, у которого четко определен интерфейс, который он экспортирует наружу. 

Сущности, которые экспортируются, явно помечаются в коде модуля. Затем модуль компилируется и из бинарного его представления можно дергать только эти сущности.

Короткий пример:

```cpp
// math.cppm - файл модуля
export module math;  // Объявление модуля

import <vector>;     // Импорт, а не включение

// Макросы НЕ экспортируются!
#define PI 3.14159

// Явный экспорт - только то, что нужно
export double calculate_circle_area(double radius);

// Внутренние функции скрыты
void internal_helper();
```

 и его использование:

```cpp
// main.cpp - обычный С++ файл
import math;    // Импорт интерфейса, не всего кода

// Используем экспортированную функцию
double area = calculate_circle_area(10);

// internal_helper();  // ERROR! функция скрыта
// double x = PI;      // ERROR! макросы не экспортируются
```

Модули призваны решать следующие проблемы:

- Одни и те же заголовки могут сотни раз обрабатываться компилятором при компиляции программ из многих единиц трансляции. Модули же компилируются один раз, в них кэшируется информация, необходимая для нормальной компиляции cpp файлов  и потом эта информация просто используется при компиляции. Никакой повторной работы!
  Это значит, что время компиляции должно заметно уменьшиться.
- В хэдэрах зачастую нужно оставлять некоторые детали реализации, которые не нужны пользователю, но нужны для корректной компиляции. Модули же явно экспортируют только нужный интерфейс.
- Никакой макросятины! Ни один макрос не прошмыгнет внутрь клиентского кода из модуля, потому что он уже скомпилирован.

На словах - прекрасные плюсы будущего. Но на словах мы все Львы Толстые, а на деле...

А на деле это все до сих пор работает довольно костыльно. До 23, а скорее 24 года использовать модули было совсем никак нельзя. Сейчас все немного лучше, но реализации все еще пропитаны проблемами. А проекты не спешат переходить на модули. Но почему?

1 Модули - довольно сложная штука в реализации. Не будем вдаваться в нюансы, но компилятор должен сильно измененить свое поведение и преобрести свойства системы сборки, чтобы нормально компилировать модули. А делать они этого не хотят. Плюс многие компиляторы опенсорсные и не так-то просто в опенсорсе реализовывать такие масштабные идеи. На винде с этим попроще, потому что во главе всего Microsoft и они завезли модули раньше всех.

2 Бинарный формат модулей нестандартизирован. Каждый компилятор выдумывает свое представление, которое несовместимо между компиляторами или даже версиями одного компилятора.

3 Из-за этого в том числе хромает тулинг. Дело в том, что модуль - это бинарный файл и программист просто так не может, например, посмотреть сигнатуру метода в каком-то файле. Это большая проблема, которую должны решить редакторы и анализаторы кода. Но отсутствие стандартизации формата мешает интеграции модулей в них. 

4 Очень много усилий нужно потратить на переработку архитектуры и кода существующих проектов, чтобы перевести их на модули.

5 Ускорение компиляции может неоправдать затрат. В среднем ускорение составляет порядка 30%. И это просто не стоит усилий.

6 Нужны новейшие версии систем сборки, компиляторов и других инструментов, чтобы заработали модули.

7 Пока популярные библиотеки не начнут распространяться через модули, существующие проекты не будут иметь большое желание переезжать на модули, потому что получится частичное внедрение.

Тем не менее, если у вас есть самые актуальные инструменты, вы запускаете новый проект или решили в тестовом режиме обновлять уже существующий, то пользоваться модулями уже можно, хоть и осторожно и с ожиданием возможных проблем.

Use new features. Stay cool.

#cppcore #compiler #tools 



