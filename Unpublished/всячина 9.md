pointer to data member
#опытным 

В [этом посте](https://t.me/grokaemcpp/723) мы рассказывали о том, что с помощью ranges и и параметра проекции можно кастомизировать алгоритмы с соответствии с определенным полем класса. Например, чтобы найти в коллекции элемент с максимальным определенным полем, то можно сделать так:

```cpp
auto max = *std::ranges::max_element(payments, {}, &Payment::amount);
```

max в этом случае будет транзакцией с максимальным размером платежа.

В этой строчке используется `&Payment::amount` - указатель на поле amount в классе Payment. Но если это параметр функции, то это значение какого-то типа. Но какой тип у этого указателя?

Если про указатели на конкретные мемберы знают немногое, то это совсем дебри плюсов.

Тип указателя на поле класса определяется так:

```cpp
struct Payment {
	double amount;
	std::string category;
};

double Payment::*ptr = &Payment::amount; // Here!

Payment payment{3.14, "Groceries"};
std::cout << payment.*ptr << std::endl;
// OUTPUT:
// 3.14
```

```cpp
double Payment::*       ptr         = &Payment::amount;
// тип указателя    имя указателя    инициализатор
```

По сути это особый тип указателя, который хранит смещение поля относительно начала объекта в байтах. Это не специфицировано в стандарте, но примерно везде так работает.

Естественно, мы должны указать, на какой тип полей этот указатель может указывать. Таким образом указатель `ptr` может указывать на любое поле класса `Payment`, имеющее тип `double`. То есть:

```cpp
struct Type {
	int a;
	int b;
	float c;
};

int Type::*p = nullptr;

p = &Type::a; // OK, `a` is int
p = &Type::b; // OK, `b` is int

p = &Type::c;  // ERROR! `c` is float
```

Указателю на интовое поле нельзя присвоить указатель на флотовое. И наоборот, указатель `p` работает с любыми полями типа int.

Если вы подумали, что очень узкоспециализированная вещь, то вы правы. Чуть больше универсализации здесь могут дать шаблоны:

```cpp
// Takes pointer to any data member for any type
template<typename T, typename FieldType>
void print_field(const T& obj, FieldType T::*field) {
    std::cout << obj.*field << std::endl;
}

Payment payment{3.14, "Groceries"};
Type t(42, 69, 3.14);

print_field(payment, &Payment::amount);
print_field(payment, &Payment::category);

print_field(t, &Type::a);
print_field(t, &Type::b);
print_field(t, &Type::c);
// OUTPUT
// 3.14
// Groceries
// 42
// 69
// 3.14
```

`print_field` может печатать значение любого поля любого класса по его указателю. Обратите внимание на шаблонную сигнатуру.

Walk through the nooks and crannies. Stay cool.

#cppcore #memory 


WAT
#опытным

Спасибо, @Ivaneo, за любезно предоставленный примерчик в рамках рубрики #ЧЗХ.

Всегда ли nullptr указатель равен нулю?

Казалось бы в названии дан ответ:

```cpp
int * p = nullptr;
std::cout << std::boolalpha << (p == nullptr) << "\n";
std::cout << std::hex << std::bit_cast<std::uintptr_t>(p) << "\n";
// OUTPUT
// true
// 0
```

Но в общем случае это неправда! [Смотрим на пример](https://godbolt.org/z/d89oEaWd4):

```cpp
struct A {
    int i;
};

int main() {
    int A::* p = 0;

    std::cout << std::boolalpha << (p == nullptr) << "\n";
    std::cout << std::hex << std::bit_cast<std::uintptr_t>(p) << "\n";
    std::cout << std::boolalpha << (std::bit_cast<std::uintptr_t>(p) == 0xffffffffffffffff) << "\n";
}
// OUTPUT:
// true
// ffffffffffffffff
// true
```

nullptr указатель равен совсем не нулю, как декларировалось в начале main. 

WAT? Что за фокусы с пропажей нуля?

В недавнем посте мы рассказывали об особом типе указателя - pointer to(data)member. Этот указатель, которым и является `p` из примера, по сути хранит информацию о том, как в объекте найти нужное поле класса.

И в большинстве случаев эта информация представляет собой просто смещение поля относительно начала объекта в байтах.

Однако нулевое смещение используется для локации самого первого поля класса. Поэтому в байтовом представлении неинициализированный указатель не может быть нулем.

Вместо этого обычно используется число -1, которое в байтовом представлении как раз выглядит как все единички:

```cpp
std::cout << std::hex << static_cast<long long int>(-1) << "\n";
// OUTPUT:
// ffffffffffffffff
```

С помощью указателей на поля класса можно кстати наглядно изучать выравнивание и упаковку полей с объект:

```cpp
struct Type {
    double a;
    char b;
    float c;
    long long d;
    short e;
    unsigned f;
};

std::cout << std::dec << std::bit_cast<std::uintptr_t>(&Type::a) << "\n";
std::cout << std::dec << std::bit_cast<std::uintptr_t>(&Type::b) << "\n";
std::cout << std::dec << std::bit_cast<std::uintptr_t>(&Type::c) << "\n";
std::cout << std::dec << std::bit_cast<std::uintptr_t>(&Type::d) << "\n";
std::cout << std::dec << std::bit_cast<std::uintptr_t>(&Type::e) << "\n";
std::cout << std::dec << std::bit_cast<std::uintptr_t>(&Type::f) << "\n";

// OUTPUT:
// 0
// 8
// 12
// 16
// 24
// 28
```

Опять же, интересный уголок плюсов.

Walk through the nooks and crannies. Stay cool.

#cppcore #memory


Сколько весит объект полиморфного класса?
#новичкам 

Частый вопрос с собеседований про размеры объектов различных классов. Даже в бэкэндерских конторах, в которых никогда в жизни не учитывали эти размеры. Но такие вопросы раскрывают знание базы, а считается, что без ее знания вы не можете писать нормальный код.

У нас уже был пост про [размер объекта пустого класса](https://t.me/grokaemcpp/156). А что если это будет класс с виртуальными методами? Сколько тогда будет весить этот класс?

```cpp
struct SomeClass {
	
	virtual ~SomeClass() = default;
	
	virtual void Process() {
		std::cout << "Process" << std::endl;
	}
};
```

Мы знаем, что для каждого класса, имеющего виртуальные методы, создается глобальная таблица виртуальных функций. В ней находятся конкретные адреса виртуальных методов конкретно этого класса. И именно к ней обращаются, когда хотят порешать вопросики, какой метод вызвать.

Таблица одна на все объекты заданного класса. И им каким-то образом нужно получить доступ к этой таблице.

Учитывайте, что нельзя захардкодить эту информацию по статическому типу объекта(например SomeClass& или SomeClass*), потому что под его личиной может скрываться наследник. 

Значит надо ее класть в каждый объект. И самое простое - положить в них указатель на свою таблицу виртуальных функций. Так и делают на самом деле. Этот указатель называют vptr.

Соответственно размер класса зависит от битности системы. Для 64-бит указатель имеет размер 8 байт(64 бита) поэтому и [размер класса SomeClass будет 8 байт](https://godbolt.org/z/hzYKbvr6e).

```cpp
std::cout << sizeof(SomeClass) << std::endl;
// OUTPUT
// 8
```

Пустые наследники SomeClass кстати тоже будут иметь размер 8 из-за того, что им только всего и нужен лишь другое значения указателя.

Если вы добавите еще полей, то размер увеличится в соответствии с размером дополнительных полей и выравниванием.

Be lightweight. Stay cool.

#cppcore #interview 


join
#опытным 

Как прекрасно сделан в питоне метод join у строки. Чтобы соединить список строк разделителем нужно просто написать:

```python
my_list = ["John", "Peter", "Vicky"]
x = " ".join(myTuple)
print(x)
# OUTPUT
# John Peter Vicky
```

И как же сложно того же результата достичь в плюсах!

То делают через потоки:

```cpp
std::string join(const std::vector<std::string>& vec, const std::string& delimiter) {
    if (vec.empty()) return "";
    
    std::ostringstream oss;
    oss << vec[0];
    
    for (size_t i = 1; i < vec.size(); ++i) {
        oss << delimiter << vec[i];
    }
    
    return oss.str();
}
```

то через std::accumutate:

```cpp
std::string join(const std::vector<std::string>& vec, const std::string& delimiter) {
    if (vec.empty()) return "";
    
    return std::accumulate(
        std::next(vec.begin()), vec.end(),
        vec[0],
        [&delimiter](const std::string& a, const std::string& b) {
            return a + delimiter + b;
        }
    );
}
```

Ну вы что! Стандартная строка же себе не может позволить иметь метод join, принимающий коллекцию строк и возвращающий объединенную строку с разделителями. Это же не универсально и никому не надо...

Но в С++23 наконец-то появилось хоть что-то похожее на адекватное решение. Используем std::views::join_with:

```cpp
std::string join(const std::vector<std::string> &vec,
                 const std::string &delimiter) {
    return vec | std::views::join_with(delimiter) |
           std::ranges::to<std::string>();
}
```

Можете обмазать все это шаблонами с головы до пят, чтобы получить универсальное решение, либо использовать прям inplace, код и так довольно понятный.

И жизнь стала чуть-чуть счастливее...

Make thing simple. Stay cool.

#cpp23



Уплощаем многомерный массив
#опытным 

Иногда у вас есть коллекция элементов, для каждого из которых вы выполняете операцию, возвращающую вектор значений:

```cpp
std::vector<int> Process(const std::string& str);

std::vector<std::string> elems = ...;

auto result_view = elems | std::views::transform([](const std::string& str) {
	return Process(str);
})
```

Итоговое отображение result - это по факту набор векторов, как из него удобно получить плоский вектор интов?

С помощью С++20 отображения std::views::join:

```cpp
std::vector<int> Process(const std::string& str);

std::vector<std::string> elems = ...;

auto result_view = elems | std::views::transform([](const std::string& str) {
	return Process(str);
})

std::vector<int> result;

std::ranges::copy(result_view | std::views::join, std::back_inserter(result));
```

Если у вас элементы, которые хотелось бы переместить, а не скопировать, то можно добавить еще отображение as_rvalue:

```cpp
std::ranges::copy(result_view | std::views::join | std::views::as_rvalue, std::back_inserter(result));
```

Если хочется чистого кода без циклов, то рэнджи и в этом случае могут помочь.

Don't stuck in a loop. Stay cool.

#cpp20


Константная мапа
#новичкам 

Определяете вы какое-нибудь отображение в коде:

```cpp
using CommandCreator = std::function<std::unique_ptr<ICommand>(const std::vector<std::string>&)>;
const std::unordered_map<std::string, CommandCreator> commands = {
	{"create", [](){return std::make_unique<CreateCommand>()}},
	{"delete", [](){return std::make_unique<DeleteCommand>()}},
	{"save", [](){return std::make_unique<SaveCommand>()}}
};
```

Никаких больше команд вы не обрабатываете, отображение константно.

И вот вы хотите получить доступ к элементам мапы:

```cpp
auto command = commands[command_name];
command->Execute();
```

И тут бац! И ошибка компиляции о том, что нет такого оператора[], который бы принимал константную std::unordered_map.

Почему так? У вектора же есть.

Проблема тут комплексная.

[Здесь](https://t.me/grokaemcpp/574) мы рассказали о том, что operator[] у мапы имеет одну особенность. Если вы ему передаете новый ключ, то он изменяет мапу и вставляет в нее элемент с этим новым ключом и дефолтным значением.

Это сделано по всей видимости по причине универсализации поведения между операторами[] для большинства контейнеров. Обычно operator[] не бросает никаких исключений. Он может приводить к неопределенному поведению, как например у вектора при доступе за границу массива. Но он не бросает. 
И в случае мапы не очень понятно, что делать, если переданного ключа нет, бросать нельзя и хочется сохранить идентичность интерфейса по всему STL с возвратом ссылки.
Вот и решили конструировать объект налету.

Но для константного оператора вообще непонятно, что делать, если ключа нет, бросать нельзя, нужно возвращать ссылку, да еще и изменять мапу нельзя. Поэтому решили проблему гениально: вообще не вводить эту версию оператора.

В условиях отсутствия константного operator[] для std::map и std::unordered_map вы можете использовать либо метод at(), который бросает std::out_of_range, если ключа нет. Или find(), который вернет итератор на конец мапы в этом же случае:

```cpp
auto command = commands.at(command_name);
command->Execute();
// or
if (auto it = commands.find(command_name); it != commands.emd()) {
	auto command = it->second();
	command->Execute();
} else {
	std::cout << "ERROR" << std::endl;
}
```

Find compromis. Stay cool.

#STL


WAT
#опытным 

Спасибо, @Ivaneo, за любезно предоставленный примерчик в рамках рубрики #ЧЗХ.

"Век живи - век учись" - сказал Луций Сенека.

"Век живи - век учи С++" - реалии нашей жизни.

Просто посмотрите на следующий код:

```cpp
struct Foo
{
	void Bar();
};

void Foo::Foo::Foo::Foo::Foo::Foo::Foo::Foo::Foo::Foo::Foo::Foo::Bar()
{
    printf("Foofoo!");
}

int main()
{
    Foo f;
    f.Bar();
    return 0;
}
```

И он [компилируется](https://godbolt.org/z/ddhdbfKMj).

WAT?

Это называется injected class name. Имя класса доступно из скоупа этого же класса. Так сделано для того, чтобы поиск имени `X` внутри класса `X` всегда разрешался именно в этот класс

Такое поведение может быть полезно в таком сценарии:

```cpp
void X() { }
class X {
public:
	static X Сreate() { return X(); }
};
```

injected class name гарантирует, что из метода `Сreate` будет возвращен именно инстанс класса Х, а не результат вызова функции Х.

Это также полезно внутри шаблонов классов, где имя класса можно использовать без списка аргументов шаблона, например, используя просто Foo вместо полного идентификатора шаблона Foo<blah, blah, blah>.

Ну и побочным эффектом такого поведения является возможность написания длиннющей цепочки из имен класса.

Так что это не у вас в глазах двоится, это плюсы такие шебутные)

Find yourself within. Stay cool.

#cppcore


Как динамически выделить память на стеке?
#опытным 

В книжке "Вредные советы для С++ программистов" от PVS-студии есть такой вредный совет: массив на стеке - это лучшее решение.

Типа выделение памяти в куче - это зло. char c[256] хватит всем, а если не хватит, то потом поменяем на 512. В крайнем случае – на 1024.

Да, использование буферов, фиксированного размера действительно ведет в проблемам в коде. Запилили новую фичу, изменили размер данных, а забыли поменять размер массива. Пожалуйста, UB.

Но возникает вопрос: а как тогда можно динамически выделять память на стеке? Ведь стандартные C-style массивы работают только с известными в compile-time размерами.

Пара способов есть, но они с "нюансом":

- Variable Length Array. Вы просто берете и создаете массив переменного размера:

```cpp
void foo(size_t n) {
	float array[n];
	// ....
}
```

Круто!

Да, но это не часть стандарта С++) Это фича языка С, доступная с С99. Однако GCC например поддерживает ее, как компиляторное расширение языка и вы сможете g++'ом сгенерировать код выше.

- alloca. Функция, которая аллоцирует заданное количество байт на стеке:

```cpp
void *alloca(size_t size);

void foo(size_t n) {
	float *array = (float)alloca(sizeof(float) * n);
}
```

Память, выделенная alloca автоматически освобождается при выходе из функции.

Эта также нестандартная функция, которая не является даже частью ANSI-C стандарта, но  поддерживается многими компиляторами(в т.ч. является частью Linux API).

Ну и на этом все.

Стандартных решений нет. И на это есть причина. Дело в том, что такой код провоцирует возникновение в программах уязвимостей.

В стандарте MISRA C есть правило MISRA-C-18.8, указывающее не использовать VLA. Другие руководства, такие как SEI CERT C Coding Standard (ARR32-C) и Common Weakness Enumeration (CWE-129), не запрещают использовать эти массивы, но призывают проверять перед созданием их размер.

Засунули в программу большой запрос и получили переполнение стека. Это вариант DoS-атаки уровня приложения.

На счет alloca вообще есть интересные интересности. Представьте себе, что будет если компилятор попытается встроить код этой функции:

```cpp
void DoSomething() {
   char* pStr = alloca(100);
   //......
}
```

в вызывающий код:

```cpp
void Process() {
   for (i = 0; i < 1000000; i++) {
     DoSomething();
   }
}
```

Так как память, выделенная alloca освобождается только после завершения функции, а не выходе из скоупа, то получает взрыв размера стека.

И теперь представьте лицо программиста, который написал этот код с учетом вызова alloca именно во фрейме функции DoSomething. 

Манипуляции со стеком - не очень безопасно, поэтому ничего такого и не вводят в плюсы.

Be safe. Stay cool.

#NONSTANDARD #goodoldc 


Двойной unlock
#опытным 

Если не пользоваться RAII, то можно наткнуться на массу проблем. Все знают про double free. Но менее известна проблема double unlock.

Все просто, вы используете ручной lock-unlock мьютекса и возможно попадаете в ситуацию двойного освобождения:

```cpp
void unsafe_function(int value) {
    mtx.lock();
    
    if (value < 0) {
        std::cout << "Error: negative value\n";
        mtx.unlock();
        // forget to return!
    }
    
    shared_data = value;
    std::cout << "Data has updated: " << shared_data << std::endl;
    
    mtx.unlock();  // second unlock
}
```

Практически всегда двойной unlock происходит из-за некорректного кода в той или иной степени. Забыть вызвать return кажется детской проблемой, но если вы например не написали тесты на эту ветку, то возможно вы наткнетесь на проблемы только в проде.

А проблемы могут быть примерно любыми. Потому что двойной unlock мьютекса - UB по стандарту. Соответственно, можете получить много непрятностей, от сегфолта до бесконечного ожидания.

Поэтому просто используйте RAII и спина болеть не будет:

```cpp
void safe_function(int value) {
    std::lock_guard lg{mtx};
    
    if (value < 0) {
        std::cout << "Error: negative value\n";
        return;
    }
    
    shared_data = value;
    std::cout << "Data has updated: " << shared_data << std::endl;
}
```

Use safe technics. Stay cool.

#concurrency #cpp11 


enum class
#новичкам

Перечисления пришли в С++ еще из С и отлично живут. Однако плюсовикам не очень с ними комфортно работать с силу наследования слабой типизации и неявных преобразований enum'ов в числовые типы и в другие enum'ы

В С++11 появился новый тип перечислений - scoped enumerations. Или ограниченные областью видимости перечисления. Определяются они так:

```cpp
enum class Enumeration {CATEGORY1, CATEGORY2, CATEGORY3};
```

Он решает две большие проблемы обычных перечислений:

- Обычные перечисления неявно преобразуются в int и обратно, что вызывает ошибки, когда не предполагается использование перечисления в качестве целого числа.

Можно например попробовать получить следующее значение перечисления, просто прибавив единицу:

```cpp
enum Color { RED, GREEN, BLUE };

Color c = RED;
Color next = c + 1;  // Implicit conversion to int and visa versa!
```

Что значит прибавить красному цвету единицу - решительно непонятно.

Неявные преобразования enum class'ов же запрещено:

```cpp
enum class Color { RED, GREEN, BLUE };

Color c = Color::RED;
Color next = c + 1; // ERROR!
```

Если вам сильно нужно преобразовать перечислитель к числу, то вы это должны сделать явно:

```cpp
Color c = Color::RED;
Color next = static_cast<Color>(static_cast<int>(c) + 1);
```

- Обычные перечисления экспортируют свои перечислители в окружающую область видимости, вызывая конфликты имён с другими сущностями в этой окружающей области:
```cpp
enum Color { RED, GREEN, BLUE };
 
enum TrafficLight { RED, YELLOW, GREEN }; // ERROR!

void graphics_library() {
    Color c = RED;
}
```

У soped enum'ов такой проблемы нет. Имена перечислителей находятся в скоупе своего перечисления:

```cpp
enum class Color1 { red, green, blue };
enum class Color2 { red, green, blue };
```

И все прекрасно компилируется.

С учетом неймспейсов и любви к явным кастам в коммьюнити, в С++ лучше использовать enum class'ы вместо обычных перечислений.

Protect your scope. Stay cool.

#cppcore #cpp11


enum struct
#опытным 

В прошлом посте мы рассказали про enum class. И в 99.999% случаев эту сущность будут писать в коде именно, как enum class\.

Но можно написать enum struct и это тоже будет [работать](https://godbolt.org/z/KTEPq9G9j)!

```cpp
enum class FileMode { Read, Write, Append };
enum struct LogLevel { Debug, Info, Warning, Error };

int main() {
	FileMode mode = FileMode::Read;
	LogLevel level = LogLevel::Info;
	std::cout << (mode == FileMode::Read) << std::endl;
	std::cout << (level == LogLevel::Info) << std::endl;
}
```

Немного кто знает вообще о существовании такой конструкции. Свойства enum struct абсолютно аналогичны enum class и структуры перечислений были введены просто для консистентности и поддержания паритета в возможности использования двух ключевых слов.

Вот такой короткий и бесполезный факт из мира плюсов)

Be useful. Stay cool.

#fun #cpp11


Размер enum'а
#опытным 

Перечисления - это по факту именованные числа. Каждому перечислителю ставится в соответствие число, к которому перечислитель может приводиться. Оно либо указывается явно, либо проставляется компилятором.

Но тогда встает вопрос: а сколько весит enum? Мы же про эффективность и хотим, чтобы данные занимали минимально возможное пространство.

Мы можем явно написать:

```cpp
enum MY_FAVOURITE_FRUITS
{
    E_APPLE      = 0x01,
    E_WATERMELON = 0x02,
    E_COCONUT    = 0x04,
    E_STRAWBERRY = 0x08,
    E_CHERRY     = 0x10,
    E_PINEAPPLE  = 0x20,
    E_BANANA     = 0x40,
    E_MANGO      = 0x80,
    E_MY_FAVOURITE_FRUITS_FORCE8 = 0xFF // 'Force' 8bits, how can you tell?
};
```

Мы как бы явно ограничиваем размер enum'а 8-ью битами. Но будет ли его размер реально 8 бит?

Не факт. Компилятор может выбрать любой подходящий по размеру тип, главное, чтобы он мог вместить все элементы перечисления. Это может быть char, short или int. И все это разного размера.

Неприятно, что на это нельзя было влиять.

Но прочь неприятности, потому что в С++11, помимо enum class появилась возможность указания размера scoped и unscoped enum'ов:

```cpp
enum class E_MY_FAVOURITE_FRUITS : unsigned char
{
    E_APPLE        = 0x01,
    E_WATERMELON   = 0x02,
    E_COCONUT      = 0x04,
    E_STRAWBERRY   = 0x08,
    E_CHERRY       = 0x10,
    E_PINEAPPLE    = 0x20,
    E_BANANA       = 0x40,
    E_MANGO        = 0x80,
    E_DEVIL_FRUIT  = 0xFF
};
```

И теперь вы может контролировать и сами задавать размер перечисления.

Control your size. Stay cool.

#cpp11



Удобно превращаем enum в число
#опытным 

В прошлом посте мы выяснили, что с С++11 можно самостоятельно указывать нижележащий тип, который и хранит все элементы enum'а.

Но вот представьте себе, что вам где-то нужно получить числовое представление одного из перечислителя. К какому типу кастовать?

Это важно, потому что scoped enum неявно не приводится к числам. Нам нужно явно указывать тип:

```cpp
enum class ColorMask : std::uint32_t
{
	red = 0xFF, 
	green = (red << 8), 
	blue = (green << 8), 
	alpha = (blue << 8)
};

// std::cout << ColorMask::red << std::endl; // ERROR
std::cout << static_cast<int>(ColorMask::red) << std::endl;
```

Если вам просто нужно вывести число в поток, то кастуйте к инту, ничего страшного не будет. Однако математические операции над полученным числом могут доставить неприятности, если тип будет не тот и будут использоваться сужающие-расширяющие преобразования.

Современные IDE-шки возможно будут вам показывать нужный тип, а возможно и нет. Хочется стандартного решения.

С++11 также вводит тип шаблонный тип std::underlying_type, который предоставляет зависимый тип type, содержащий подкапотный тип enum'a:

```cpp
enum e1 {};
enum class e2 {};
enum class e3 : unsigned {};
enum class e4 : int {};

constexpr bool e1_t = std::is_same_v<std::underlying_type_t<e1>, int>;
constexpr bool e2_t = std::is_same_v<std::underlying_type_t<e2>, int>;
constexpr bool e3_t = std::is_same_v<std::underlying_type_t<e3>, int>;
constexpr bool e4_t = std::is_same_v<std::underlying_type_t<e4>, int>;

std::cout
        << "underlying type for 'e1' is " << (e1_t ? "int" : "non-int") << '\n'
        << "underlying type for 'e2' is " << (e2_t ? "int" : "non-int") << '\n'
        << "underlying type for 'e3' is " << (e3_t ? "int" : "non-int") << '\n'
        << "underlying type for 'e4' is " << (e4_t ? "int" : "non-int") << '\n';

// OUTPUT
// underlying type for 'e1' is non-int
// underlying type for 'e2' is int
// underlying type for 'e3' is non-int
// underlying type for 'e4' is int
```

Соответственно, для каста нужно сделать такую штуку:

```cpp
auto num = static_cast<std::underlying_type_t<ColorMask>>(ColorMask::red);
```

Плохо, что это очень громоздкая конструкция, где к тому же типы повторяются. Поэтому в С++23 ввели хэлпер-сахарок std::to_underlying, который за нас все это делает:

```cpp
auto num = std::to_underlying(ColorMask::red);
```

Красота!

Know your type. Stay cool.

#cpp11 #cpp23



Мувать не всегда дешево
#новичкам 

С приходом мув семантики настали "прекрасные плюсы будущего". Нет никакого копирования, чудо оптимизации бороздят просторы стека и кучи. Не жизнь, а сказка.

Но мир не такой уж солнечный и приветливый. Это очень опасное...

Если вы работаете придерживаетесь RAII, пользуетесь контейнерами и умными указателями, то вы практически никогда не определяете самостоятельно специальные методы класса и, в частности, конструктор перемещения и оператор перемещающего присваивания. Компилятор сгенерирует их за вас, ленивых дядь. 

Рано или поздно вы немного отрываетесь от "низов": вас уже не интересует КАК конкретно эти методы реализованы. Вы оперируете более высокоуровневыми сущностями и полагаетесь на компилятор

И вот вы в ситуации, когда у вас есть данные, обернутые в класс, которые легально по контексту кода можно мувнуть или скопировать. Условно говоря, у вас есть функция Process, которая принимает данные по значению, чтобы поддержать оба варианта передачи: копирование и мув:

```cpp
void Process(Data data);
```

Что выбрать?

"Конечно мувнуть, это же не долгое копирование, выполнится быстро" - вот к таким не совсем корректным мыслям может привести "оторванность от низов".

Кажется, что у некоторых людей есть ощущение, что данные из одного объекта как-то  перетекают в другой объект и это происходит очень быстро. 

Но это не так! Перемещение - это **поверхностное копирование**. 

Возьмем простой пример:

```cpp
struct Data {
	int a;
	double b;
};

Data obj1{3, 3.14};
Dara obj2 = std::move(obj1);
```

Что будет происходить при перемещении `obj1`? Копирование `a` и `b`.

Чуть сложнее:

```cpp
struct Data {
	std::array<int, 5> arr;
};

Data obj1{.arr = {1, 2, 3, 4, 5}};
Dara obj2 = std::move(obj1);
```

Что будет при перемещении `obj1`, а значит и `arr`? Тоже копирование! std::array - это массив, фиксированного размера, расположенный на стеке. Как вы собираетесь его перемещать в другой объект? Под другой объект уже выделена своя память на стеке, вы не можете один кусок стека переместить в другой. Вы можете только скопировать значения.

Можно еще занулить конечно, что обычно этого не происходит из соображений перфоманса.

Получается, что реально "переместить" вы можете только данные, выделенные на куче. И то они никуда не перемещаются. Вы просто копируете указатель из одного объекта в другой, при этом сами данные никак не затрагиваются.

```cpp
struct Data {
	std::string * str;
	// member functions for making it work
};

Data obj1{.str = new std::string("Hello, World!")};
Dara obj2 = std::move(obj1);
```

`obj2` теперь имеет такое же значение указателя str, как и `obj1`, но сама строка оказалась нетронутой.

Более того. Даже если вы используете std::string, то не всегда мув будет быстрее копирования! Thanks to [SSO](https://t.me/grokaemcpp/11).

Получается, что никто никуда не течет. Все так же пресловуто копируется, кроме динамических данных под указателями.

Теперь снова актуализируем вопрос: мувать или копировать?

И ответ уже не плоскости оптимизации, а в плоскости логики кода. Перемещайте, когда вам в текущем скоупе объект больше не нужен и копируйте, если нужен. Тогда вы не пытаетесь оптимизировать код, а передаете владение объектом другому коду. Редко, когда вы на авито продаете вещи, чтобы заработать. Вы их продаете, чтобы от лишнего избавиться и дать их тем, кому они нужны. Вот здесь примерно это и должно происходить.

Think logically. Stay cool.

#cppcore #cpp11




Передача владения
#новичкам 

Захотелось совсем немного развить тему предыдущего поста.

В целом, мув семантика она не столько про оптимизацию(для этого есть например [rvo/nrvo](https://t.me/grokaemcpp/136)), сколько про передачу владения объектами. И то, что std::move ничего не мувает хорошо укладывается в эту концепцию. Не данные перемещаются, а передается владение данными. 

```cpp
void bar(std::vector<int>&& vec) {
	// do nothing
}
void foo() {
	std::vector<int> vec = {1, 2, 3};
	bar(std::move(vec));
}
```

Здесь мы передаем владение вектором из foo в bar. Заметьте, что bar оперирует правой ссылкой, то есть никакие перемещающие конструкторы не вызывались. Но такая сигнатура говорит о главном: bar ожидает эксклюзивного права владения над этим вектором. Вы должны явно мувнуть объект, чтобы вызвать bar. И не важно, что он дальше bar с этим вектором делает. Может ничего не сделает, а может и использует как-то данные. Но так решил автор кода: вызов bar предполагает передачу ему владения вектором.

Другой пример:

```cpp
std::vector<int> double_elements(std::vector<int> vec) {
    for (auto& elem: vec) {
	    elem *= 2;
    }
    return vec;
}

void foo() {
	std::vector<int> vec = {1, 2, 3};
	{
		auto doubled = double_elements(vec);
		std::println("{}", doubled);
	}
	vec.push_back(4);
	{
		auto doubled = double_elements(std::move(vec));
		std::println("{}", doubled);
	}
}

```

Функция double_elements принимает вектор по значению и возвращает набор из удвоенных элементов.

Функция foo 2 раза вызывает удвоение значений элементов. . По логике функции foo, ей еще нужен vec в целости и сохранности(нужно доложить в него элемент). Поэтому она и передает vec в double_elements по значению. Но после второго вызова vec ей больше не нужен. Поэтому можно передать владение им в double_elements: возможно он им распорядится лучше.

Еще одна вещь, которая подчеркивает передачу владения: moved-from объект практически никак нельзя безопасно использовать, кроме как безопасно разрушить. Даже если функция принимает rvalue reference, это не значит, что она не изменяет объект: возможно внутренние вызовы это делают. 

Поэтому считайте, что, передав владение, вы больше физически не имеете права пользоваться объектом. Это как продав компанию, вы бы продолжили иметь то же влияние на нее. Нетушки. Либо крестик снимите, либо трусы наденьте. Либо передали владение и забыли, либо скопировали и дальше попользовались.

Give away what you don't need. Stay cool.

#cppcore #cpp11




![[Pasted image 20251017225433.png]]

![[Pasted image 20251019124247.png]]
Атрибуты лямбды
#опытным 

Во вчерашнем посте код с картинки реально компилируется и, если вы не поняли, что это за чертовщина, то следующие несколько постов будут для вас.

В С++11 у нас появилась возможность указывать атрибуты для функции. Например:

```cpp
[[nodiscard]] int ComplicatedCompute() {
	return 2*2;
}

ComplicatedCompute(); // you got warning: ignoring return value of 'int ComplicatedCompute()', declared with attribute `nodiscard`
```

Вы можете пометить возвращаемое значение функции, как то, которое нельзя игнорировать, и компилятор даст вам по сопатке, если вы его все же заигнорите.

Ну это функции. А как же лямбды? Хочется и для них указывать атрибуты.

И атрибуты для возвращаемого значения лямбды завезли в С++23. Выглядит это так:

```cpp
auto complicated_compute = [] [[nodiscard]] () { return 2 * 2; };

complicated_compute(); // warning: ignoring return value of 'main()::<lambda()>', declared with attribute 'nodiscard'
```

После скобок для захвата вы указываете список атрибутов в квадратных скобках. Выглядит интересно. Не очень элегантно, но интересно.

Одни скажут: "усложнение синтаксиса!". Другие скажут, что давно пора лямбды подтягивать ко всем возможностям обычных функций. 

Тут как бы все просто: не хотите - не используйте. У лямбды и так полно опциональных обвесок, одним больше, одним меньше. Можно определить шаблонную лямбду и обвесить ее всякими концептами с trailing return type. И это будет страшный зверь. Можно сделать отдельный пост, как может выглядеть ультимативная лямбда.

Ну а если вы хотите немного больше синтаксически говорить кодом, то теперь можете использовать атрибуты для лямбд.

Don't ignore. Stay cool.

#cpp23


Атрибуты везде
#опытным

Используют атрибуты не только лишь все, мало кто знает, куда их можно пихать.

Есть на самом деле 3 легальных места для навешивания атрибутов на функцию.

1 Перед типом возвращаемого значения:

```cpp
[[deprecated]] int foo() { return 42; }
```

Тогда он применяется к самой функции.

2 Перед именем функции:

```cpp
int foo [[deprecated]] () { return 42; }
```

Теперь он тоже применяется к самой функции.

3 После параметров:

```cpp
int foo() [[gnu::deprecated]] { return 42; }
```

Тогда атрибут применяется к типу функции, а не к самой функции. Разница вот в чем:

```cpp
int foo() [[gnu::deprecated]] { return 42; }

int main() {
	foo(); // no warnings
	using FuncType = decltype(foo); // use of type is deprecated
}
```

Обычный вызов функции прекрасно компилируется. Но вот использование типа функции через decltype помечается как устаревшее.

Причем gcc и clang по-разному интерпретируют эту ситуацию. Clang говорит, что gnu::deprecated нельзя применять к типам и игнорирует атрибут. Вот [ссылка на годболт](https://godbolt.org/z/Khabv1jrE) для интересующихся.

Соответственно, в лямбде в тех же местах можно ставить атрибуты:

```cpp
auto complicated_compute = [] [[nodiscard]] () [[gnu::deprecated]] {
	return 2 * 2;
};
```

Признавайтесь, знали?)

Have your own opinion. Stay cool.

#cppcore


Множество атрибутов
#опытным 

Если вы хотите указать несколько атрибутов для вашей функции, вы можете использовать следующий синтаксис:

1 Списочный. Внутри одних скобок перечисляете все атрибуты:

```cpp
[[gnu::always_inline, gnu::const, gnu::hot, nodiscard]] int f();
```

2 Многоскобочный. Для больших любителей квадратов. Очень больших:

```cpp
[[gnu::always_inline]] [[gnu::hot]] [[gnu::const]] [[nodiscard]] int f();
```

Больше квадратных скобок!

Также если вы используете несколько атрибутов из какого-то одного неймспейса, то можете использовать директиву using:

```cpp
[[using gnu : always_inline, const, hot]] [[nodiscard]] int f();
```

Но тогда котлеты отдельно, мухи отдельно. Все атрибуты одного неймспейса нужно уносить в отдельные скобки. Это фича С++17.

Что интересно, вы можете написать полную чупуху:

```cpp
[[crypto, is, the, best, investment]] int f();
```

И это скомпилируется! Стандарт поддерживает любые implementation-defined атрибуты. Причем неизвестные атрибуты просто игнорируются. Правда игнор спровождается варнингами, которые тем не менее можно скрыть опциями, подобным -Wno-attributes.

Таким образом, если ваш код компилируется под разные системы, то вы можете не стесняясь использовать дублирующие атрибуты, предоставляемые разными компиляторами. Так на любой платформе можно получить одинаковое поведение.

Love squares. Stay cool.

#cppcore #cpp17


Атрибуты параметров функции
#новичкам 

Атрибуты можно также применять к параметрам функции. Это помогает чуть полнее в коде для пользователей функции аннотировать некоторые свойства параметров.

Однако из стандартных атрибутов по сути имеет смысл использовать только атрибут maybe_unused:

```cpp

```



