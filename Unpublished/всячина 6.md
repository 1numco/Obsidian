
std::from_char
#новичкам 

С++17 нам принес новую прекрасную функцию парсинга строк в числа - std::from_char.

```cpp
std::from_chars_result from_chars(
    const char* first,   // Начало строки (включительно)
    const char* last,    // Конец строки (не включительно)
    IntegerType& value,  // Куда записать результат
    int base = 10        // Система счисления (2-36)
);

std::from_chars_result from_chars(
    const char* first,   // Начало строки (включительно)
    const char* last,    // Конец строки (не включительно)
    FloatType& value,  // Куда записать результат
    std::chars_format fmt = std::chars_format::general // Формат плавающей точки
);
```

На самом деле это два семейства перегрузок функций для целых чисел и чисел с плавающей точкой.

Задача функции - максимально быстро, безо всяких накладных расходов на выделение памяти и поддержку исключений, распарсить строку в число арифметического типа.

Функция возвращает структуру `std::from_chars_result`:

```cpp
struct from_chars_result {
    const char* ptr;  // Указатель на первый НЕпрочитанный символ
    std::errc ec;     // Код ошибки (если успех — `std::errc()`)
};
```

Если парсинг удался и какая-то часть строки конвертировалась в число, то в ptr находится указатель на первый символ, на котором парсинг завершился. Если вся строка была интерпретирована, как число, то в ptr находится last указатель.

Если парсинг неудался, то ptr равен first, а код ошибки ec выставляется в  std::errc::invalid_argument.

```
"123" → удачно распарсили все → ptr == last (конец строки).
"123abc" → распарсили "123" → `ptr` указывает на 'a'.
"abc" → ошибка → ptr == first (начало строки).
```

Примеры работы:

```cpp
const std::string str = "42abc";
int value;
auto res = std::from_chars(str.data(), str.data() + str.size(), value);
if (res.ec == std::errc()) {
	std::cout << "Value: " << value << "\n"; // 42
	std::cout << "Remaining: " << res.ptr << "\n"; // "abc"
}

// ----------------

const std::string str = "xyz";
int value;
auto res = std::from_chars(str.data(), str.data() + str.size(), value);

assert(res.ec == std::errc::invalid_argument);
assert(res.ptr == str.data());  // ptr остался на начале
```

К тому же функция может детектировать переполнение:

```cpp
const std::string str = "99999999999999999999";
int value;
auto res = std::from_chars(str.data(), str.data() + str.size(), value);
assert(res.ec == std::errc::result_out_of_range);
```

В чем главный прикол этой функции?

Если у вас есть строка с последовательностью чисел, разделенных запятой, то вы просто в цикле можете передвигать нужные указатели и парсить числа одно за другим. Тот же std::stoi выкинул бы исключение и пошел пиво пить:

```cpp
const std::string str = "123,456,789";
std::vector<int> numbers;
const char* current = str.data();
const char* end = str.data() + str.size();

while (current < end) {
	int value;
	auto res = std::from_chars(current, end, value);
	if (res.ec != std::errc()) {
		std::cerr << "Parsing error!\n";
		break;
	}
	
	numbers.emplace_back(value);
	current = res.ptr; // Сдвигаем указатель
	// Пропускаем разделитель (запятую)
	if (current < end && *current == ',') {
		++current;
	}
}

for (int num : numbers) {
	std::cout << num << " ";
}
// Вывод: 123 456 789
```

К тому же ее целочисленный вариант с С++23 constexpr, что позволить вам парсить строку в числа даже во время компиляции.

Если вы не любите исключения - std::from_char ваш выбор.

Be efficient. Stay cool.

#cpp17 #cpp23


std::to_chars
#новичкам 

В C++17 появилась не только функция для парсинга (std::from_chars), но и её обратная версия — std::to_chars, которая позволяет конвертировать числа (int, float, double и др.) в строки без дополнительных затрат на выделение памяти и поддержку исключений.

```cpp
std::to_chars_result to_chars(char* first, char* last,
                             IntegerType value,
                             int base = 10);  // (1)

std::to_chars_result to_chars(char* first, char* last,
                             FloatType value,
                             std::chars_format fmt);  // (2)

std::to_chars_result to_chars(char* first, char* last,
                             FloatType value,
                             std::chars_format fmt,
                             int precision);  // (3) (since C++23)
struct to_chars_result {
    const char* ptr;
    std::errc ec;
};
```

Единственный случай, когда эта функция может зафейлиться - если вы передали слишком маленький буффер. Тогда ec выставляется в std::errc::value_too_large, а ptr в last.

В чем преимущество функции по сравнению со старой-доброй std::to_string?

1 Можно задать точность и основание системы счисления.

2 Отсутствуют динамические аллокации внутри функции.

Вот вам пример работы:
```cpp
char buffer[20];
int value = 12345;

auto result = std::to_chars(buffer, buffer + sizeof(buffer), value);
if (result.ec == std::errc()) {
	size_t result_length = result.ptr - buffer;
	std::string_view str_result(buffer, result_length);
	std::cout << "Result: " << str_result << "\n"; // "12345"
}

// ------------------------

double pi = 3.1415926535;
char buf[20];

auto result = std::to_chars(buf, buf + sizeof(buf), pi, std::chars_format::fixed, 4);
if (result.ec == std::errc()) {
	size_t result_length = result.ptr - buf;
	std::string_view str_result(buf, result_length);
	std::cout << "Result: " << str_result << "\n"; // "3.1416"
}
```

Не всегда проблема точности и аллокаций - это реальная проблема. Но если вы работаете с ограниченной кучей и хотите стандартное средство конвертации числа в строку - std::to_char как раз для вас.

Be efficient. Stay cool.

#cpp17



Разница между std::stoi+std::to_string и std::from_chars+std::to_chars
#опытным


В C++ есть два основных подхода к конвертации чисел в строки и обратно:

Старомодный  — std::stoi, std::to_string (C++11)

Модномолодежный — std::from_chars, std::to_chars (C++17)

В чем принципиальная разница между ними и когда какой подход использовать? Сегодня мы широкими мазками ответим на эти вопросы.

Особенности старомодного подхода:

- Основное - это исключения. Все нештатные ситуации обрабатываются с их помощью, что ведет к неким накладным расходам.
- Работа в высокоуровневом ООП стиле. Используются классы и возвращаются классы, без всяких сырых буферов.
- Нет контроля над парсингом. Нет возможности задать формат, основание системы счисления или точность.
- Поддержка локалей. Грубо говоря, это механизм для учёта региональных особенностей представления данных. То есть std::stoi, std::to_string реализованы с учетом возможности спецификации локалей и соотвественно изменения результатов конвертации. С локалями возможна такая штука:
```cpp
// В США (локаль "en_US"):
std::to_string(3.14);  // "3.14" (точка как разделитель)

// В Германии (локаль "de_DE"):
std::to_string(3.14);  // Может вернуть "3,14" (запятая)!
```
Естественно, что поддержка такой фичи обходится дорого.

Особенности модномолодежного подхода:

- Функции std::from_chars, std::to_chars сроектированы быть настолько легкими и быстрыми, насколько это возможно на таком уровне абстракции.
- Отсутствие намеренных динамических аллокаций. Только вы решаете, где расположена память по данные.
- Отсутствие исключений. Функции возвращает объект ошибки, который явно нужно проверять руками.
- Не проверяет локали.
- Поддерживают частичный парсинг.
- Поддержка явной гарантии round-trip. Если вы запишите в строку число с помощью std::to_chars и прочитаете его с помощью std::from_chars, то вы всегда получите изначальный результат. Главное, чтобы обе функции были вызваны с использованием одинаковой реализации стандартной библиотеки. Но у std::stoi, std::to_string и этого нет.


Если вы работаете в высоконагруженном или ограниченном по производительности окружении, то ваш выбор явно std::from_chars, std::to_chars. Обычно в коде таких приложений отказываются от использования исключений, поэтому проблем с код-стайлом не будет. 

Возможность поэтапного парсинга также не оставляет выбора - используйте std::from_chars.

Если вы не паритесь за производительность, любите объекты, вам не нужен частичный парсинг или каждый раз при виде слова exception у вас начинает идти пена изо рта, то придерживайтесь старого подхода, ничего плохого в этом нет.

Choose the right tool. Stay cool.

#cppcore #cpp11 #cpp17



Modern pimpl идиома
#новичкам 

[В одном из давнишних постов ](https://t.me/grokaemcpp/107) мы уже обсуждали базовую формулировку и реализацию идиомы pimpl. Это сырой указатель на forward-объявленную структуру.

В современных плюсах, естественно, никто уже так не делает. Сырые указатели уходят в прошлое и старые подходы пересматриваются с применением умных указателей.

Допустим, вы используете какой-то нестандартный формат сериализации данных, например apache avro. Конечно вы хотите написать свою библиотеку сериализации, которая позволить конвертировать данные в/из avro формата. Как должна выглядеть эта библиотека?

Ну скорее всего вы хотите использовать только доменные сущности в интерфейсе библиотеки. В этом случае только она зависит от стороннего решения и вы в любой момент смогли, например, изменить формат сериализации. Также приятно иметь стабильный интерфейс и линковать стороннее решение только с этой библиотекой.

С такими симптомами ваш терапевт прописал вам однократный прием pimpl идиомы. Выглядеть это может так:

```cpp
// serializer.hpp
class Serializer {
public:
    Serializer();
    ~Serializer();
    
    // only move-semantic
    Serializer(const Serializer&) = delete;
    Serializer& operator=(const Serializer&) = delete;
    Serializer(Serializer&&) noexcept;
    Serializer& operator=(Serializer&&) noexcept;

    std::vector<uint8_t> serializeOrder(const domain::Order& person);
    domain::Order deserializeOrder(const std::vector<uint8_t>& data);
private:
    std::unique_ptr<struct Impl> pimpl_; // Smart pointer on forward-declared struct
};

// serializer.cpp

struct Serializer::Impl {
    avro::GenericRecord convertToAvro(const domain::Order&);
    domain::Order convertFromAvro(const avro::GenericRecord&);
};

Serializer::Serializer() 
    : pimpl_(std::make_unique<Impl>()) {
}

Serializer::~Serializer() = default;
Serializer::Serializer(Serializer&&) noexcept = default;
Serializer& Serializer::operator=(Serializer&&) noexcept = default;

std::vector<uint8_t> Serializer::serializeOrder(const domain::Person& person) {
    auto record = pimpl_->convertToAvro(person);
    return {...};
}
// deserializeOrder
```

Основная идея - все упоминания и детали реализации avro находятся в cpp и не торчат наружу. Мы имеем стабильный интерфейс, стабильный ABI и сокращенное время линковки. А за счет использования std::unique_ptr у нас тривиальные реализации всех специальных методов.

Примерно так это и выглядит в современных плюсах. Но это еще не конец для pimpl. Есть решение, которое поможем вам избежать динамических аллокаций. Но об этом в другой раз.

Hide details. Stay cool.

#design 


**Зачем в pimpl определять специальные методы в cpp?**
#опытным 

В прошлом посте вы могли заметить, что все специальные методы класса Serializer только объявляются в хэдере, а реализуются в файле исходников. Зачем так делать?

```cpp
class Serializer {
public:
    Serializer();
    ~Serializer();
    
    // only move-semantic
    Serializer(const Serializer&) = delete;
    Serializer& operator=(const Serializer&) = delete;
    Serializer(Serializer&&) noexcept;
    Serializer& operator=(Serializer&&) noexcept;

    //...
private:
    std::unique_ptr<struct Impl> pimpl_;
};
```

Мы ведь привыкли либо вообще не определять никакие специальные методы по правилу нуля, либо просто помечать их default и все. Почему в этот раз так нельзя сделать?

Все дело в нашем особенном указателе pimpl_. Это умный указатель на forward-объявленную структуру. Это значит, что мы не знаем примерно ничего об этой структуре, кроме ее имени. И в этом загвоздка. Компилятор на данный момент не знает, как выглядят ее деструктор и перемещающие методы.

Когда мы явно помечаем специальные методы класса как default, мы явно просим компилятор за нас сгенерировать определение этих методов. 

```cpp
class Serializer {
public:
    Serializer();
    ~Serializer() = default; // Here
    
    // only move-semantic
    Serializer(const Serializer&) = delete;
    Serializer& operator=(const Serializer&) = delete;
    Serializer(Serializer&&) noexcept = default; // Here
    Serializer& operator=(Serializer&&) noexcept = default; // Here

    //...
private:
    std::unique_ptr<struct Impl> pimpl_;
};
```

**То есть мы запрашиваем определение метода в теле класса**. На основе чего компилятор будет генерировать их? На основе того, что есть в теле класса. 

Но вот беда, в теле класса нет никакой информации о том, что из себя представляет класс Impl. Возьмем тот же деструтор. По дефолту std::unique_ptr вызывает просто `delete ptr` . А у delete expression есть пометка, что при удалении указателя на неполный тип программа становится ill-formed. Поэтому компиляторы на случай, если вы захотите сгенерировать деструктор std::unique_ptr с неполным типом, ставят такой ассерт времени компиляции: `static_assert(sizeof(_Tp)>0, "can't delete pointer to incomplete type");`. А компиляция последнего примера крашнется с соотвествующей ошибкой.

Так что определяйте специальные методы в реализации и будет вам счастье.

Don't give impossible tasks. Stay cool.

#cppcore #design 



Квиз

Сегодня #quiz на любимую тему всех плюсовиков - утечку памяти. 

Исключения в конструкторе представляют особый интерес с точки зрения исследования цикла жизни объекта и на собесах нет-нет да и спросят что-нибудь про исключения в конструкторах. Поэтому в этой теме надо бы разбираться.

Спасибо [Сергею Борисову](@borisov_s_s) за идею для поста)

Ну а сейчас у меня для вас всего один вопрос. **Будет ли в этом коде утечка памяти или нет?**

```cpp
class Bar {
public:
    Bar() {
        throw std::runtime_error("Error");
    }
};

int main() {
    Bar *bar = nullptr;

    try {
        Bar *bar = new Bar();
    } catch(...) {
        std::cout << "Houston, we have a problem" << std::endl;
    }
}
```

Будет ли в этом коде утечка памяти в коде выше?


Ответ
#новичкам 

В этом коде:

```cpp
class Bar {
public:
    Bar() {
        throw std::runtime_error("Error");
    }
};

int main() {
    Bar *bar = nullptr;

    try {
        Bar *bar = new Bar();
    } catch(...) {
        std::cout << "Houston, we have a problem" << std::endl;
    }
}
```

Не будет утечки памяти.  Стандарт нам это гарантирует при использовании new expression.

Дело вот в чем. В [этом посте](https://t.me/grokaemcpp/608) мы поговорили о том, что есть 3 вида new: 
- operator new, который выделяет память
- placement new, который вызывает конструктор на заданной памяти.
- new expression, который в начале выделяет память через operator new, а потом конструирует объект на этой памяти через placement new.

Так вот new expression заботится о своих пользователях и оборачивает в try-catch вызов конструктора объекта. В catch оно освобождает память и пробрасывает исключение наружу:

```cpp
Bar *bar = new Bar();
// инструкция выше эквивалентнас следующему коду:
Bar* bar;
void* tmp = operator new(sizeof(Bar));
try {
	new(tmp) Bar(); // Placement new
	p = (Bar*)tmp; // The pointer is assigned only if the ctor succeeds
}
catch (...) {
	operator delete(tmp); // Deallocate the memory
	throw; // Re-throw the exception
}
```

И получается, что и исключение есть, и память освобождена. Таким образом new обеспечивает базовую гарантию исключений, чтобы программа осталась в согласованном состоянии и отсутствовали утечки памяти.

Вообще, это даже интересная техника. Ловить исключение, заметать следы преступления и пробросить исключение дальше. Может помочь избежать утечек памяти в конструкторах ваших классов, которые сами внутри выделяют память.

Спасибо, @PyXiion за предоставленную информацию)

Don't let your memory leak. Stay cool.

#cppcore #memory 


Capture this
#новичкам 

Бывают ситуации, когда вы хотите зарегистрировать коллбэк, в котором будет выполняться метод текущего класса. 

Например, вы пишите класс приложения. Правила хорошего тона говорят вам, что нужно добавить поддержку graceful shutdown. Для этого получаем объект обработчика сигнала и регистрируем коллбэк на SIGINT и SIGTERM:

```cpp
struct Application {
	Application() {
		SignalHandler::GetSignalHandler().RegisterHandler([](){
			Shutdown();
		});
	}

	void Shutdown() {...}
};
```

Сработает ли такой код?

Он не соберется. Будет ошибка: `'this' was not captured for this lambda function`. Методу Shutdown нужен объект, на котором его нужно вызвать.

Для этого в С++11 вместе с лямбдами ввели захват this. Это значит, что в лямбду сохраняется копия указателя на текущий объект. А синтаксис лямбды позволяет в таком случае не использовать явно this в ее теле:

```cpp
struct Application {
	Application() {
		SignalHandler::GetSignalHandler().RegisterHandler([this](){
			// this->Shutdown(); - don't need this syntax
			Shutdown();
		});
	}

	void Shutdown() {...}
};
```

До С++20 кстати можно было захватывать this в лямбду с помощью дефолтного захвата по значению и по ссылке:

```cpp
SignalHandler::GetSignalHandler().RegisterHandler([= /*& also works*/](){ // works
	Shutdown();
});
```

Однако в С++20 запретили неявный захват this по значению(что очень хорошо)

Be explicit. Stay cool.

#cppcore #cpp11 #cpp20




Почему важно проверять входные данные
#новичкам 

Вы делаете какие-то вычисления и среди них есть целочисленное деление:

```cpp
void fun(int a, int b) {
	// some calculations
	auto res = a / b;
	// some calculations
}

```

Вы уже наслышаны о том, что в С++ есть механизм обработки исключений и просто оборачиваете вашу функцию в try-catch и думаете, что С++ позаботится о том, что вы будете информированы о всех проблемах, которые могут произойти в коде:

```cpp
try {
	fun(1, 2);
} catch(std::exception& ex) {
	std::cout << "Calculation error: " << ex.what() << std::endl;
}
```

Однако помните, что вы пишите на С++. Здесь уровень заботы примерно, как у бати, который вывозит неумеющего плавать сына на середину реки и бросает его в виду с криками "Плыви, сынок!".

Если вдруг вы передадите в fun вторым параметром ноль:

```cpp
try {
	fun(1, 0);
} catch(std::exception& ex) {
	std::cout << "Calculation error: " << ex.what() << std::endl;
}
```

то С++ не пошлет исключение об этой ситуации.

Стандарт явно говорит: целочисленное деление на ноль приводит к неопределенному поведению. У меня например программа просто падает с надписью: `Floating point exception`. Очень иронично со стороны компилятора обрабатывать эту ситуацию, выводя в консоль текст о появлении исключения, хотя его тут нет и его никак не отловить.

Поэтому нужно проверять входные данные и самим явно кидать исключения:

```cpp
void fun(int a, int b) {
	if (!b) {
		throw std::runtime_error("Devision by zero!");
	}
	// some calculations
	auto res = a / b;
	// some calculations
}

try {
	fun(1, 0);
} catch(std::exception& ex) {
	std::cout << "Calculation error: " << ex.what() << std::endl;
}
```

Тогда на консоль явно выведется ожидаемое `Calculation error: Devision by zero!`.

Так что будьте осторожны и проверяйте входные данные.

Stay alert. Stay cool.

#cppcore


Just throw it forward
#новичкам 

Работа с исключениями - целое искусство. В этой теме куча фишек, которые помогут извлекать из исключений максимум пользы.

Пусть вы хотите работать с какой-то сущностью в коде эксклюзивно:

```cpp
void func(std::shared_ptr<Resource> res) {
	if (res->TryToAcquire()) {
		// do dirty things
	} else {
		// you don't have permission to do dirty, so return
		return;
	}
}
```

Что будет, если в результате обработки эксклюзивно захваченного ресурса произойдет исключение?

Правильно, утечка. Утечка ресурса. Вы его больше не сможете захватить и он так и останется в подвешанном состоянии.

Хорошо бы отловить исключение и освободить ресурс. Однако привычная обработка исключений тут особо не поможет. Мы на этом слое вызовов не можем адекватно обработать исключение, у нас просто недостаточно информации и полномочий, чтобы принять решение.

То есть нам как-то нужно сделать 2 вещи одновременно: дать исключению выйти наружу и освободить ресурс. 

В этом поможет простой вызов "throw".

```cpp
void func(std::shared_ptr<Resource> res) try {
	if (res->TryToAcquire()) {
		// do dirty things
	} else {
		// you don't have permission to do dirty, so return
		return;
	}
} catch(std::exception& ex) {
	res->Release();
	throw;
}
```

Инструкция throw делает единственную вещь - пробрасывает то же самое исключение выше по стеку вызовов.

Получается, что можно и рыбку съесть и ... освободить ресурс.

Полезная фишка. Не обязательно полностью обрабатывать исключения на текущем уровне, но можно позаботится о том, чтобы программа находилась в согласованном состоянии без потеряных по пути бойцов.

Don't leak your resources. Stay cool.

#cppcore 


Обогащаем исключение
#новичкам 

Еще один простой и известный лайфхак, как можно более эффективно работать с исключениями.

Вот пилишь проект на 100500 строк кода. Запускаешь и вылетает ошибка: "абракадабра, ты хреновый программист". И как понять, откуда это исключение прилетело? 

И начинается. Все обкладывается принтами и смотрится после какого принта программа падает. Но можно сделать немного умнее.

Пусть у вас в проекте активно используется библиотека для работы с базой данных. При возникновении непредвиденной ситуации библиотека генерирует исключение. Однако мест, где вы используете базу, много. И вам хотелось бы понимать примерный путь пролетания исключения, чтобы лучше понимать ситуацию для отладки.

В прошлом посте мы просто прокидывали исключение дальше, без добавления в него какой-то информации. Но можно бросить новое исключение и передать туда сообщение об ошибке первого:

```cpp
void ComplicatedCalculations() try {
	// use db
} catch (std::exception& ex) {
	throw std::runtime_error(std::string("ComplicatedCalculations Error:") + ex.what());
}

void HandlingCalculations() try {
	ComplicatedCalculations();
} catch (std::exception& ex) {
	throw std::runtime_error(std::string("HandlingCalculations Error:") + ex.what());
}
```

В итоге мы получаем фактически стек вызовов, который пролетает исключение. И уже намного проще найти место конкретной проблемы, особенно если есть информативные логи.

Однако в результате будет длинная строка из всех вызовов. Плюс не очень хочется повторять вот этот паттерн с "+ ex.what()". 

И у данной проблемы есть интересное решение, о котором мало кто из вас слышал. Об этом мы поговорим в следующий раз.

Track your problems to the bottom. Stay cool.

#cppcore

Засовываем исключение в исключение
#опытным 

Вы знали, что в плюсах есть вложенные исключения? Такие исключения могут хранить в себе несколько исключений. Сегодня мы посмотрим, что это за зверь такой.

Начнем с применения. В прошлом посте мы создавали новое исключение на основе строки ошибки обрабатываемого исключения. В этом случае нужно писать определенное количество бойлерплейта и теряется информация о типе изначального исключения. Чтобы избежать этих проблем, мы можем бросить новое исключение, которое будет в себе содержать старое:

```cpp
void ComplicatedCalculations() try {
	// use db
} catch (std::exception& ex) {
	std::throw_with_nested(std::runtime_error("Complicated Calculations Error"));
}

void HandlingCalculations() try {
	ComplicatedCalculations();
} catch (std::exception& ex) {
	std::throw_with_nested(std::runtime_error("Handling Calculations Error"));
}
```

Теперь исключение, которое вылетит из HandlingCalculations будет на самом деле  содержать 3 исключения: от базы данных, от ComplicatedCalculations и от HandlingCalculations.

Вложенные исключения существуют с С++11 и очень интересно устроены. Рассмотрим несколько упрощенные версии сущностей, которые находятся под капотом механизма вложенных исключений. Есть класс std::nested_exception:

```cpp
class nested_exception
{
	exception_ptr _M_ptr;
public:
    /// The default constructor stores the current exception (if any).
    nested_exception() noexcept : _M_ptr(current_exception()) { }
...
};
```

Этот класс ответственен за захват текущего исключения с помощью вызова std::current_exception(). 

Дальше имеется класс, который хранит в себе все множество исключений:

```cpp
template<typename Except>
struct Nested_exception : public Except, public nested_exception
{
	explicit Nested_exception(const Except& ex)
		: Except(ex) { }
};
```

Объекты этого класса наследуются от nested_exception, в котором захвачено старое исключение, и от Except - нового исключения. 

Ну и последний компонент - std::throw_with_nested:

```cpp
template<typename Tp>
[[noreturn]]
inline void throw_with_nested(Tp&& t)
{
	throw Nested_exception<remove_cvref_t<Tp>>{std::forward<Tp>(t)};
}
```

При вызове throw_with_nested создается объект Nested_exception на основе переданного типа исключения и, неявно, nested_exception, которых сохраняет в себе указатель на старое исключение.

Получается, что мы при каждом вызове throw_with_nested подмешиваем новое исключение к старому с помощью множественного наследования.

Очень прикольная техника, которая позволяет строить цепочки объектов. Это как тупл, только расширяемый в рантайме.

Это все хорошо и интересно. Прокидывать вложенные исключения мы научились. Но рано или поздно их придется обработать. Как это сделать? Об этом будем говорить в следующем посте.

Inherit knowledge from your ancestor. Stay cool.

#cppcore #cpp11

Раскрываем вложенное исключение
#опытным 

Каша заварилась, пришло время расхлебывать. В прошлом посте мы успешно завернули кучу исключений в одно, теперь нужно как-то все обратно развернуть. Для этого существует функция std::rethrow_if_nested. Работает она вот так:

```cpp
class nested_exception
{
	exception_ptr _M_ptr;
public:
    /// The default constructor stores the current exception (if any).
    nested_exception() noexcept : _M_ptr(current_exception()) { }

	[[noreturn]] void
    rethrow_nested() const {
		if (_M_ptr)
			// just throw _M_ptr
			rethrow_exception(_M_ptr);
		std::terminate();
    }
...
};

template<class E>
void rethrow_if_nested(const E& e) {
	if (auto p = dynamic_cast<const std::nested_exception*>(std::addressof(e)))
		p->rethrow_nested();
}

```

Так как объект вложенного исключения - это наследник std::nested_exception, то мы имеем право динамически привести указатель переданного в rethrow_if_nested исключения к std::nested_exception. Если каст прошел успешно, то бросается исключение, сохраненное в nested_exception. Если каст провалился, значит `E` - это уже не наследник nested_exception и у нас в руках самое первое исключение в цепочке.

Обычно в статьях по этой теме приводят мягко говоря странные примеры того, как надо обрабатывать вложенные исключения:

```cpp
int main() {
	try {
		Login("test@example.com", "secret");
	} catch (SecurityError& e) {
		std::cout << "Caught a SecurityError";
		try {
			std::rethrow_if_nested(e);
		} catch (AuthenticationError& e) {
			std::cout
			<< "\nNested AuthenticationError: "
			<< e.Email;
		}
	}
	std::cout << "\nProgram recovered";
}
```

Встречайте вложенные try-catch с заранее известной глубиной вложенности. Это конечно никуда не годится.

В реальности при повсеместном использовании вложенных исключений мы не знаем, сколько раз нам нужно сделать rethrow_if_nested. Но при этом мы точно знаем, что если исключение последнее в цепочке, то rethrow_if_nested ничего не сделает. Это же идеальное условие для остановки рекурсии!

Рекурсия решает проблему неопределенного количества уровней вложенности исключений и помогает удобно подряд печатать соответствующие сообщения об ошибках:

```cpp

void print_exception(const std::exception& e, int level =  0)
{
    std::cerr << std::string(level, ' ') << "exception: " << e.what() << '\n';
    try {
        std::rethrow_if_nested(e);
    }
    catch (const std::exception& nestedException) {
        print_exception(nestedException, level + 1);
    }
    catch (...) {}
}

void ComplicatedCalculations() try {
	// use db
} catch (std::exception& ex) {
	std::throw_with_nested(std::runtime_error("Complicated Calculations Error"));
}

void HandlingCalculations() try {
	ComplicatedCalculations();
} catch (std::exception& ex) {
	std::throw_with_nested(std::runtime_error("Handling Calculations Error"));
}

int main() {
	try {
		HandlingCalculations();
	} catch (const std::exception& e) {
		print_exception(e);
	}
}
// OUTPUT:
// Handling Calculations Error
//  Complicated Calculations Error
//   Some DB Error
```

В этом случае на добавление дополнительной информации к исключению вы тратите всего 1 строчку, которая мало чем отличается от возбуждения нового исключения. Плюс в коде логики проекта вы одной строчкой обрабатываете все вложенные исключения. Красота!

Очень нишевая функциональность, которую вы вряд ли встретите в реальных проектах. Однако будет прикольно попробовать ее в своих пет-проектах, если вы не гнушаетесь исключений.

Have a good error handling system. Stay cool.

#cppcore #cpp11




Квиз

Сегодня потенциально самый необычный #quiz на канале. Воистину, C/С++ - это самые интересные языки из существующих. Столько безобразия можно с ними натворить. С одной стороны, это мешает языкам выходить в мейнстрим "патамушта небезопасна". С другой стороны, здесь максимальная свобода творчества и полета фантазии.

**У меня для вас всего один вопрос: Что произойдет в результате попытки компиляции и запуска этого С-кода:**

```cpp
const int main[] = {
	-98693133, -443987883, 440, 113408,
	-1922629632, 4149, 1227264, 84869120,
	15544, 266023168, 1970231557, 1701994784,
	1701344288, 1936024096, -1878384268, 258392925
};
```

Тут даже думать не нужно, если вы не компьютер. Выбирайте то, что подсказывает ваше сердце.

Сhoose with your heart. Stay cool.


Варианты ответа:

Это ж даже не программа. Ошибка компиляции.

Даже если и скомпилируется, исполняемый файл не сформируется, функции main ведь нет.

Операционка в ужасе будет максимально злостно прибивать эту программу, вы этими циферками явно ее ядро переписать хотели.

Segfault or not segfault...

Этот код поднимает ковид из мертвых. Запасаемся масками!

На консоль выведется "Hello, World!"

Код запустится, но ничего не выведется.

На консоль выведется "You are the best!"


Ответ
#опытным

Ну что. Пора раскрывать карты. 

Правильных ответов здесь несколько и все зависит от версии компилятора и опций компиляции. Интереснее всего смотреть, что получится при использовании gcc9 и меньше без опций. 

А получится вот что. Программа успешно скомпилируется и на консоли появится сообщение:

```
You are the best!
```

Да, да. Это она про вас, наши подписчики.

Дело вот в чем.  Есть такой варнинг в gcc: **warning:** '**main**' is usually a function [**-Wmain**]. Погодите, main "обычно" является функцией. Это что, может быть не так?

В С на самом деле нет прям жесткого требования на тип символа main. Он в целом может быть и массивом:
```c
char main[10];
```
хоть указателем на функцию:
```c
void (*main)();
```

И вот здесь начинается пространство для экспериментов. Адрес main - это место, с которого код начинается исполняться. Если мы каким-то образом запихаем инструкции ассемблера в массив, то мы сможем выполнить код в такой программе!

Ну а дальше дело техники. Пишем прокси программу:

```c
void main() {
	__asm__ (
		// print You are the best!
		"movl $1, %eax;\n" /* 1 is the syscall number for write */
		"movl $1, %ebx;\n" /* 1 is stdout and is the first argument */
		// "movl $message, %esi;\n" /* load the address of string into the second argument*/
		// instead use this to load the address of the string
		// as 16 bytes from the current instruction
		"leal 16(%eip), %esi;\n"
		"movl $18, %edx;\n" /* third argument is the length of the string to print*/
		"syscall;\n"
		// call exit (so it doesn't try to run the string Hello World
		// maybe I could have just used ret instead
		"movl $60,%eax;\n"
		"xorl %ebx,%ebx; \n"
		"syscall;\n"
		// Store the You are the best! inside the main function
		"message: .ascii \"You are the best!\\n\";"
	);
}
```

Компилируем ее и запускаем gdb для дизассемблирования main:
```gdb
(gdb) disass main
Dump of assembler code for function main:
   0x0000000000001129 <+0>:     endbr64 
   0x000000000000112d <+4>:     push   %rbp
   0x000000000000112e <+5>:     mov    %rsp,%rbp
   0x0000000000001131 <+8>:     mov    $0x1,%eax
   0x0000000000001136 <+13>:    mov    $0x1,%ebx
   0x000000000000113b <+18>:    lea    0x10(%eip),%esi        # 0x1152 <main+41>
   0x0000000000001142 <+25>:    mov    $0x12,%edx
   0x0000000000001147 <+30>:    syscall 
   0x0000000000001149 <+32>:    mov    $0x3c,%eax
   0x000000000000114e <+37>:    xor    %ebx,%ebx
   0x0000000000001150 <+39>:    syscall 
   0x0000000000001152 <+41>:    pop    %rcx
   0x0000000000001153 <+42>:    outsl  %ds:(%rsi),(%dx)
   0x0000000000001154 <+43>:    jne    0x1176 <__libc_csu_init+6>
   0x0000000000001156 <+45>:    (bad)  
   0x0000000000001157 <+46>:    jb     0x11be <__libc_csu_init+78>
   0x0000000000001159 <+48>:    and    %dh,0x65(%rax,%rbp,2)
   0x000000000000115d <+52>:    and    %ah,0x65(%rdx)
   0x0000000000001160 <+55>:    jae    0x11d6
   0x0000000000001162 <+57>:    and    %ecx,(%rdx)
   0x0000000000001164 <+59>:    nop
   0x0000000000001165 <+60>:    pop    %rbp
   0x0000000000001166 <+61>:    retq   
End of assembler dump.
```

Ну и пожалуйста. Слева четко видим шестнадцатиричные числа, которые и представляют собой тело функции main.

Единственное, что осталось - вывести эти числа в десятиричной форме по 4 байта, как инты:

```gdb
(gdb) x/16dw main
0x1129 <main>:  -98693133       -443987883      440     113408
0x1139 <main+16>:       -1922629632     4149    1227264 84869120
0x1149 <main+32>:       15544   266023168       1970231557      1701994784
0x1159 <main+48>:       1701344288      1936024096      -1878384268     258392925
```

Делайем из этих чиселок массив и готово! Закодированная программа будет выполняться.

Есть ощущение, что в более новых версиях компиляторов эту лавочку прикрыли, потому что на gcc10 и более такая прога сегфолтится.

Но в любом случае, очень прикольно, что есть такая возможность.

Можете поиграться с кодом на [годболте](https://godbolt.org/z/56r3bGqdb). Также можно почитать [статью](https://jroweboy.github.io/c/asm/2015/01/26/when-is-main-not-a-function.html), в которой автор подробно расписал историю исследования возможности так писать код.

Благодарю @PyXiion за предоставление материалов для этого поста.

Be amazed. Stay cool.

#fun #OS 


Почему еще важен std::forward
#опытным 

Подписчик @Ivaneo предложил новую рубрику #ЧЗХ, в рамках которой мы будем рассматривать мозголомательные примеры кода и пытаться объяснить, почему они работают так криво. 

Он же предложил следующий пример:

```cpp
#include <iostream>

void bar(float&& x) { std::cout << "float " << x << "\n"; }
void bar(int&& x) { std::cout << "int " << x << "\n"; }

void foo(auto&& v) { bar(v); }

int main() {
	foo(1);
	foo(2.0f);
}
```

Как думаете, что выведется на консоль? Подумайте пару секунд.

Ну нормальный человек ответит:

```
int 1
float 2
```

Однако командная строка вам выдаст следующее:

```
float 1
int 2
```

Если не верите, по посмотрите в [годболте](https://godbolt.org/z/7v1W9WdG6). И можете уже сейчас написать в комментах: "ЧЗХ", "WTF", "WAT" и прочее.

А нам пораразбираца.

Тут используется auto в аргументах функции, значит эта функция неявно шаблонная. Посмотрим, что нам выдаст [cppinsights](https://cppinsights.io/s/8e857fc7) по этому коду:

```cpp
#ifdef INSIGHTS_USE_TEMPLATE
template<>
void foo<int>(int && v)
{
  bar(static_cast<float>(v));
}
#endif


#ifdef INSIGHTS_USE_TEMPLATE
template<>
void foo<float>(float && v)
{
  bar(static_cast<int>(v));
}
#endif
```

Просто прекрасно. Какого черта компилятор кастит переменные к противоположным типам?

Первое, что важно понимать: внутри функции foo переменная `v` - это уже lvalue, так как имеет имя. Значит просто так вызвать перегрузки для правых ссылок он не может. 

Но у компилятора в кармане есть стандартные преобразования, которые и идут в ход, когда нет подходящих перегрузок. Обычно это неявные преобразования из одного типа в другой.

То есть происходит следующее: компилятор понимает, что подходящей перегрузки нет, поэтому начинает применять стандартные преобразования в другие типы. Любой каст дает временный объект. А временный объект типа int легко биндится к float&&, как и временный объект float легко биндится к int&&.

Вот и получается обмен вызовами.

Чтобы такого не происходило, применяйте перед сном std::forward. Если есть контекст вывода типов, то он помогает правильно передавать категорию выражения объекта во внутренние вызовы.

```cpp
#include <iostream>

void bar(float&& x) { std::cout << "float " << x << "\n"; }
void bar(int&& x) { std::cout << "int " << x << "\n"; }

void foo(auto&& v) { bar(std::forward<decltype(v)>(v)); }

int main() {
	foo(1);
	foo(2.0f);
}
```

В этом случае вывод будет ожидаемым.

Be amazed. Stay cool.
#cppcore #cpp11 #template


std::clamp
#опытным 

Иногда у модулей приложения могут быть ограничения по диапазону значений. Например, скорость игрока. Как бы он не замедлялся, скорость не будет меньше нуля, и как бы он не ускорялся, она не будет больше max значения. Или координаты персонажа на ограниченном игровом поле.

И чтобы не городить подобных конструкций:

```cpp
if (value < min) {
	value = min;
}
if (value > max) {
	value = max;
}
```

есть замечательная стандартная функция std::clamp. Она полностью инкапсулирует логику ограничения значения сверху и снизу:

```cpp
template<class T>
constexpr const T& clamp( const T& v, const T& lo, const T& hi );
```

Теперь ограничивать значения переменным проще, чем написать Hello, World.

```cpp
double increment_speed(double curr_speed, double acceleration, double time_delta) {
	curr_speed += acceleration * time_delta;
	return std::clamp(curr_speed, kMinSpeed, kMaxSpeed);
}
```

Не самая широкоизвестная функция, однако круто, что в стандарте есть такие нишевые утилитарные инструменты. Они уже протестированы за вас, максимально обобщены и адекватно названы.

Вряд ли вы заходите в такие глубины стандарта и cppreference, чтобы std::clamp попалась вам на глаза. Поэтому и решил здесь рассказать про нее.

Don't reinvent the wheel. Stay cool.

#STL


Как определять константы локальных функций
#новичкам

Когда мы определяем константу в скоупе функции у нас есть несколько вариантов, как это сделать: пометить const, constexpr, const static, constexpr static. Какой вариант выбрать?

Идентификатор constexpr говорит о том, что значение переменной обязательно должно быть известно во время компиляции. Просто const перед локальной переменной такого не требует, это обычная константа времени выполнения. Ну а [static в этом контекcте](https://t.me/grokaemcpp/258) продлевает время жизни переменной до конца работы программы. 

Особенности функционала диктуют кейсы применения.

1 Если константа зависит от входных данных функции, то ее нужно помечать, как const. constexpr здесь по определению не подойдет, не-consteval функции могут выполняться в рантайме, а в consteval функциях входные параметры не считаются за constexpr. static тоже, потому что один раз определив статическую константу, вы ее не сможете поменять.

```cpp
std::pair<double, double> normalizeVector(double x, double y) {
    const double LENGTH = std::sqrt(x * x + y * y); // Зависит от x и y
    return {x / LENGTH, y / LENGTH};
}
```

2 Если константа не зависит от входных данных функции и она известна во время компиляции, то лучше ее определить, как constexpr static. Тогда такая локальная переменная гарантированно не будет занимать пространство на стеке при каждом вызове функции, ее инициализация точно пройдет в compile-time и об этом будет явно сказано в коде программы.

```cpp
double metersToMiles(double meters) {
	constexpr static double METERS_IN_MILE = 1609.34;
	return meters / METERS_IN_MILE;
}
```

Вообще этот пост в принципе родился из вопроса: "как помечать локальные константы, значения которых известны на этапе компиляции?". В большинстве случаев можно пометить константу просто constexpr, компилятор скорее всего ее оптимизирует и вставит ее значение в места вызовов. Однако, если вы по каким-то причинам будете использовать адрес этой локальной константы, то [компилятор будет вынужден класть ее на стек](https://godbolt.org/z/GG3EjWorn) на каждом вызове.

Но зачем делать ненужные действия? Если значение переменной не меняется от вызова к вызову, то она больше подходит на глобальную константу. А чтобы не засорять глобальный скоуп переменной, которая используется только в этой функции, то можно сделать ее статической локальной переменной и получить тот же результат.

Be expressive. Stay cool


std::to_address
#опытным 

В [этом посте ](https://t.me/grokaemcpp/530) мы поговорили о том, как доставать настоящий адрес объекта с помощью функции std:addressof. В основном она предназначена для универсальной обработки всех объектов, даже для тех, у кого перегружен оператор взятия адреса.

Однако есть и другая, похожая задача. Вам приходит на вход объект, который представляет из себя какого-то рода указатель на объект и из него нужно получить адрес самого объекта.

Дело это не совсем тривиальное. Со всеми стандартными классами, типа умных указателей и итераторов(которые называют общим выражением fancy pointer) может прокатить вот такое выражение: `obj.operator->()`. Однако для простых указателей это не прокатит. Да и не прокатит для любых других объектов, у которых не определен этот оператор. Что делать?

Использовать C++20 функцию std::to_address! Вот ее примерная реализация:

```cpp
template<class T>
constexpr T* to_address(T* p) noexcept {
	static_assert(!std::is_function_v<T>);
	return p;
}

template<class T>
constexpr auto to_address(const T& p) noexcept {
	if constexpr (requires{ std::pointer_traits<T>::to_address(p); })
		return std::pointer_traits<T>::to_address(p);
	else
		return std::to_address(p.operator->());
}
```

То есть для указателей она просто вовращает их значения наружу, а для объектов. Для fancy pointer'ов она спрашивает, определено ли свойство std::pointer_traits для этих типов. Если жу не определено, то пытается достать указатель с помощью вызова метода operator->().

Обычно эта функция требуется для вызова сишного апи в обобщенном коде:

```cpp
void c_api_func(const int*);

template<typename T>
void call_c_api_func(T && obj) {
	c_api_func(std::to_address(obj));
}

std::vector<int> data{10, 20, 30};
call_c_api_func(data.begin()); // works
auto ptr = std::make_unique<int>(42);
call_c_api_func(ptr); // works
call_c_api_func(ptr.get()); // also works
```

Use the right tool. Stay cool.

#cpp20 #cppcore


Volatile
#опытным 

Ключевое слово, которое не embedded-разработчик вряд ли когда-нибудь встречал в своей жизни. Сегодня мы поговорим, для чего оно используется.

Предположим, что у нас есть переменная keyboard_press, память под которую замаплена на память устройства ввода-вывода. Когда нажимается кнопка клавиатуры, изменяется переменная keyboard_press. Оставим сам маппинг за скобками и попробуем написать какую-то детсадовскую логику с переменной keyboard_press:

```cpp
int keyboard_press = 0;
size_t count_test = 0;

void some_function() {
	while(keyboard_press == 0) {
		count_test++;
	}
	// doing stuff
}
```

Что в ассемблере?

```asm
some_function():
	mov eax, DWORD PTR keyboard_press[rip]
	test eax, eax
	jne .L1
.L3: // это кстати пустой бесконечный цикл, куда нельзя попасть и откуда нельзя выбраться
	jmp .L3
.L1:
	ret
count_test:
	.zero 8
keyboard_press:
	.zero 4
```

А где цикл? А где инкремент count_test?

На самом деле код собран с -О3 и компилятор просто выкинул цикл. Он не видит, что в данном коде где-то еще изменяется keyboard_press, поэтому разумно полагает, что мы написали бесконечный цикл без сайдэффектов, который вообще-то ub.

Но keyboard_press может изменяться, просто это никак не понятно по коду программы. 

Теоретически компилятор может увидеть, что мы замапили устройство ввода-вывода на эту переменную. А может и не увидеть. Если маппинг происходит в другой единице трансляции, то не увидит. Компилятор технически не может знать всего, что творится в коде. Он оптимизирует какой-то локальный участок кода на основе своих эвристик, которые просто не могут учитывать весь код программы.

Однако компилятор точно видит тип переменной. И на него мы можем повлиять. Вот чтобы отучить компилятор от таких фокусов, нужно пометить keyboard_press ключевым словом volatile.

```cpp
volatile int keyboard_press = 0;
size_t count_test = 0;

// same
```

Теперь ассемблер выглядит так:

```asm
some_function():
	mov eax, DWORD PTR keyboard_press[rip]
	test eax, eax
	jne .L1
	mov rax, QWORD PTR count_test[rip]
	add rax, 1
.L3:
	mov edx, DWORD PTR keyboard_press[rip]
	mov rcx, rax
	add rax, 1
	test edx, edx
	je .L3
	mov QWORD PTR count_test[rip], rcx
.L1:
	ret
```


Все, что делает volatile - все операции над переменной становятся видимыми спецэффектами и не могут быть оптимизированы компилятором. Ну и еще операции над volitile переменными не могут переупорядочиваться с другими видимыми спецэффектами в порядке кода программы.

Говорится ли здесь что-нибудь о потоках? Нет! Здесь говорится только об оптимизациях компилятора.

Поэтому использовать volatile можно только для обработки сигналов(хэндлер которых вызывается в том же прерванном потоке), либо в тех местах, где вы работаете с переменной строго в одном потоке.

Доступ к volatile переменным не атомарный + с их помощью нельзя делать синхронизацию неатомарных переменных между потоками, так как они volitile не подразумевает барьеров памяти.

Именно из-за этих ограничений volatile используется в очень узком спектре задач и в большинстве С++ приложений полностью заменяется атомиками.

Don't be optimized out. Stay cool.

#cppcore #multitasking #memory 


Отличия volatile от std::atomic
#опытным 

Кратко пробежимся по особенностям volatile переменных и атомиков, чтобы было side-by-side сравнение.

volatile переменные:

- Компилятору запрещается выкидывать операции над volatile переменными. Грубо говоря, компилятору запрещается "запоминать" значение таких переменных и он обязан их каждый раз читать из памяти.

- Это происходит, потому что операции над volatile переменными становятся видимыми сайд-эффектами. Такие операции в программе влияют на другие потоки и внешние системы. Компилятор в принципе может крутить ваш код на всех продолговатых инструментах, которых он хочет. Главное, чтобы видимое внешнему миру исполнение осталось прежним. Поэтому просто выкинуть из кода использование volatile переменной он не может.

- Физически это значит, что volatile переменные запрещается кэшировать в регистрах и всегда честно читать из памяти.

- Запрещается реордеринг операций volatile переменных с другими операциями с видимыми спец-эффектами, расположенных выше и ниже по коду.

- Любой другой реордеринг разрешен.

- Операции над такими переменными не являются гарантированно атомарными в том плане, что есть возможность увидеть их промежуточное состояние. В целом, ничто не мешает пометить volatile объект std::unordered_map и конечно же операции над мапой не будут атомарными. Они могут быть атомарными на определенных архитектурах для тривиальных типов с правильным выравниванием памяти, но это никто не гарантирует.

- Запись и чтение volatile переменных не связаны между собой отношением synchronized-with, поэтому на их основе нельзя выстроить межпотоковое отношение happens-before. А это значит, что по стандарту С++ доступ к volatile переменной из разных потоков - это гонка данных и ub.

- volatile по стандарту подразумевает, что переменная может быть измененена


std::atomic:

- Операции над атомиками - это также видимые спецэффекты, только ситуация немного другая. Запись в атомике и других переменных, синхронизируемые атомиком, становятся видимыми сайд эффектами только для потоков, которые прочитают последнюю запись в атомик.

- По сути, если компилятор докажет, что поток будет всегда читать одно и то же значение атомика, то он может его закэшировать. Если ваш код только читает из memory mapped io, то компилятор теоритически может выкинуть чтение и заменить заранее вычисленным значением. Поэтому атомик нельзя использовать, как замену volatile. 

- Вы можете контролировать, какой барьер памяти хотите поставить атомарной операцией, и соответственно можете контролировать реордеринг. Самый сильный порядок предполагает, полный барьер памяти - никакие инструкции до атомика не могут быть переупорядочены ниже по коду и наоборот. Самый слабый порядок не предполагает никаких барьеров.

- Операции над атомарными переменными гарантировано являются атомарными в том смысле, что невозможно увидеть их промежуточное состояние. Это могут быть реально lock-free операции или в кишках операций могут использоваться мьютексы, но все это дает эффект атомарности.

- Запись и чтение атомиков связаны между собой отношением synchronized-with, поэтому на их основе можно построить межпотоковое отношение happens-before. Это значит, что по стандарту операции непосредственно над атомарными переменными не могут приводить к гонке данных.

- При использовании правильных порядков и барьеров памяти вы можете добиться того, что с помощью атомарных переменных вы сможете соединять операции над неатомиками отношением happens-before. Это значит, что атомики можно использовать для корректной синхронизации неатомарных переменных и предотвращения гонки данных над ними.

Про атомики можно говорить еще долго, но эти разговоры уже будут сильно оторваны от volitile. В этом посте хотелось бы сравнить их, чтобы можно быть проследить отличия по одним и тем же характеристикам.

Compare things. Stay cool.

#cppcore #cpp11 #multitasking


const vs constexpr переменные
#новичкам 

Хоть constexpr появился в С++11, многие так до конца и не понимают смысла этого ключевого слова. Давайте сегодня на базовом уровне посмотрим, чем отличаются const и constexpr, чтобы наглядно увидеть разницу.

Начнем с const. Наш старый добрый друг с первых дней C++ (а также C), может быть применен к объектам, чтобы указать на их неизменяемость. Попытка изменить const переменную напрямую приведет к ошибке компиляции, а через грязные хаки может привести к UB.

И все. Здесь ничего не говорится о том, когда инициализируется такая переменная. Компилятор может оптимизировать код и выполнить инициализацию на этапе компиляции. А может и не выполнить. Но в целом объекты const инициализируются во время выполнения:

```cpp
// might be optimized to compile-time if compiled decides...
const int importantNum = 42;

std::map<std::string, double> buildMap() { /*...*/ }
// will be inited at runtime 100%
const std::map<std::string, double> countryToPopulation = buildMap();
```

const иногда даже может использоваться в compile-time вычислениях, если она имеет интегральный тип и  инициализировано compile-time значением. В любых других случаях это не так.

Есть простой способ проверить, может ли переменная быть использована в compile-time вычислениях - попробовать инстанцировать с ней шаблон:

```cpp
const int count = 3;
std::array<double, count> doubles {1.1, 2.2, 3.3}; // int with literal initializer is OK
// при использовании const переменной в compile-time контексте она инициализируется в compile-time

// but not double:
const double dCount = 3.3;
std::array<double, static_cast<int>(dCount)> moreDoubles {1.1, 2.2, 3.3};
// error: the value of 'dCount' is not usable in a constant expression
// не то, чтобы double нельзя было использовать как constant expression, просто const double - не constant expression.
```

Отсюда мы приходим к понятию constant expression - выражение, которое может быть вычислено во время компиляции. Такие выражения могут использоваться как нетиповые шаблонные параметры, размеры массивов и в других контекстах, которые требуют compile-time значений. Если такое выражение используется в других вычислениях, которые требуют compile-time значений, то оно гарантировано вычислится в compile-time.

Видно, что просто пометив переменную const нам никто не гарантирует, что ее можно будет использовать в качестве constant expression, кроме пары случаев.

Хотелось бы четко говорить компилятору, что мы собираемся использовать данную переменную в compile-time вычислениях.

И ровно для этой цели можно помечать переменную constexpr. Вы так приказываете компилятору попытаться вычислить переменную в compile-time. Главное, чтобы инициализатор также был constant expression:

```cpp
// fine now:
constexpr double dCount = 3.3; // literal is a constant expression
std::array<double, static_cast<int>(dCount)> doubles2 {1.1, 2.2, 3.3};
```

Просто const double шаблон не переварил, а constexpr double - спокойно.

constant expression - не обязан быть какого-то рода одной чиселкой. С каждым стандартом constexpr все больше распространяется на стандартные классы и их операции и мы можем даже создать constexpr std::array, вызвать у него метод и все это в compile-time:

```cpp
constexpr std::array<int, 3> modify() {
	std::array<int, 3> arr = {1, 2, 3};
	arr[0] = 42; // OK в C++20 (изменение в constexpr)
	return arr;
}
constexpr auto arr1 = modify(); // arr == {42, 2, 3}
static_assert(arr1.size() == 3);
static_assert(arr1[0] == 42);
```

Есть принципиальные ограничения на constexpr объекты. Например, довольно сложно и непонятно, как работать в compile-time с динамическими аллокациями. Поэтому нельзя например создать constexpr объект std::unordered_map. В некоторых случаях с большими оговорками динамические аллокации возможны, но это для другого поста.

Но в целом, в сочетании с constexpr функциями вы можете делать намного больше, чем просто создавать массивы из даблов.

Итого:
- const может применяться к любым объектам, чтобы сказать компилятору и читателю кода, что они неизменяемы.
- const интегральные переменные с инициализатором в виде константного выражения могут сами использоваться, как константные выражения. Все остальные const переменные таким свойством не обладают и инициализируются в runtime.
- пометка constexpr говорит компилятору, что мы хотим иметь возможность использовать переменную как constant expression и использовать ее в compile-time вычислениях.
- для этого типу данных нужно соответствовать определенным критериям, а инициализатору - быть самому константным выражением.
- в сочетании с constexpr функциями вы можете перенести большое число вычислений в compile-time и я сейчас не про метапрограммирование.
- если хотите объявить константу, значение которой известно на этапе компиляции - пометьте ее constexpr, компилятору так будет приятнее.

Don't be confused. Stay cool.
#cpp11

constexpr функции сквозь года
#новичкам

constexpr бывают не только переменные, но и функции. Такие функции могут быть выполнены, как в compile-time, так и в runtime, в зависимости от контекста вызова:
- Если значения параметров возможно посчитать на этапе компиляции, то возвращаемое значение также должно посчитаться на этапе компиляции.
- Если значение хотя бы одного параметра будет неизвестно на этапе компиляции, то функция будет запущена в runtime. 
- Но если вы попытаетесь присвоить возвращаемое значение функции с runtime аргументом constexpr переменной, то получите ошибку компиляции.

```cpp
constexpr int square(int x) {
    return x * x;
}

int main() {
    constexpr int val = square(5);  // compile-time calculations
    static_assert(val == 25, "Must be 25");  // compile-time check
    int arg = rand() % 25;
    int res = square(arg); // runtime calculations
    assert(res == arg*arg); // runtime check
    constexpr int fail = square(arg); // compile error here!
}
```

В С++11 можно было использовать только однострочные constexpr функции с сильными ограничениями. 

```cpp
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1); // ternary operator is allowed, so recursion
}
```

В С++14 уже можно писать многострочные функции, использовать в них локальные переменные и базовые конструкции языка.

```cpp
constexpr int factorial(int n) {
    int result = 1;
    for (int i = 1; i <= n; ++i) {
        result *= i;
    }
    return result;
}

static_assert(factorial(5) == 120, "Must be 120");
```

C++20 и выше - constexpr почти везде. Уже есть и [виртуальные constexpr функции](https://t.me/grokaemcpp/684), и большинство простых контейнеров могут быть созданы и препарированы в compile-time, и все больше алгоритмов и стандартных функции получают пометки constexpr.

```cpp
constexpr std::string create_greeting() {
    std::string s = "Hello, ";
    s += "C++20!";
    return s;
}

static_assert(create_greeting() == "Hello, C++20!");
```

constexpr функции помогают иметь единый интерфейс для runtime и compile-time вычислений. Поэтому использование таких функций может приводить к неожиданному переносу некоторых вычислений в compile-time.

В сферах, где важны ультра-мега-милипизерные задержки очень важно как можно больше действий перевести в compile-time, сильно разгрузить "разогрев" программы , чтобы оставить время выполнения только для самых важных вещей(лутание бабок).

Free up time for important things. Stay cool.

#cpp11 #cpp14 #cpp20 



constexpr vs consteval функции
#опытным 

В С++20 добавили новый спецификатор - consteval. Отдельно его интро не особо интересно разбирать, поэтому попробуем в сравнении с constexpr.

consteval может быть применен только к функцим и это ключевое слово заставляет функцию выполняться во время компиляции и возвращать константное выражение. Отсюда и название спецификатора "константное вычисление"(constant evaluation).

Вот пара простых примеров:

```cpp
consteval int sum_consteval(int a, int b) {
	return a + b;
}

constexpr int sum_constexpr(int a, int b) {
	return a + b;
}

int main() {
	constexpr auto c = sum_consteval(100, 100);
	static_assert(c == 200);
	
	constexpr auto c1 = sum_constexpr(100, 100);
	static_assert(c1 == 200);
	
	constexpr auto val = 10;
	static_assert(sum_consteval(val, val) == 2*val);
	
	int a = 10;
	int res = sum_constexpr(a, 10); // fine with constexpr function
	int res1 = sum_consteval(10, 10);
	
	// int res2 = sum_consteval(a, 10); // error! the value of 'a' is not usable in a constant expression
}
```

Мы можем использовать оба спецификатора constexpr и consteval для того, чтобы инициализировать compile-time константы и обычные переменные.

Однако consteval функции могут вызываться только с constant expression в качестве аргументов. При попытке передачи в них неконстантного выражения будет ошибка компиляции.

Итого:

- спецификатор consteval может быть применен только для фукнций
- constexpr может быть применен и для переменных
- consteval заставляет компилятор вычислять выражение на этапе компиляции. Если хотя бы один аргумент такой функции не является константным выражением, то будет ошибка компиляции.
- constexpr функции могут быть вычислены на этапе компиляции, если аргументы являются константными выражениями. Но также они могут быть вычислены в рантайме с аргументами в виде рантайм значений.

Don't be confused. Stay cool.

#cpp20 


constexpr vs constinit
#опытным 

constinit - еще один спецификатор, который появился в С++20. Им помечаются глобальные или thread-local переменные для того, чтобы удостоверится в их статической инициализации. Это либо [нулевая инициализация](https://t.me/grokaemcpp/260), либо [константная инициализация](https://t.me/grokaemcpp/266). Собственно, это и отображено в самом названии спецификатора.

Тут суть в [Static Initialization Order Fiasco](https://t.me/grokaemcpp/277). Инициализация глобальных переменных в рантайме зависит от фазы луны и половой активности жаб в Центральной Америке. Мы нем можем гарантировать порядок инициализации глобальных переменных в рантайме и если одна переменная зависит от значения другой, то может произойти  много неприятных неожиданностей.

Вот constinit служит гарантией того, что переменная проинициализирована до старта программы, а программистам показывает, что с этой глобальной переменной точно все в порядке.

Интересность ситуёвины состоит в том, что constinit не подразумевает константность объекта! Действительно, мы же можем проинициализировать константным выражение ь неконстантную переменную и это будет валидный код:

```cpp
static int i = 42;
```

constinit - это только про гарантии инициализации в компайл тайме и все! Например:

```cpp
// init at compile time
constexpr int compute(int v) { return v*v*v; }
constinit int global = compute(10); // compute is invoked at compile-time

// won't work:
// constinit int another = global; // global is a runtime value

int main() {
    // but allow to change later...
    global = 100;

    // global is not constant expression!
    // std::array<int, global> arr;
}
```

Мы можем инициализировать global с помощью константных выражений, в том числе и результатами вычислений constexpr функций. Однако сама global не является ни constexpr, ни даже обычной константой. С ее помощью нельзя инициализировать другие constinit переменные, как нельзя использовать ее в качестве шаблонных параметров. Но global можно изменять, как как она не предполагает иммутабельность. 

Вы также не можете определить constexpr constinit переменную, потому что будет масло масляное. constexpr и так обеспечивает статическую инициализацию глобальных переменных.

Итого:

- constinit переменные в своей базе мутабельные, constexpr - немутабельные.
- constinit применяется только к static и thread storage duration объектам. Проще говоря, к разного рода глобальным переменным. constexpr может применяться к локальным переменным.
- Оба спецификатора обеспечивают инициализацию глобальных переменных в compile-time и защищают от SIOF.
- Эти спецификаторы нельзя использовать в одном выражении.

Don't be confused. Stay cool.

#cpp20


Висячие ссылки в лямбдах
#новичкам 

Все знают, что возврат ссылки на локальный объект функции приводит к неопределенному поведению. Однако не всегда так просто можно распознать такие ситуации.

В C++11 появились лямбда-выражения, а вместе с ними ещё один способ прострелить себе причинное место.

Лямбда, захватывающая что-либо по ссылке, безопасна до тех пор, пока она не возвращается куда-либо за пределы области, в которой её создали. Как только лямбда покинула скоуп - можно начинать молиться:

```cpp
auto make_add_n(int n) {
    return [&](int x) {
        return x + n;      // n will become dangling reference!
    };
}

auto add5 = make_add_n(5);
std::cout << add5(5) << std::endl;      // UB!
```

Гцц и шланг пишут разный результат на консоль, что напрямую говорит об ub. Можете посмотреть [тут](https://godbolt.org/z/4MYPWfbzo). На варнинги об этой ситуации лучше не надеяться, потому что гцц например думает, что в коде все в порядке.

Еще более интересная ситуация с объектами и методами.

```cpp
struct Task {
  int id;

  std::function<void()> GetNotifier() {
    return [=]{
      std::cout << "notify " << id << std::endl;
    };
  }
};

int main() {
  auto notify = Task { 5 }.GetNotifier();
  notify();
}
```

Что же здесь может провиснуть? Никаких локальных объектов в методе GetNotifier нет.

На самом деле провиснет сам объект, на котором вызывается GetNotifier. Мы его аккуратненько и довольно неявненько захватили через копию указателя this. До С++ 20 мы могли захватывать this вот так по значению и такую проблему будет очень сложно дебагать. Ситуация чуть улучшилась в С++20, мы теперь обязаны указывать `this` в списке захвата:

```cpp
struct Task {
  int id;

  std::function<void()> GetNotifier() {
    return [this]{
      std::cout << "notify " << id << std::endl;
    };
  }
};
```

Так уже чуть проще отловить проблему.

Как это лечить? Если лямбда с захватом по ссылке, то можно поменять на захват по значению. Но если у вас объект класса провисает, то тут поможет только профилактика и рефакторинг.

В случае с захватом this можно синтаксически ограничить использование методов, возвращающий лямбду, с помощью [ref-квалификаторов методов](https://t.me/grokaemcpp/627):

```cpp
struct Task {
  int id;
  std::function<void()> GetNotifier() && = delete; // forbit call on temporaries

  std::function<void()> GetNotifier() & {
    return [this]{
      std::cout << "notify " << id << std::endl;
    };
  }
};
```

Теперь вы не сможете вызвать этот метод на временном объекте, потому что удалена соответствующая перегрузка.

Конечно это вряд ли поможет в многопоточке, но это уже что-то.

Refer to actual things. Stay cool.

#cppcore #cpp11 #cpp20


История capture this
#опытным 

Проследим историю захвата this в лямбду сквозь стандарты С++, там есть на что посмотреть.

С++11

Появились лямбды и в них можно захватывать this как явно, так и неявно через параметры захвата по-умолчанию. Во всех случаях захватывается `&(*this)` то есть указатель на текущий объект:

```cpp
struct Foo {
	int m_x = 0;

	void func() {
		int x = 0;
		
		//Explicit capture 'this'
		[&]() { /*access m_x and x*/ }();
		
		//Implcit capture 'this'
		[&]() { /*access m_x and x*/ }();
		
		//Redundant 'this'
		[&, this]() { /*access m_x and x*/ }();
		
		//Implcit capture 'this'
		[=]() { /*access m_x and x*/ }();
		
		//Error
		[=, this]() { }();
	}
};
```

Однако не было адекватного способа захватить объект по значению aka скопировать его в лямбду.

С++14

Появилась инициализация в захвате, поэтому стал реальным захват по значению:

```cpp
struct Foo {
	int m_x = 0;

	void func() {
		[copy=*this]() mutable {
		    copy.m_x++;
		}();
	}
};
```

В остальном все осталось также

С++17

Появился захват объекта по значению! В пропоузале написано, что захват по значению может быть очень важно для асинхронных операций, которые откладывают выполнение лямбд:

```cpp
struct Processor {
 //Some state data..

	std::future<void> process(/*args*/) {
		//Pre-process...
		//Do the data processing asynchronously
		return
		std::async(std::launch::async,
			  [=](/*data*/){
		/*
		  Runs in a different thread.
		 'this' might be invalidated here
		*/
		
		//process data
		});
	}
};

auto caller() {
 Processor p;
 return p.process(/*args*/);
} 
```

В этом коде UB, потому что возвращаем лямбду со ссылкой на несуществующий объект. Поменять это можно захватом объекта по значению:

```cpp
struct Processor {
	std::future<void> process(/*args*/) {
		return
		std::async(std::launch::async,
			  [*this](/*data*/){
		/*
		  Runs in a different thread.
		 'this' might be invalidated here
		*/
		
		//process data
		});
	}
};
```
В этом случае в лямбде будет храниться копия объекта и все методы будут обращаться к существующему объекту.

С++20

С появлением захвата this по значению стала очень путающей семантика неявного захвата. Что reference capture &, что value capture =, по факту захватывали текущий объект по ссылке. И ничто неявно не захватывало this по значению.

Изначально в 20-м стандарте эту проблему хотели решить, просто запретив неявный захват this в любом случае. Но посидели и поняли, что для ссылочного захвата по умолчанию семантика неявного захвата ссылки на объект(чем отдаленно явняется this) корректна. А вот для захвата по значению - нет.

Поэтому начиная с С++20 мы не можем неявно захватывать this в default capture by value:

```cpp
struct Bagel {
	int x = 0;
	void func() {
		//OK until C++20. Warning in C++20.
		[=]() { std::cout << x; }();
		
		//Error/warning until C++20. OK in C++20.
		[=, this]() { std::cout << x; }();
	}
};
```

Оставлю в картинке под постом инфографику по изменениям в стандартах относительно захвата this.

Know the history. Stay cool.

#cpp11 #cpp14 #cpp17 #cpp20

![[Pasted image 20250617130415.png]]




Правильно захватываем по ссылке объект в лямбду
#опытным 

В недавнем посте мы рассказали о проблеме, когда лямбда, захватывающая объект по ссылке, возвращается из метода. Это потенциально может привести к тому, что объект уничтожится раньше, чем произойдет вызов лямбды, что в итоге приведет к провисшей ссылке, а значит - к UB.

```cpp
struct Task {
    int id;

    std::function<void()> GetNotifier() {
        return [=]{
            std::cout << "notify " << id << std::endl;
        };
    }
};

int main() {
    auto notify = Task { 5 }.GetNotifier();
    notify();
}
```

Можно вместо захвата по ссылке использовать захват по значению. Но скорее всего это не поможет, так как хочется использовать тот же самый объект, из метода которого возвращалась лямбда.

Тут бы шаред поинтер использовать. Но втупую заюзать его тоже ничем не поможет:

```cpp
struct Task {
    int id;

    std::function<void()> GetNotifier() {
        return [curr = std::shared_ptr<Task>(this)]{
            std::cout << "notify " << curr->id << std::endl;
        };
    }
};

int main() {
    auto notify = Task { 5 }.GetNotifier();
    notify();
}
```

Да, мы создали из this шареный указатель, но его контрольный блок никак не учитывает оригинальный объект! `curr` будет думать, что только он и его копии будут владеть объектом, а оригинальный объект просто уничтожится и `curr` будет ссылаться на невалидный объект. Получили то же самое UB.

Что делать?

Использовать миксин C++11 std::enable_shared_from_this. Это базовый CRTP класс, который предоставляет метод shared_from_this. Если вы обернете исходный объект в std::shared_ptr, то метод shared_from_this возвращает копию объекта умного указателя, в котором находился исходный объект. Эта копия будет разделять контрольный блок с оригинальным объектом, поэтому пока жива хоть одна копия, исходный объект не разрушится. Выглядит это так:

```cpp
struct Task : std::enable_shared_from_this<Task> {
    int id;

    std::function<void()> GetNotifier() {
        // Захватываем shared_ptr на текущий объект
        return [self = shared_from_this()] {
            std::cout << "notify " << self->id << std::endl;
        };
    }
};

int main() {
    auto notify = std::make_shared<Task>(5)->GetNotifier();
    notify();  // Теперь безопасно - объект не будет уничтожен
}
```  

В первой строчке main происходит много вещей:
- Создается объект класса Task и оборачивается во временный объект умного указателя. 
- Вызывается метод GetNotifier у объекта внутри временного умного указателя, из которого возвращается лямбда с захваченной копией временного объекта.
- До перехода к следующей строчке временный объект, созданный через make_shared, разрушается.

Но ничего страшного не происходит, потому что notify хранит в себе копию временного объекта умного указателя, а значит тебе эта лямбда владелец исходного объекта Task{5}. Поэтому при вызове этой лямбды никакого Ub и провисания ссылки нет.

Вообще, наверное пора рассказывать про CRTP, миксины и прочие нечисти шаблонов в С++. Если хотите такого, то жмякните лайкосик, а с нам посты по этим темам.

Watch your lifetime. Stay cool.

#template #cpp11






