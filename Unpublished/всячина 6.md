
std::from_char
#новичкам 

С++17 нам принес новую прекрасную функцию парсинга строк в числа - std::from_char.

```cpp
std::from_chars_result from_chars(
    const char* first,   // Начало строки (включительно)
    const char* last,    // Конец строки (не включительно)
    IntegerType& value,  // Куда записать результат
    int base = 10        // Система счисления (2-36)
);

std::from_chars_result from_chars(
    const char* first,   // Начало строки (включительно)
    const char* last,    // Конец строки (не включительно)
    FloatType& value,  // Куда записать результат
    std::chars_format fmt = std::chars_format::general // Формат плавающей точки
);
```

На самом деле это два семейства перегрузок функций для целых чисел и чисел с плавающей точкой.

Задача функции - максимально быстро, безо всяких накладных расходов на выделение памяти и поддержку исключений, распарсить строку в число арифметического типа.

Функция возвращает структуру `std::from_chars_result`:

```cpp
struct from_chars_result {
    const char* ptr;  // Указатель на первый НЕпрочитанный символ
    std::errc ec;     // Код ошибки (если успех — `std::errc()`)
};
```

Если парсинг удался и какая-то часть строки конвертировалась в число, то в ptr находится указатель на первый символ, на котором парсинг завершился. Если вся строка была интерпретирована, как число, то в ptr находится last указатель.

Если парсинг неудался, то ptr равен first, а код ошибки ec выставляется в  std::errc::invalid_argument.

```
"123" → удачно распарсили все → ptr == last (конец строки).
"123abc" → распарсили "123" → `ptr` указывает на 'a'.
"abc" → ошибка → ptr == first (начало строки).
```

Примеры работы:

```cpp
const std::string str = "42abc";
int value;
auto res = std::from_chars(str.data(), str.data() + str.size(), value);
if (res.ec == std::errc()) {
	std::cout << "Value: " << value << "\n"; // 42
	std::cout << "Remaining: " << res.ptr << "\n"; // "abc"
}

// ----------------

const std::string str = "xyz";
int value;
auto res = std::from_chars(str.data(), str.data() + str.size(), value);

assert(res.ec == std::errc::invalid_argument);
assert(res.ptr == str.data());  // ptr остался на начале
```

К тому же функция может детектировать переполнение:

```cpp
const std::string str = "99999999999999999999";
int value;
auto res = std::from_chars(str.data(), str.data() + str.size(), value);
assert(res.ec == std::errc::result_out_of_range);
```

В чем главный прикол этой функции?

Если у вас есть строка с последовательностью чисел, разделенных запятой, то вы просто в цикле можете передвигать нужные указатели и парсить числа одно за другим. Тот же std::stoi выкинул бы исключение и пошел пиво пить:

```cpp
const std::string str = "123,456,789";
std::vector<int> numbers;
const char* current = str.data();
const char* end = str.data() + str.size();

while (current < end) {
	int value;
	auto res = std::from_chars(current, end, value);
	if (res.ec != std::errc()) {
		std::cerr << "Parsing error!\n";
		break;
	}
	
	numbers.emplace_back(value);
	current = res.ptr; // Сдвигаем указатель
	// Пропускаем разделитель (запятую)
	if (current < end && *current == ',') {
		++current;
	}
}

for (int num : numbers) {
	std::cout << num << " ";
}
// Вывод: 123 456 789
```

К тому же ее целочисленный вариант с С++23 constexpr, что позволить вам парсить строку в числа даже во время компиляции.

Если вы не любите исключения - std::from_char ваш выбор.

Be efficient. Stay cool.

#cpp17 #cpp23


std::to_chars
#новичкам 

В C++17 появилась не только функция для парсинга (std::from_chars), но и её обратная версия — std::to_chars, которая позволяет конвертировать числа (int, float, double и др.) в строки без дополнительных затрат на выделение памяти и поддержку исключений.

```cpp
std::to_chars_result to_chars(char* first, char* last,
                             IntegerType value,
                             int base = 10);  // (1)

std::to_chars_result to_chars(char* first, char* last,
                             FloatType value,
                             std::chars_format fmt);  // (2)

std::to_chars_result to_chars(char* first, char* last,
                             FloatType value,
                             std::chars_format fmt,
                             int precision);  // (3) (since C++23)
struct to_chars_result {
    const char* ptr;
    std::errc ec;
};
```

Единственный случай, когда эта функция может зафейлиться - если вы передали слишком маленький буффер. Тогда ec выставляется в std::errc::value_too_large, а ptr в last.

В чем преимущество функции по сравнению со старой-доброй std::to_string?

1 Можно задать точность и основание системы счисления.

2 Отсутствуют динамические аллокации внутри функции.

Вот вам пример работы:
```cpp
char buffer[20];
int value = 12345;

auto result = std::to_chars(buffer, buffer + sizeof(buffer), value);
if (result.ec == std::errc()) {
	size_t result_length = result.ptr - buffer;
	std::string_view str_result(buffer, result_length);
	std::cout << "Result: " << str_result << "\n"; // "12345"
}

// ------------------------

double pi = 3.1415926535;
char buf[20];

auto result = std::to_chars(buf, buf + sizeof(buf), pi, std::chars_format::fixed, 4);
if (result.ec == std::errc()) {
	size_t result_length = result.ptr - buf;
	std::string_view str_result(buf, result_length);
	std::cout << "Result: " << str_result << "\n"; // "3.1416"
}
```

Не всегда проблема точности и аллокаций - это реальная проблема. Но если вы работаете с ограниченной кучей и хотите стандартное средство конвертации числа в строку - std::to_char как раз для вас.

Be efficient. Stay cool.

#cpp17



Разница между std::stoi+std::to_string и std::from_chars+std::to_chars
#опытным


В C++ есть два основных подхода к конвертации чисел в строки и обратно:

Старомодный  — std::stoi, std::to_string (C++11)

Модномолодежный — std::from_chars, std::to_chars (C++17)

В чем принципиальная разница между ними и когда какой подход использовать? Сегодня мы широкими мазками ответим на эти вопросы.

Особенности старомодного подхода:

- Основное - это исключения. Все нештатные ситуации обрабатываются с их помощью, что ведет к неким накладным расходам.
- Работа в высокоуровневом ООП стиле. Используются классы и возвращаются классы, без всяких сырых буферов.
- Нет контроля над парсингом. Нет возможности задать формат, основание системы счисления или точность.
- Поддержка локалей. Грубо говоря, это механизм для учёта региональных особенностей представления данных. То есть std::stoi, std::to_string реализованы с учетом возможности спецификации локалей и соотвественно изменения результатов конвертации. С локалями возможна такая штука:
```cpp
// В США (локаль "en_US"):
std::to_string(3.14);  // "3.14" (точка как разделитель)

// В Германии (локаль "de_DE"):
std::to_string(3.14);  // Может вернуть "3,14" (запятая)!
```
Естественно, что поддержка такой фичи обходится дорого.

Особенности модномолодежного подхода:

- Функции std::from_chars, std::to_chars сроектированы быть настолько легкими и быстрыми, насколько это возможно на таком уровне абстракции.
- Отсутствие намеренных динамических аллокаций. Только вы решаете, где расположена память по данные.
- Отсутствие исключений. Функции возвращает объект ошибки, который явно нужно проверять руками.
- Не проверяет локали.
- Поддерживают частичный парсинг.
- Поддержка явной гарантии round-trip. Если вы запишите в строку число с помощью std::to_chars и прочитаете его с помощью std::from_chars, то вы всегда получите изначальный результат. Главное, чтобы обе функции были вызваны с использованием одинаковой реализации стандартной библиотеки. Но у std::stoi, std::to_string и этого нет.


Если вы работаете в высоконагруженном или ограниченном по производительности окружении, то ваш выбор явно std::from_chars, std::to_chars. Обычно в коде таких приложений отказываются от использования исключений, поэтому проблем с код-стайлом не будет. 

Возможность поэтапного парсинга также не оставляет выбора - используйте std::from_chars.

Если вы не паритесь за производительность, любите объекты, вам не нужен частичный парсинг или каждый раз при виде слова exception у вас начинает идти пена изо рта, то придерживайтесь старого подхода, ничего плохого в этом нет.

Choose the right tool. Stay cool.

#cppcore #cpp11 #cpp17



Modern pimpl идиома
#новичкам 

[В одном из давнишних постов ](https://t.me/grokaemcpp/107) мы уже обсуждали базовую формулировку и реализацию идиомы pimpl. Это сырой указатель на forward-объявленную структуру.

В современных плюсах, естественно, никто уже так не делает. Сырые указатели уходят в прошлое и старые подходы пересматриваются с применением умных указателей.

Допустим, вы используете какой-то нестандартный формат сериализации данных, например apache avro. Конечно вы хотите написать свою библиотеку сериализации, которая позволить конвертировать данные в/из avro формата. Как должна выглядеть эта библиотека?

Ну скорее всего вы хотите использовать только доменные сущности в интерфейсе библиотеки. В этом случае только она зависит от стороннего решения и вы в любой момент смогли, например, изменить формат сериализации. Также приятно иметь стабильный интерфейс и линковать стороннее решение только с этой библиотекой.

С такими симптомами ваш терапевт прописал вам однократный прием pimpl идиомы. Выглядеть это может так:

```cpp
// serializer.hpp
class Serializer {
public:
    Serializer();
    ~Serializer();
    
    // only move-semantic
    Serializer(const Serializer&) = delete;
    Serializer& operator=(const Serializer&) = delete;
    Serializer(Serializer&&) noexcept;
    Serializer& operator=(Serializer&&) noexcept;

    std::vector<uint8_t> serializeOrder(const domain::Order& person);
    domain::Order deserializeOrder(const std::vector<uint8_t>& data);
private:
    std::unique_ptr<struct Impl> pimpl_; // Smart pointer on forward-declared struct
};

// serializer.cpp

struct Serializer::Impl {
    avro::GenericRecord convertToAvro(const domain::Order&);
    domain::Order convertFromAvro(const avro::GenericRecord&);
};

Serializer::Serializer() 
    : pimpl_(std::make_unique<Impl>()) {
}

Serializer::~Serializer() = default;
Serializer::Serializer(Serializer&&) noexcept = default;
Serializer& Serializer::operator=(Serializer&&) noexcept = default;

std::vector<uint8_t> Serializer::serializeOrder(const domain::Person& person) {
    auto record = pimpl_->convertToAvro(person);
    return {...};
}
// deserializeOrder
```

Основная идея - все упоминания и детали реализации avro находятся в cpp и не торчат наружу. Мы имеем стабильный интерфейс, стабильный ABI и сокращенное время линковки. А за счет использования std::unique_ptr у нас тривиальные реализации всех специальных методов.

Примерно так это и выглядит в современных плюсах. Но это еще не конец для pimpl. Есть решение, которое поможем вам избежать динамических аллокаций. Но об этом в другой раз.

Hide details. Stay cool.

#design 


**Зачем в pimpl определять специальные методы в cpp?**
#опытным 

В прошлом посте вы могли заметить, что все специальные методы класса Serializer только объявляются в хэдере, а реализуются в файле исходников. Зачем так делать?

```cpp
class Serializer {
public:
    Serializer();
    ~Serializer();
    
    // only move-semantic
    Serializer(const Serializer&) = delete;
    Serializer& operator=(const Serializer&) = delete;
    Serializer(Serializer&&) noexcept;
    Serializer& operator=(Serializer&&) noexcept;

    //...
private:
    std::unique_ptr<struct Impl> pimpl_;
};
```

Мы ведь привыкли либо вообще не определять никакие специальные методы по правилу нуля, либо просто помечать их default и все. Почему в этот раз так нельзя сделать?

Все дело в нашем особенном указателе pimpl_. Это умный указатель на forward-объявленную структуру. Это значит, что мы не знаем примерно ничего об этой структуре, кроме ее имени. И в этом загвоздка. Компилятор на данный момент не знает, как выглядят ее деструктор и перемещающие методы.

Когда мы явно помечаем специальные методы класса как default, мы явно просим компилятор за нас сгенерировать определение этих методов. 

```cpp
class Serializer {
public:
    Serializer();
    ~Serializer() = default; // Here
    
    // only move-semantic
    Serializer(const Serializer&) = delete;
    Serializer& operator=(const Serializer&) = delete;
    Serializer(Serializer&&) noexcept = default; // Here
    Serializer& operator=(Serializer&&) noexcept = default; // Here

    //...
private:
    std::unique_ptr<struct Impl> pimpl_;
};
```

**То есть мы запрашиваем определение метода в теле класса**. На основе чего компилятор будет генерировать их? На основе того, что есть в теле класса. 

Но вот беда, в теле класса нет никакой информации о том, что из себя представляет класс Impl. Возьмем тот же деструтор. По дефолту std::unique_ptr вызывает просто `delete ptr` . А у delete expression есть пометка, что при удалении указателя на неполный тип программа становится ill-formed. Поэтому компиляторы на случай, если вы захотите сгенерировать деструктор std::unique_ptr с неполным типом, ставят такой ассерт времени компиляции: `static_assert(sizeof(_Tp)>0, "can't delete pointer to incomplete type");`. А компиляция последнего примера крашнется с соотвествующей ошибкой.

Так что определяйте специальные методы в реализации и будет вам счастье.

Don't give impossible tasks. Stay cool.

#cppcore #design 



Квиз

Сегодня #quiz на любимую тему всех плюсовиков - утечку памяти. 

Исключения в конструкторе представляют особый интерес с точки зрения исследования цикла жизни объекта и на собесах нет-нет да и спросят что-нибудь про исключения в конструкторах. Поэтому в этой теме надо бы разбираться.

Спасибо [Сергею Борисову](@borisov_s_s) за идею для поста)

Ну а сейчас у меня для вас всего один вопрос. **Будет ли в этом коде утечка памяти или нет?**

```cpp
class Bar {
public:
    Bar() {
        throw std::runtime_error("Error");
    }
};

int main() {
    Bar *bar = nullptr;

    try {
        Bar *bar = new Bar();
    } catch(...) {
        std::cout << "Houston, we have a problem" << std::endl;
    }
}
```

Будет ли в этом коде утечка памяти в коде выше?


Ответ
#новичкам 

В этом коде:

```cpp
class Bar {
public:
    Bar() {
        throw std::runtime_error("Error");
    }
};

int main() {
    Bar *bar = nullptr;

    try {
        Bar *bar = new Bar();
    } catch(...) {
        std::cout << "Houston, we have a problem" << std::endl;
    }
}
```

Не будет утечки памяти.  Стандарт нам это гарантирует при использовании new expression.

Дело вот в чем. В [этом посте](https://t.me/grokaemcpp/608) мы поговорили о том, что есть 3 вида new: 
- operator new, который выделяет память
- placement new, который вызывает конструктор на заданной памяти.
- new expression, который в начале выделяет память через operator new, а потом конструирует объект на этой памяти через placement new.

Так вот new expression заботится о своих пользователях и оборачивает в try-catch вызов конструктора объекта. В catch оно освобождает память и пробрасывает исключение наружу:

```cpp
Bar *bar = new Bar();
// инструкция выше эквивалентнас следующему коду:
Bar* bar;
void* tmp = operator new(sizeof(Bar));
try {
	new(tmp) Bar(); // Placement new
	p = (Bar*)tmp; // The pointer is assigned only if the ctor succeeds
}
catch (...) {
	operator delete(tmp); // Deallocate the memory
	throw; // Re-throw the exception
}
```

И получается, что и исключение есть, и память освобождена. 

Вообще, это даже интересная техника. Ловить исключение, заметать следы преступления и пробросить исключение дальше. Может помочь избежать утечек памяти в конструкторах ваших классов, которые сами внутри выделяют память.

Спасибо, @PyXiion за предоставленную информацию)

Don't let your memory leak. Stay cool.

#cppcore #memory 


Почему важно проверять входные данные
#новичкам 

Вы делаете какие-то вычисления и среди них есть целочисленное деление:

```cpp
void fun(int a, int b) {
	// some calculations
	auto res = a / b;
	// some calculations
}

```

Вы уже наслышаны о том, что в С++ есть механизм обработки исключений и просто оборачиваете вашу функцию в try-catch и думаете, что С++ позаботится о том, что вы будете информированы о всех проблемах, которые могут произойти в коде:

```cpp
try {
	fun(1, 2);
} catch(std::exception& ex) {
	std::cout << "Calculation error: " << ex.what() << std::endl;
}
```

Однако помните, что вы пишите на С++. Здесь уровень заботы примерно, как у бати, который вывозит неумеющего плавать сына на середину реки и бросает его в виду с криками "Плыви, сынок!".

Если вдруг вы передадите в fun вторым параметром ноль:

```cpp
try {
	fun(1, 0);
} catch(std::exception& ex) {
	std::cout << "Calculation error: " << ex.what() << std::endl;
}
```

то С++ не пошлет исключение об этой ситуации.

Стандарт явно говорит: целочисленное деление на ноль приводит к неопределенному поведению. У меня например программа просто падает с надписью: `Floating point exception`. Очень иронично со стороны компилятора обрабатывать эту ситуацию, выводя в консоль текст о появлении исключения, хотя его тут нет и его никак не отловить.

Поэтому нужно проверять входные данные и самим явно кидать исключения:

```cpp
void fun(int a, int b) {
	if (!b) {
		throw std::runtime_error("Devision by zero!");
	}
	// some calculations
	auto res = a / b;
	// some calculations
}

try {
	fun(1, 0);
} catch(std::exception& ex) {
	std::cout << "Calculation error: " << ex.what() << std::endl;
}
```

Тогда на консоль явно выведется ожидаемое `Calculation error: Devision by zero!`.

Так что будьте осторожны и проверяйте входные данные.

Stay alert. Stay cool.

#cppcore


Пробрасываем исключение
#новичкам 

Работа с исключениями - целое искусство. В этой теме куча фишек, которые помогут извлекать из исключений максимум пользы.

Пусть вы хотите работать с какой-то сущностью в коде эксклюзивно:

```cpp
void func(std::shared_ptr<Resource> res) {
	if (res->TryToAcquire()) {
		// do dirty things
	} else {
		// you don't have permission to do dirty, so return
		return;
	}
}
```

Что будет, если в результате обработки эксклюзивно захваченного ресурса произойдет исключение?

Правильно, утечка. Утечка ресурса. Вы его больше не сможете захватить и он так и останется в подвешанном состоянии.

Хорошо бы отловить исключение и освободить ресурс. Однако привычная обработка исключений тут особо не поможет. Мы на этом слое вызовов не можем адекватно обработать исключение, у нас просто недостаточно информации и полномочий, чтобы принять решение.

То есть нам как-то нужно сделать 2 вещи одновременно: дать исключению выйти наружу и освободить ресурс. 

В этом поможет простой вызов "throw".

```cpp
void func(std::shared_ptr<Resource> res) try {
	if (res->TryToAcquire()) {
		// do dirty things
	} else {
		// you don't have permission to do dirty, so return
		return;
	}
} catch(std::exception& ex) {
	res->Release();
	throw;
}
```

Инструкция throw делает единственную вещь - пробрасывает то же самое исключение выше по стеку вызовов.

Получается, что можно и рыбку съесть и ... освободить ресурс.

Полезная фишка. Не обязательно полностью обрабатывать исключения на текущем уровне, но можно позаботится о том, чтобы программа находилась в согласованном состоянии без потеряных по пути бойцов.

Don't leak your resources. Stay cool.

#cppcore 


Обогащаем исключение
#новичкам 

Еще один простой и известный лайфхак, как можно более эффективно работать с исключениями.

Вот пилишь проект на 100500 строк кода. Запускаешь и вылетает ошибка: "абракадабра, ты хреновый программист". И как понять, откуда это исключение прилетело? 

И начинается. Все обкладывается принтами и смотрится после какого принта программа падает. Но можно сделать немного умнее.

Пусть у вас в проекте активно используется библиотека для работы с базой данных. При возникновении непредвиденной ситуации библиотека генерирует исключение. Однако мест, где вы используете базу, много. И вам хотелось бы понимать примерный путь пролетания исключения, чтобы лучше понимать ситуацию для отладки.

В прошлом посте мы просто прокидывали исключение дальше, без добавления в него какой-то информации. Но можно бросить новое исключение и передать туда сообщение об ошибке первого:

```cpp
void ComplicatedCalculations() try {
	// use db
} catch (std::exception& ex) {
	throw std::runtime_error(std::string("ComplicatedCalculations Error:") + ex.what());
}

void HandlingCalculations() try {
	ComplicatedCalculations();
} catch (std::exception& ex) {
	throw std::runtime_error(std::string("HandlingCalculations Error:") + ex.what());
}
```

В итоге мы получаем фактически стек вызовов, который пролетает исключение. И уже намного проще найти место конкретной проблемы, особенно если есть информативные логи.

Однако в результате будет длинная строка из всех вызовов. Плюс не очень хочется повторять вот этот паттерн с "+ ex.what()". 

И у данной проблемы есть интересное решение, о котором мало кто из вас слышал. Об этом мы поговорим в следующий раз.

Track your problems to the bottom. Stay cool.

#cppcore

Засовываем исключение в исключение
#опытным 

Вы знали, что в плюсах есть вложенные исключения? Такие исключения могут хранить в себе несколько исключений. Сегодня мы посмотрим, что это за зверь такой.








https://t.me/c/2009887601/52081


Концепты делают ошибки более читаемыми

pimpl std::unique_ptr и деструктор

Пример внутреннего кэша. filter_view

std::ranges::less и std::less разница при сортировке

Flexible array member


SPAM

std::clamp
кладутся ли на стек constexpr локальные переменные

std::filesystem введение

приватные инклюды и их директория

нужны .done файлы

inotify
Какая разница между спецификатором, модификатором, квалификатором, идентификатором, инициализатором?

https://youtu.be/O56xKKy34Do?si=rvmTFjXTenCdpzDX\