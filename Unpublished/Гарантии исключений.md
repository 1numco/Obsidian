
Гарантии безопасности исключений

Программа на С++ - очень интересное явление. Вроде мощный, подкаченный, умный и скоростной парень. Но вот проблема. Ходить не умеет нормально. То в ноги себе стреляет, то падает периодически. В общем, беда у него с ходьбой. У этого могут быть разные причины. Все из них даже трудно в голове удержать. Но сегодня обсудим, какие есть гипсы, лангеты и костыли, которые помогут этому парню нормально ходить при работе с исключениями.

Даже не зная, что вы работаете с исключениями - вы уже работаете с ними. Даже обычный, казалось бы, безобидный new может кинуть std::bad_alloc. И все, приплыли.

Обрабатывать исключения можно по-разному и это будет давать разные результаты. От того, как обрабатываются исключения в модуле, зависит, какие гарантии он может дать в случае возникновения исключительной ситуации.

А это очень важная штука, потому что взаимодействующий с модулем код полагается на его адекватное поведение, которое с легкостью может быть нарушено, если нет гарантий безопасности.

Итак, существует 3 гарантии безопасности исключений:

Базовая гарантия. Формулировка разнится, но более общая звучит так: "после возникновения исключения программа должна остаться в согласованном состоянии". Теперь на рабоче-крестьянском: не должно быть утечек ресурсов и должны сохраняться все инварианты классов. С утечками, думаю, все понятно. Инвариант - некое логически согласованное состояние системы. Если класс владеет массивом и содержит поле для его размера, то инвариантом этого класса будет совпадение реального размера массива со значением поля-размера. Для класса "легковая машина" инвариантом будет количество колес - 4. Обычная машина без одного или нескольких колес просто не едет. И для того, чтобы машина корректно работала, количество колес должно быть одинаково - 4. Или например, нельзя, чтобы дата создания чего-то была больше текущего дня, ну никак. Вот такие штуки должны сохраняться.

Строгая гарантия. Если при выполнении операции возникает исключение, операция не должна оказать на систему никакого влияния. То есть пан или пропал. Либо вся операция выполняется успешно и ее результат применяется, либо система откатывается в состояние до выполнения операции. Это свойство программы называется транзакционностью. 

Гарантия отсутствия исключений. Ни при каких обстоятельствах не будет брошено исключение. Легко сказать, но тяжело сделать. С++ и его стандартная библиотека разрабатывались с учетом использования исключений. И это накладывает свои ограничения на отсутствие исключений. Мы все-таки не на Go пишем. 

Ну и есть еще одна гарантия - отсутствие каких-либо гарантий. Мама - анархия, во всей красе.

Тема важная, будем потихоньку ее разбирать с примерами по каждой гарантии.

Be a guarantor. Stay cool.

#cppcore


Базовая гарантия исключений
#новичкам 

Вспомним определение базовой гарантии: после возникновения исключения в программе не должно быть утечек ресурсов и должны сохраняться все инварианты классов.

И не всегда базовой гарантии легко удовлетврить. Поскольку исключения добавляют в программу дополнительные пути выполнения кода, крайне важно учитывать последствия работы кода по таким путям и избегать любых нежелательных эффектов, которые в противном случае могут возникнуть. Давайте посмотрим на примере:

```cpp
class IntArray {
    int *array;
    std::size_t nElems;

public:
    // ...

    ~IntArray() { delete[] array; }

    IntArray(const IntArray &that);  // nontrivial copy constructor
    IntArray &operator=(const IntArray &rhs) {
        if (this != &rhs) {
            delete[] array;
            array = nullptr;
            nElems = rhs.nElems;
            if (nElems) {
                array = new int[nElems];
                std::memcpy(array, rhs.array, nElems * sizeof(*array));
            }
        }
        return *this;
    }

    // ...
};
```

Внутренний инвариант класса IntArray -  член `array` является валидным (возможно, нулевым) указателем, а член `nElems` хранит количество элементов в массиве. В операторе присваивания освобождается память текущего `array`'я и присваивается значение счётчику элементов `nElems` до выделения нового блока памяти для копии. В результате, если из new вылетит исключение, то `array` будет нулевым, а размер массива нет. Это нарушение инварианта и таким объектом просто небезопасно пользоваться. Метод size потенциально вернет ненулевой размер, а закономерное использование следом оператора[] приведет к неопределенному поведению.

Код, который избегает подобных нежелательных эффектов, называется exception safe. То есть предоставление базовой гарантии уже говорит о том, что ваш код "exception safe".

Допустим, что ваш класс предоставляет базовую гарантию исключений. Какие выводы мы можем из этого сделать? Ну сохранены инварианты, а значения-то какие будут у полей?

В том-то и дело, что конкретные значения неизвестны. И это сильно ограничивает практическое использование таких объектов. По сути единственное, что с ним можно гарантировано безопасно сделать - это разрушить. 

И это главное. Вся магия с раскруткой стека и вызовом деструктором локальных объектов работает только если деструкторы вызывать безопасно. А для этого объект должен быть в валидном, но необязательно определенном, состоянии. То есть вы в принципе не можете восстановить работоспособность приложения, если ваши инструменты не предоставляют хотя бы базовую гарантию. 

Здесь кстати можно провести параллель с мувнутыми объектами: по хорошему их надо просто удалить.

Примером предоставления только базовой гарантии может быть использование какой-нибудь базы данных. Если при выполнении запроса фреймворк выкинул исключение, например потому что соединение отвалилось, то объект для работы с базой остался в валидном состоянии, но нет никакой информации о том, выполнился запрос или нет:

```cpp
auto db = std::make_shared<DBConnection>(credentials);
try {
	auto result = db->Execute("UPDATE ...");
	process(result);
} catch (std::exception& ex) {
	std::cout << "We can cannot rely on table state and must retry with that in mind" << std::endl;
	// retry
}
```

Provide guarantees. Stay cool.

#cppcore 


Строгая гарантия исключений
#новичкам 

Базовая гарантия - это конечно хорошо, наше приложение будет корректно работать, даже если что-то пойдет не так. Но иногда этого недостаточно. Иногда нам нужно, чтобы ошибка операции вообще никак не повлияла на текущее состояние системы. Либо пан, либо пропал. Либо операция выполнилась и все хорошо, либо она бросила исключение, но после его отлова система находится в том же состоянии, что и до выполнения операции.

Такое свойство операций называется транзакционность. Транзакция может либо выполниться полностью, либо все результаты промежуточных операций в ней откатываются до состояния до начала исполнения транзакции.

Это важно, когда ваша операция требует выполнения нескольких промежуточных операций, постепенно меняющих систему. Если остановиться посередине, то уже невозможно или очень сложно будет восстановить консистентность данных.

Давайте перепишем оператор присваивания класс IntArray из предыдущего поста так, чтобы он предоставлял строгую гарантию:

```cpp
class IntArray {
    int *array;
    std::size_t nElems;

public:
    // ...

    ~IntArray() { delete[] array; }

    IntArray(const IntArray &that);  // nontrivial copy constructor

    IntArray &operator=(const IntArray &rhs) {
        int *tmp = nullptr;
        if (rhs.nElems) {
            tmp = new int[rhs.nElems];
            std::memcpy(tmp, rhs.array, rhs.nElems * sizeof(*array));
        }
        delete[] array;
        array = tmp;
        nElems = rhs.nElems;
        return *this;
    }

    // ...
};
```

В этот раз мы ничего не изменяем в самом объекте до тех пор, пока не выделим новый буфер и не скопируем туда элементы `rhs`. И только после этого выполняем обновление самого объекта с помощью небросающих инструкций.

Хрестоматийный пример из стандартной библиотеки - вектор с его методом push_back. Если у типа есть небросающий перемещающий конструктор, то метод предоставляет строгую гарантию. Вот примерно как это работает:

```cpp
template <typename T>
class vector {
private:
    T *data = nullptr;
    size_t size = 0;
    size_t capacity = 0;

    void reallocate(size_t new_capacity) {
        // allocate memory
        T *new_data =
            static_cast<T *>(::operator new(new_capacity * sizeof(T)));
        size_t new_size = 0;

        try {
            // Move or copy elements 
            for (size_t i = 0; i < size; ++i) {
                new (new_data + new_size) T(std::move_if_noexcept(data[i]));
                ++new_size;
            }
        } catch (...) {
            // Откат в случае исключения
            for (size_t i = 0; i < new_size; ++i) {
                new_data[i].~T();
            }
            ::operator delete(new_data);
            throw;
        }

        // cleanup
        // ...
    }

public:
    void push_back(const T &value) {
        if (size >= capacity) {
            size_t new_capacity = capacity == 0 ? 1 : capacity * 2;

            // save for rollback
            T *old_data = data;
            size_t old_size = size;
            size_t old_capacity = capacity;

            try {
                reallocate(new_capacity);
            } catch (...) {
                // restore
                data = old_data;
                size = old_size;
                capacity = old_capacity;
                throw;
            }
        }

        // actually insert element
        // ...
    }

};
```

в хэлпере reallocate используется [std::move_if_noexcept](https://t.me/grokaemcpp/702), который условно кастит в rvalue ссылке, если мув конструктор noexcept. И только в этом случае можно предоставить строгую гарантию: если вы уже повредили один из исходных объектов, его уже никак не восстановить. А безопасное перемещение элементов гарантирует готовый к использованию новый расширенный буфер.

Be strong. Stay cool.

#cppcore 


Гарантия отсутствия исключений
#новичкам 

Переходим к самой сильной гарантии - отсутствие исключений. 

В сам язык С++(new, dynamic_cast), и в его стандартную библиотеку в базе встроены исключения. Поэтому писать код без исключений в использованием стандартных инструментов практически невозможно. Вы конечно можете использовать [nothrow new](https://t.me/grokaemcpp/612) и написать свой вариант стандартной библиотеки и других сторонних решений. И кто-то наверняка так делал. Но в этом случае разработка как минимум затянется, а как максимум вы бросите это гиблое дело.

Поэтому повсеместно предоставлять nothow гарантии с использованием стандартных инструментов не всегда реалистично.

Но если такой термин есть, значит такие гарантии можно предоставлять для отдельных сущностей. Давайте как раз об этих сущностях и поговорим.

Но для начала проясним термины.

Под гарантией отсутствия исключений подразумевается обычно 2 понятия: nothrow и nofail.

nothrow подразумевает отсутствие исключений, но не отсутствие ошибок. Говорится, что ошибки репортятся другими средствами(в основном через глобальное состояние, потому что деструктор ничего не возвращает) или полностью скрываются и игнорируются. 

Примером сущностей с nothrow гарантией является деструкторы. С С++11 они по-умолчанию помечены noexcept. В основном это сделано для того, чтобы при раскрутке стека не получить [double exception](https://t.me/grokaemcpp/705). 
Но деструкторы могу фейлиться. Просто никаких средств, кроме глобальных переменных для репорта ошибок невозможно использовать. Они ведь ничего не возвращают, а исполняются скрытно от нас(если вы используете RAII конечно).

nofail же подразумевает полное отсутствие ошибок. nofail гарантия ожидается от std::swap, мув-конструкторов классов и других функций с помощью которых достигается строгая гарантия исключений. 

Например в [swap-идиоме](https://t.me/grokaemcpp/336) std::swap и мув-конструкторы используются для определения небросающего оператора присваивания. 

nofail гарантиями также должны обладать функторы-коллбэки модифицирующих алгоритмов. std::sort не предоставляет никаких гарантий на состояние системы, если компаратор бросит эксепшн.

В языке в целом эти гарантии обеспечиваются ключевым словом [noexcept](https://t.me/grokaemcpp/701). При появлении этой нотации компилятор понимает, что для этой функций не нужно генерировать дополнительный код, необходимый для обработки исключений. Но у этого есть своя цена: если из noexcept функции вылетит исключение, то сразу же без разговоров вызовется std::terminate.

Provide guarantees. Stay cool.

#cppcore #cpp11


Самая надежная гарантия отсутствия исключений
#опытным 

Исключения не любят не только и не столько потому, что они нарушают стандартный поток исполнения программы, могут привести к некорректному поведению системы и приходится везде писать try-catch блоки. Исключения - это не zero-cost абстракция. throw требуют динамические аллокации, catch - RTTI, а в машинном коде компилятор обязан генерировать инструкции на случай вылета исключений. Плюс обработка исключений сама по себе медленная.

Поэтому некоторые и стараются минимизировать использование исключений и максимальное использование noexcept кода.

Но можно решить проблему накорню. Так сказать отрезать ее корешок под самый корешок.

Есть такой флаг компиляции -fno-exceptions. Он запрещает использование исключений в программе. Но что значит запрет на использование исключений?

1 Ошибка компиляции при выбросе исключения. А я говорил, что под корень рубим. Вы просто не соберете программу, которая кидает исключения.

```cpp
int main() {
	throw 1; // even this doesn't compile
}
```

2 Ошибка компиляции при попытке обработать исключение. Ну а че, если вы живете в мире без исключений, зачем вам их обрабатывать? 

```cpp
int main() {
// even this doesn't compile
try {
} catch(...) {
}

}
```

3 Можно конечно сколько угодно жить в розовом мире без исключений, но рано или поздно придется использовать чужой код. Что будет, если он выкинет исключение?

```cpp
std::map<int, int> map;
std::cout << map.at(1) << std::endl;
```

Моментальное завершение работы. Оно как бы и понятно. Метод мапы at() кидает std::out_of_range исключение, если ключа нет в мапе. Но так как его все равно некому перехватить, то сразу же терминируемся. И никакой вам раскрутки стека и graceful shutdown. Просто ложимся и умираем, скрестив ручки.

То есть вы накорню запрещаете упоминание исключений в вашем коде, а если что-то пошло не по плану, то оно пойдет по п...

Зато получаете стабильно высокую производительность и предсказуемый флоу программы.

Как тогда код писать? А об этом через пару постов.

Handle errors. Stay cool.

#cppcore #compiler


Как стандартные хэдэры компилируются с -fno-exceptions?
#опытным 

В прошлом посте мы поговорили о том, что использование флага -fno-exceptions фактически трансформирует ваш код в диалект С++, в котором упоминание мира исключений карается ошибкой компиляции. Но каким образом компилируется код из стандартных заголовочных файлов? Там же повсюду обработка исключений?

Ответ прост. Макросы, товарищи. Вся магия в них. Вот на что заменяется обработка исключений:

```cpp
#if __cpp_exceptions
# define __try      try
# define __catch(X) catch(X)
# define __throw_exception_again throw
#else
# define __try      if (true)
# define __catch(X) if (false)
# define __throw_exception_again
#endif
```

При запрете исключений, обработка заменяется на максимально безобидные инструкции, а проброс исключения дальше превращается в ничто.

Ну и для большинства классов, унаследованных от `exception`, существуют соответствующие функции с C-линковкой:

```cpp
#if __cpp_exceptions
  void __throw_bad_exception()
  { throw bad_exception(); }
#else
  void __throw_bad_exception()
  { abort(); }
#endif
```

Тогда любая функция, которая бросает исключения должна триггерить std::abort. Или нет?

Нет. Вот [примерчик](https://compiler-explorer.com/z/z9h1EY7W4).

Стандартная библиотека не только в хэдэрах поставляется. Она еще и неявно динамически линкуется к каждой программе. И по дефолту она собирается с использованием исключений.

Чтобы это исправить, можно собрать ее с запретом исключений. Примерно так:

```bash
git clone git://gcc.gnu.org/git/gcc.git
cd gcc
git checkout <target_release_tag>
./configure \
    --disable-libstdcxx-exceptions \
    CXXFLAGS="-fno-exceptions <all_flags_that_you_need>"

make -j$(nproc)
make install
```

Тогда у вас действительно всегда будет вызываться abort. Потому что все эти макросы также находятся в сорс файлах.

Extend your limits. Stay cool.

#compiler



Возврат ошибки. Кастомная структура
#новичкам

Если нам запрещают кидать исключения, то надо как-то сообщать об ошибке. И самый прямолинейный способ это сделать - вернуть ошибку в качестве возвращаемого значения. Но как это сделать, если функция при успешном выполнении должна возвращать нормальное значение?

Обернем это все в класс и сделаем его типом возвращаемого значения!

```cpp
template<typename T>
struct Result {
    T value;
    std::string error;

    static Result ok(T val) {
        return Result{std::move(val), {}};
    }
  
    static Result fail(std::string err_msg) {
        return Result{T{}, std::move(err_msg)};
    }

    explicit operator bool() const { return error.empty(); }
};

Result<double> safe_divide(double a, double b) {
    if (b == 0.0) {
        return Result<double>::fail("Division by zero");
    }
    return Result<double>::ok(a / b);
}

auto div_result = safe_divide(10.0, 2.0);
if (div_result) {
	std::cout << "Result: " << div_result.value << std::endl;
} else {
	std::cout << "Error: " << div_result.error << std::endl;
}
```

Без шаблонной магии это выглядит примерно так. 2 условных поля - валидный результат и сообщение об ошибке(код ошибки). Ну и немного полезных методов для красивой инициализации результата.

Этот подход работает, но у него есть несколько весомых недостатков: 

- в структуре хранится всегда 2 поля, хотя семантически должно хранится что-то одно. Возвращается либо ошибка, либо валидный результат. Нет суперпозиции. А в коде выше есть. Как минимум это увеличивает размер объекта, а как максимум(при ошибочной реализации, но все же) приводит к той самой суперпозиции, когда есть и ошибка и результат.
- так как всегда конструируются и результат, и ошибка, то ничто не мешает использовать результат без проверки, вернула ли функция ошибку.

Нечто похожее используется в std::from_chars:

```cpp
std::from_chars_result from_chars(const char *first, const char *last,
					IntegerType &value, int base = 10);
struct from_chars_result {
	const char* ptr; // Указатель на первый НЕпрочитанный символ
	std::errc ec; // Код ошибки (если успех — std::errc())
};
```

Вообще говоря, похожее только синтаксически. Потому что в случае ошибки поле `ptr` тоже иногда полезно прочитать и понять, на каком символе ошибка.

В общем, классы результатов, где 2 поля, но только одно из них всегда актуальное -  не очень, так делать не нужно. Есть варианты получше.

You could do better. Stay cool.

#badpractice


Возврат ошибки. std::variant
#новичкам 

Если у вас есть С++17, то поздравляю, у вас есть std::variant, который решает проблему суперпозиции полей из прошлого поста.

По сути, вариант - это типобезопасный юнион, который хранит только один тип из списка шаблонных параметров. Объект варианта можно проверить на наличие нужного типа и есть способы no-exceptions сообщения об ошибке, если вы хотите получить доступ не к тому типу. Обычный std::get кидает исключение при неправильном доступе, но std::holds_alternative или std::get_if предоставляют небросающий апи:

```cpp
struct Error {
    std::string message;
};

std::variant<double, Error> safe_divide(double a, double b) {
    if (b == 0.0) {
        return Error{std::string"Division by zero"}};
    }
    return a / b;
}

auto div_result = safe_divide(10.0, 2.0);
if (std::holds_alternative<double>(div_result)) {
	std::cout << "Result: " << std::get<double>(div_result) << std::endl;
} else {
	std::cout << "Error: " << std::get<Error>(div_result).message << std::endl;
}
```

Библиотечный код стал ощутимо короче и не перестал быть таким же читаемым. Но вот клиентский код стал очевидно менее читаемым.

К этому привело то, что семантика "результат или ошибка" не заложена в самой идее std::variant. Для него все типы изначально равнозначны и равноожидаемы. Нет плохого и хорошего типа.

Чисто технически, вы можете сделать простую обертку из варианта, чтобы такая семантика появилась, но оставим это в качестве домашнего задания читателям.

Вариант не требует динамических аллокаций и занимает столько памяти, сколько нужно для самого большого типа(помимо небольшой метаинформации). Так что по части эффективности здесь все хорошо.

Еще можно легко возвращать несколько типов ошибки или значений, просто добавив нужный тип в список шаблонных параметров.

В небросающем коде нужно обязательно проверять каждый доступ к объекту варианта, потому что std::get кидает исключение. Ну или сразу используйте std::get_if, если точно знаете, какой должен быть тип, но нужно подстраховаться от ошибок.

Это хороший вариант, но больно пользоваться. Хочется более элегантного решения решения для этой проблемы. И оно есть! О этом в следующем посте.

Use a right semantic. Stay cool.

#cpp17


Возврат ошибки. std::expected
#опытным 

В С++23 появился практически идеальный класс для возврата объектов ошибки - std::expected.

Это та самая обертка над вариантом с приятным интерфейсом, о котором говорилось в прошлом посте.

```cpp
struct Error {
    std::string message;
};

std::expected<double, Error> safe_divide(double a, double b) {
    if (b == 0.0) {
        return std::unexpected(Error{"Division by zero"});
    }
    return a / b;
}

auto div_result = safe_divide(10.0, 2.0);

if (div_result.has_value()) {
	std::cout << "Result: " << div_result.value() << std::endl;
} else {
	std::cout << "Error: " << div_result.error().message << std::endl;
}
// или с операторами
if (div_result) { // operator bool
	std::cout << "Result: " << *div_result << std::endl; // operator*
} else {
	std::cout << "Error: " << div_result.error().message << std::endl;
}
```

По сути у std::expected в базовом интерефейсе 3 метода и пара операторов. Методы has_value(), value() и error() для проверки и доступа к значению или ошибке. И operator bool, operator*, operator-> для ленивых;

Преимущества нового типа `std::expected` по сравнению с `std::variant`:

- Хранит только два типа: значение и ошибка.
- Делает код интуитивно понятнее, поскольку для создания ошибки нужно использовать `std::unexpected`. Это особенно удобно, когда тип ошибки `std::string`. В этом случае использование `std::expected{ "Something bad happens" }` позволяет явно обозначить в коде, что мы не просто строку возвращаем, а сообщение об ошибке.
- Предоставляет простой и лаконичный базовый интерфейс: 3 метода и пара операторов. Методы has_value(), value() и error() для проверки и доступа к значению или ошибке. И operator bool, operator*, operator->, кому лень писать названия методов.


С std::expeсted удобно работать, если есть всего один тип результата и один тип ошибки. Работать с std::expected<std::variant<Type1, Type2>, Error> или std::expected<Type, std::variant<Error1, Error2>> не так удобно, как просто с вариантом из трех типов.

Must хэв при работе без исключений.

Use a right semantic. Stay cool.

#cpp23


Возврат ошибки. std::optional
#опытным 

У std::variant довольно громоздкий интерфейс при возврате ошибки вместе с результатом работы функции. Но в С++17 появился еще один класс, который имеет семантику "Или" для типов + более дружелюбный интерфейс.

Это std::optional. Этот шаблонный класс либо содержит нужный тип, либо не содержит его. Вот так может выглядеть код:

```cpp
struct Error {
    std::string message;
};

std::optional<double> safe_divide(double a, double b) {
    if (b == 0.0) {
        return std::nullopt;
    }
    return a / b;
}

auto div_result = safe_divide(10.0, 2.0);

if (div_result.has_value()) {
	std::cout << "Result: " << div_result.value() << std::endl;
} else {
	std::cout << "Error: there is no value" << std::endl;
}
// или с операторами
if (div_result) { // operator bool
	std::cout << "Result: " << *div_result << std::endl; // operator*
} else {
	std::cout << "Error: there is no value" << std::endl;
}
```

Для того, чтобы вернуть пустой optional, используется константа std::nullopt. А в остальном интерфейс очень похож на std::expected за исключением доступа к ошибке.

Но на мой взгляд, std::optional не очень подходит для обработки ошибок.

1 Он имеет семантику наличия или отсутствия значения. Отсутствие значения - это в принципе нормальная ситуация в программировании. Вы сделали Select к базе и получили пустоту, запросили что-то по апи и получили пустоту - вот самое место для std::optional.

Получается, что вы в одном месте кодовой базы используете опшинал для простой индикации наличия результата, а в другом случае отсутствие значения означает ошибку. Это несколько сбивает с толку. Хочется использовать разные инструменты для обоих этих случаев.

2 Если вам нужно специфицировать, какая конкретно ошибка произошла, то std::optional умывает рука. Нужно либо output параметры использовать, либо вообще другой класс.

Поэтому имхо, std::optional при обработке ошибок такая себе практика.

Use the right tool. Stay cool.

#cpp17


Output параметры
#новичкам 

Если у вас нет std::variant, std::expected, std::optional, вам лень засовывать ошибки в объекты, то у вас остается не так много вариантов. Один из них - output параметры функции.

Идея донельзя простая. Не хочешь использовать сложные типы? Добавь дополнительный параметр функции. Но конфигурация возвращаемого значения и параметров функции может быть разная.

- С-style 1. Возвращаем int, который каким-то образом кодирует ошибку + потенциально какую-то полезную информацию, а результат работы функции записывается в выходной параметр. Например системный вызов read:

```cpp
ssize_t read(size_t count, int fd, void buf[count], size_t count);
```

Возвращает количество прочитанных байт, либо -1, если произошла ошибка. Конкретная ошибка передается через errno. Сами данные записываются в buf.

Так как это не С++ подход, то он содержит все недостатки отсутствия ООП.

- С-style 2. Возвращаем enum ошибки с одним успешным элементом, а сам результат возвращаем в одном или нескольких выходных параметрах.

```cpp
enum ErrorCode {
    Success,
    DivisionByZero,
    NegativeNumber,
    Overflow
};

ErrorCode safe_sqrt(double x, double& result) {
    if (x < 0) {
        return ErrorCode::NegativeNumber;
    }
    result = std::sqrt(x);
    return ErrorCode::Success;
}

double result = 0.;
auto error = safe_sqrt(-4.0, result);
if (error != ErrorCode::Success) {
	process_error(error);
} else {
	std::cout << "Result: " << result << std::endl;
}
```

Странно, что функция возвращает ошибку, которая может быть Success. Плюс надо постоянно инициализировать результат до вызова.

- С-style 3. Наоборот, возвращаем результат, а в выходные параметры передаем потенциальную ошибку:

```cpp
double safe_sqrt(double x, ErrorCode& error) {
    if (x < 0) {
        error = ErrorCode::NegativeNumber;
        return {};
    }
    error = ErrorCode::Success;
    return std::sqrt(x);
}

ErrorCode error = ErrorCode::Success;
    
auto result = safe_sqrt(-4.0, error);
if (error != ErrorCode::Success) {
	process_error(error);
} else {
	std::cout << "Result: " << result << std::endl;
}
```

Такая сигнатура никак не форсит человека проверить код ошибки, можно случайно забыть проверить воспользоваться невалидным результатом.

Этот подход используется в том числе в стандартной библиотеке:

```cpp
bool exists( const std::filesystem::path& p, std::error_code& ec ) noexcept;
```

- Универсальный. Можно ввести и универсальный кодстайл: возвращаем bool в качестве индикатора успешности выполнения функции, а результаты и ошибки возвращаем в output параметрах.
```cpp
bool parse_coordinates(const std::string& input, 
                      double& x, double& y, double& z,
                      std::string& error_message);
double x, y, z;
std::string error_msg;

if (parse_coordinates("10.5,20.3,30.7", x, y, z, error_msg)) {
	std::cout << "Coordinates: " << x << ", " << y << ", " << z << std::endl;
} else {
	std::cout << "Error: " << error_msg << std::endl;
}
```

Здесь сигнатура явно форсит проверить результат(особенно с nodiscard). Но еще больше данных нужно инициализировать до вызова функции и код становится все менее декларативным.

Наверное когда-то это был популярный подход к обработке ошибок. Но в современном С++ существуют хорошие альтернативы, которые сделают ваш код проще, понятнее и консистентнее.

Prevent misuse. Stay cool.

#design



Небросающие контейнеры
#опытным 

У нас есть [небросающий new](https://t.me/grokaemcpp/612), который активно используется в безисключительном мире.

```cpp
MyClass * p1 = new MyClass; // привычное использование
MyClass * p2 = new (std::nothrow) MyClass; // небросающая версия
```

Но обычно нам не нужны такие низкоуровневые инструменты. По аналогии хочется и небросающих контейнеров! Точнее соответствующих методов работы с ними. С нуля все реализовывать слишком сложно.

Но вот беда. Небросающего апи у стандартных контейнеров вообще нет. В спецификации требований к аллокаторам подразумевается, что указатель, возвращаемый методом allocate, содержит валидный блок данных. А в случае ошибки кидает исключение. Других вариантов нет. Если вы в своем аллокаторе при ошибке аллокации вернете нулевой указатель, то получите UB. 

Интересно, как могли бы выглядеть небросающие методы того же вектора. Но сейчас немного о другом.

Вы скомпилировали вашу стандартную библиотеку в небросающей версии и любой выброс исключения заменяется на std::abort.

Приложение работает, работает и фигак: падает с абортом. Понятно, что нечего не понятно, но хотелось бы хоть как-нибудь задетектировать именно ошибку выделения памяти на фоне других проблем.

1 Можно написать свой STL-совместимый аллокатор, использующий nothrow new и в случае ошибки залогироваться и помереть спокойно. Придется писать относительно много кода

2 Можно использовать [new_handler](https://t.me/grokaemcpp/613) и просто установить обработчик на случай ошибки с выделением памяти. Фактически, дело пары строк:

```cpp
void handler()
{
    std::cout << "Memory allocation failed, terminating\n";
    std::abort;
}
int main()
{
    std::set_new_handler(handler);
    // ...
}
```

Все равно обычно мало что можно сделать при ошибке выделения памяти. Если хотите сделать ретрай, то это также можно сделать средствами хэндлера. Поэтому не вижу какого-то сакрального смысла в небросающих методах стандартных контейнеров. А если нужна кастомщина, то она у вас скорее всего уже есть.

Handle problems playfully. Stay cool.

#cppcore #STL




Обработка ошибок шердингера
#опытным 

Мы уже поговорили о том, что есть 2 подхода к обработке ошибок - исключения и возврат кода ошибки(std::expected или output параметры).

Особенно, если вы компилируете проект с -dno-exceptions вы можете спокойно помечать все свои функции noexcept.

И хоть стандартная библиотека насквозь пропитана исключениями, она все-таки иногда, очень редко предоставляет альтернативные варианты. Например [std::from_chars](https://t.me/grokaemcpp/732) или [std::to_chars](std::to_chars).

Интересно, что в библиотеке std::filesystem очень многие функции и методы имеют две перегрузки работы с данными: одна с исключениями, другая - без. Например:

```cpp
bool exists( const std::filesystem::path& p );
bool exists( const std::filesystem::path& p, std::error_code& ec ) noexcept;

// or

bool remove( const std::filesystem::path& p );
bool remove( const std::filesystem::path& p, std::error_code& ec ) noexcept;
```

Это очень полезно, если вы не желаете работать с исключениями.

Однако здесь приведены "образцово показательные" перегрузки. Посмотрите вот на это:

```cpp
directory_iterator& operator++();
directory_iterator& increment( std::error_code& ec );
```

Есть класс std::filesystem::directory_iterator и эти итераторы нужно уметь инкрементировать, чтобы двигаться по элементам директории. Так как сигнатура операторов в С++ не поддерживает лишние параметры, то для варианта с кодом ошибок приходится определять именованный метод. Обратите внимание, что increment не объявлен как noexcept!

То есть используя increment, вы не можете гарантировать отсутствие исключений. Да, ошибки при работе с файловой системой ОС передаются в качестве кодов ошибок. Но тот же std::bad_alloc increment кинуть может.

По всей видимости, мотивация не выбрасывать исключения связана с тем, что вызывающие стороны, использующие версию с исключениями, часто замусорены локальными блоками `try/catch` для обработки «рутинных» событий. Условно: при работе с файлами может оказаться, что у программы нет прав доступа для них. Это в целом нормальная ситуация в файловой системе, но передается через исключения, как исключительная ситуация. Чтобы это "рутинное" исключение не полетело дальше и не сломало что-то, надо обвешиваться всеми видами catch, что засоряет код.

Дизайн странный и путает людей. Поэтому будьте аккуратны с std::filesystem, если реально хотите убрать исключения с глаз долой.

Don't be confused. Stay cool.

#cpp17




https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0709r4.pdf


