1. CRTP и статический полиморфизм  
  
- понимает идею CRTP 
- применяет CRTP для реализации полиморфизма времени компиляции  
- применяет std::enabled_shared_from_this


Динамический полиморфизм и его проблемы. На примере паттерна команда и нескольких производных классов.
Статический полиморфизм CRPT. Упоминаем policy based pattern, говорим, что шаблон неявно задает интерфейс и делаем один шаг к наследованию политики от шаблонного класса. На примере того же паттерна команда.
Преимущества и недостатки по сравнению с динамическим полиморфизмом
Когда стоит использовать CRTP вместо policy? Когда мы переопределяем методы из базового класса. Базовый класс предоставляет базовую имплементацию, наследники могут решать, переопределять ее или нет..
Концепция миксинов. Вторая причина использовать crtp, можем подмешивать функционал к классу
Пример из стандартной либы std::enabled_shared_from_this. Объясняем, почему нельзя просто так создавать std::shared_ptr из себя.





## Введение

В С++ много уникальных паттернов и идиом связанных с шаблонами. Но CRTP выделяется среди них и представляет особый интерес, как с точки зрения реализации, так и с точки зрения решаемой задачи. Сегодня вы узнаете:

- Как реализовать статический полиморфизм с помощью CRTP и задавать интерфейс времени компиляции.
- В чем преимущества и недостатки CRTP.
- Что такое миксины и как они могут помочь однотипно расширять функционал классов.
- Как правильно использовать стандартный класс std::enable_shared_from_this.


## Динамический полиморфизм

Чтобы перейти к полиморфизму времени компиляции, давайте для начала вспомним, как реализуется полиморфизм времени выполнения.

```cpp
// базовый класс
struct Task {
	virtual void execute() = 0;
};

// наследники
struct DetectFraudMessage: public Task {
	DetectFraudMessage(const std::string& message) : message_{message} {}
	void execute() override {
		std::println("Message: \"{}\" - is fraud!", message_);
	}
	std::string message_;
};

struct DetectCursedWordsMessage: public Task {
	DetectCursedWordsMessage(const std::string& message) : message_{message} {}
	void execute() override {
		std::println("Message: \"{}\" - has cursed words!", message_);
	}
	std::string message_;
};
// единоообразно обрабатываем разные задачи с помощью указателя на базовый класс
std::unique_ptr<Task> command = std::make_unique<DetectFraudMessage>("Malicios message");
command->execute();
command = std::make_unique<DetectCursedWordsMessage>("Cursed Word");
command->execute();```

Код выше демонстрирует реализацию известного паттерна "Команда"(Всплывашка: **Команда** (Command) —  поведенческий паттерн проектирования, используемый при объектно-ориентированном программировании, представляющий действие. Конкретный объект команды заключает в себе само действие и его параметры.) Создаем интерфейс Task и наследуем от него конкретные действия: распознавание мошеннических сообщений и нецензурной лексики.

Прелесть в том, что мы можем единообразно с помощью указателя на базовый класс управлять объектами наследников и выполнять то действие, которое нам в данный момент нужно.

Это хорошее и стандартное решение задачи единообразной обработки данных. Но оно неидеальное.

За счет того, что мы не знаем реальных типов во время компиляции, компилятору сложно оптимизировать выполнение методов для этих типов. Например, в таком случае затрудняется инлайнинг кода методов(Всплывашка: Инлайнинг — процесс встаивания низкоуровнего кода функции в то место, откуда функция вызывается. За счет снижения накладных расходов на создание нового стекового фрейма и большей локальности инструкций и данных достигается значительное увеличение производительности.). В высоконагруженных real-time приложениях или в приложениях, которые работают на малопроизводительных процессорах(embedded), высокие затраты на виртуальные вызовы могут быть критичными.

#### Статический полиморфизм

В случае, если для вас неприемлемы затраты на вызов виртуальных функций, на помощь может прийти статический полиморфизм. Давайте перепишем предыдущий пример с помощью Policy based design pattern:

```cpp
struct DetectFraudMessage {
	DetectFraudMessage(const std::string& message) : message_{message} {}
	void doWork() {
		std::println("Message: \"{}\" - is fraud!", message_);
	}
	std::string message_;
};

struct DetectCursedWordsMessage {
	DetectCursedWordsMessage(const std::string& message) : message_{message} {}
	void doWork() {
		std::println("Message: \"{}\" - has cursed words!", message_);
	}
	std::string message_;
};

// Task - политика
template<typename Task>
struct Executor {
	Executor(const Task& task) : task_{task} {}
	void execute() {
		// выполняем задачу
		task_.doWork();
		std::println("Work has been done!");
	}
	Task task_;
};

Executor ex{DetectFraudMessage{"Malicios message"}};
ex.execute();
Executor ex1{DetectCursedWordsMessage{"Cursed Word"}};
ex1.execute();
```

Мы достигли того же самого, а именно единообразной обработки задач.

Давайте заметим несколько особенностей. 

1. В методе execute мы используем у политики метод do_work. Если у конкретной политики, с которой мы инстанцировали Executor не будет реализован этот метод, то произойдет ошибка компиляции. Таким образом в классе Executor мы задали неявный интерфейс, которому должна следовать политика.

2. Через Executor мы не просто выполняем другие задачи, мы инкапсулировали в него какую-то общую для обработки любой задачи логику(логирование завершения задачи). 

Погодите. Executor задает интерфейс и содержит общую логику. А что если ...

#### CRTP

А что если мы попробуем отнаследоваться от класса Executor? Больно уж он походит своими свойствами на базовый класс. Так мы избавимся от явного создания объекта Executor и все наследники будут иметь непосредственный доступ к общей функциональности через методы базового класса. Давайте посмотрим на нашем примере:

```cpp
template<typename Task>
struct Executor {
	void execute() {
		static_cast<Task*>(this)->doWork();
	}
};

struct DetectFraudMessage : Executor<DetectFraudMessage> {
	DetectFraudMessage(const std::string& message) : message_{message} {}
	void doWork() {
		std::println("Message: \"{}\" - is fraud!", message_);
	}
	std::string message_;
};

struct DetectCursedWordsMessage : Executor<DetectCursedWordsMessage> {
	DetectCursedWordsMessage(const std::string& message) : message_{message} {}
	void doWork() {
		std::println("Message: \"{}\" - has cursed words!", message_);
	}
	std::string message_;
};

DetectFraudMessage{"Malicios message"}.execute();
DetectCursedWordsMessage{"Cursed Word"}.execute();
```

Давайте отметим несколько особенностей:

1 Так как базовый класс у нас шаблонный, то наследники должны наследоваться от базового класса с собой в качестве шаблонного параметра.

2 Executor перестал иметь конструктор, он ему теперь ненужен, так как Executor теперь находится в одному иерархии с конкретными задачами.

3 Чтобы корректно вызвать метод конкретной таски, Executor должен получить доступ к реальному указателю на объект таски. При обычном наследовании базовый класс ничего не знает про своих наследников. Но у нас необычный случай. У Executor есть шаблонный параметр, который представляет из себя точный тип наследника. Поэтому мы можем безопасно привести this к указателю на наследника с помощью static_cast.

Таким образом, у нас появился интерфейс, который наследуют конкретные задачи(DetectFraudMessage, DetectCursedWordsMessage) и все они теперь имеют доступ к методу execute. Также Executor неявно задает интерфейс наследникам, так как внутри своего execute использует метод наследника. Теперь Executor, как сущность в пользовательском коде, вообще не нужен! Выходит, что с помощью такой техники наследования, мы получили возможности схожие с динамическим полиморфизмом на виртуальных функциях.

Подобная идея такого хитрого наследования наизнанку раз за разом возникала еще в раннем шаблонном коде С++(еще до стандартизации) применительно к совершенно разным ситуациям. Поэтому ее так и назвали "любопытно повторяющийся паттерн в шаблонах". Или Curiously recurring template pattern, CRTP.

#### Преимущества и недостатки CRTP

CRTP предлагает интересное и необычное решение для статического полиморфизма. Особенности реализации диктуют нам особенности в использовании. Давайте посмотрим, чем CRTP лучше или хуже динамического полиморфизма на виртуальных функциях.

Недостатки CRTP:

- Интерфейс, которому следуют наследники, задается неявно. Чтобы корректно реализовать наследника, нужно смотреть в реализацию методов базового класса. Это усложняет внесение новой функциональности и чтение кода.

- Невозможность оперировать наследниками через указатель или ссылку на базовый класс. Так как базовый класс - шаблон, параметризованный наследником, то на самом деле каждая инстанциация базового класса - это отдельные классы, которые никак не связаны друг с другом. У каждого наследника свой базовый класс и  свой тип ссылки и указателя. Это приводит, например, к затрудненному хранению наследников в контейнерах.

- Шаблонный код сложен для понимания многими разработчиками, поэтому применение таких необычных паттернов повышает когнитивную нагрузку на разработчиков, поддерживающий данный код.

Преимущества CRTP:

- Отсутствие накладных расходов на виртуальные вызовы. В тех приложениях, для которых важна скорость, CRTP - незаменимый вариант.

- И наследник, и базовый класс знают друг о друге. Это позволяет базовому классу использовать методы наследников. Чтобы достичь такого с помощью динамического полиморфизма, надо делать такие методы виртуальными. В CRTP же все решается в компайл-тайме.

- На самом деле базовый класс знает не только методы, но и статические члены, поля класса и зависимые типы. Это уникальная особенность CRTP, недостижимая с помощью динамического полиморфизма.

Итого. Используя CRTP мы страдаем при прочтении кода и ограничиваемся использованием объектов класса, без возможности их полиморфного управления по ссылкам и указателям на базовый класс. Но при этом получаем ощутимую прибавку перфоманса и уникальные возможности по взаимодействию внутренностей родителя и потомка.

Когда оправдано идти на жертвы, чтобы получить возможности, которые предоставляет CRTP?

#### Когда применять CRTP?

Любое применение, связанное с инверсией зависимости(Всплывашка: Инверсия Зависимостей - один из принципов объектно-ориентированного проектирования SOLID. Заключается в том, что классы должны зависеть от абстракций, а не от конкретных деталей) нам не подходит, потому что мы не можем единообразно управлять потомками через общую переменную.

Давайте отталкиваться от того, что нам дает CRTP. По сути, он дает всем потомкам общий интерфейс и общую функциональность. И еще он дает возможность базовому классу получать доступ к членам наследников. Из этого вытекает логичный сценарий применения: мы можем расширять классы общей функциональностью. И дополнительно(если мы хотим использовать полную мощь CRTP) эта общая функциональность может использовать методы наследников.

Класс, с помощью которого мы подмешиваем общую функциональность называется Mixin.

#### Миксины

Функциональность миксинов - это не специфичная для С++ штука. Они есть и в других языках программирования. Однако в С++ они реализуются именно за счет CRTP.

Посмотрим, на конкрентный пример миксина. Для итераторов приходится всегда определять операторы инкремента и декремента. Они есть также в постфиксной и префиксной формах. Не хочется для каждого итератора писать 4 метода, которые в каждом случае делают примерно одно и то же. И тут на помощью приходит миксин, который подмешивает в любые классы функциональность вышеупомянутых операторов. Реализуем класс iterator_base, который подмешивает операторы префиксного и постфиксного инкрементов в наследников:

```cpp
template <typename Derived>
class iterator_base {
public:
	// постфиксный инкремент
	Derived operator++(int) {
		Derived temp = derived();
		derived().increment();
		return temp;
	}
	// префиксный инкремент
	Derived& operator++() {
		derived().increment();
		return derived();
	}
private:
	// приватный метод хэлпер, чтобы не видеть в коде посторяющихся кастов
	Derived& derived() {
		return static_cast<Derived&>(*this);
	}

};

class my_iterator : public iterator_base<my_iterator> {
public:
	my_iterator(int* ptr) : ptr_(ptr) {}
	void increment() { ++ptr_; }
private:
	int* ptr_;
};

int arr[2] = {};
my_iterator r(&arr[0]);
r++;
++r;
```

Мы один раз определили миксин и просто наследуемся от него. При этом наследник получает доступ к методам родителя, который использует метод потомка, чтобы сделать реальный инкремент.

Таким образом мы избавляемся от необходимости реализовывать одни и те же скучные методы в наследниках.

#### std::enable_shared_from_this

Хрестоматийным примером миксинов и CRTP в общем из стандартной библиотеки является класс std::enable_shared_from_this. Чтобы понять, зачем он нужен, придется вспомнить особенности поведения std::shared_ptr.

```cpp
int main() {
	int * ptr = new int(42);
	std::shared_ptr<int> sp{ptr};
	std::shared_ptr<int> sp1{ptr};
}
```

В чем проблема с этим кодом?

Кнопка: Я знаю!

В этом коде память по указателю ptr будет освобождена дважды. Оба раза после выхода из скоупа обоих умных указателей. Так как эти два объекта указателей не связаны друг с другом общим control блоком, то счетчик сильных ссылок у них свой. Оба счетчика обнуляются при выходе из скоупа объекта, что триггерит вызов delete ptr.

То есть если мы создаем несколько умных указателей от одного и того же сырого указателя, то получаем упавшее в segfault'ом приложение с ошибкой double free.

Как правильно делать:

```cpp
int * ptr = new int(42);
std::shared_ptr<int> sp{ptr};
std::shared_ptr<int> sp1{sp};
```

Нужно создать второй указатель на основе первого, чтобы они разделяли общий control блок. Тогда при выходе из скоупа delete ptr вызовется всего один раз.

Такая наивная проблема может появиться в коде методов классов. Допустим мы хотим раздавать копию текущего объекта внешнему коду. Наивная реализация:

```cpp
struct Foo {
	Foo() : ptr{new int{42}} {}
	
	std::shared_ptr<Foo> getSharedPtr() {
		// создаем новый умный указатель на основе this
		return std::shared_ptr<Foo>(this);
	}
	~Foo() {delete ptr;}
private:
	int * ptr;
};

int main() {
	auto foo = std::make_shared<Foo>();
	auto foo1 = foo->getSharedPtr();
}
```

В этой реализации такая же проблема. Мы создаем новый shared_ptr на основе this. Тогда деструктор объекта this вызовется дважды: после выхода из скоупа foo1 и второй раз при выходе foo из скоупа. Словили ту же проблему.

Миксин std::enable_shared_from_this как раз решает подобную проблему. Он позволяет объекту obj, который уже создан внутри шаред поинтера, безопасно генерировать дополнительные экземпляры std::shared_ptr, которые разделяют владение над obj и имеют общий control блок. Таким образом гарантируется, что деструктор obj вызовется 1 раз.

Давайте посмотрим, как изменится последний пример с использованием std::enable_shared_from_this:

```cpp
// наследуемся от миксина
struct Foo : public std::enable_shared_from_this<Foo> {
	Foo() : ptr{new int{42}} {}
	std::shared_ptr<Foo> getSharedPtr() {
		// используем метод миксина shared_from_this
		return shared_from_this();
	}
	~Foo() {delete ptr;}
private:
	int * ptr;
};

// обязательно объект должен быть обернут в умный указатель
auto foo = std::make_shared<Foo>();
auto foo1 = foo->getSharedPtr();
auto foo2 = foo->getSharedPtr();
```

Обязательные условия корректного использования std::enable_shared_from_this:

- Наследование от std::enable_shared_from_this с указанием типа наследника в качестве шаблонного параметра.
- Использование метода shared_from_this(), который и создает новый инстанс умного указателя, на основе существующего.
- Изначальный объект должен быть сразу внутри умного указателя. Только используя метод getSharedPtr через существующий объект std::shared_ptr, реализуется вся магия.

Теперь мы можем  сколько угодно раз вызывать getSharedPtr, деструктор исходного объекта вызовется все равно 1 раз.

Подробнее почитать про магию работы std::enable_shared_from_this можно [на cppreference](https://en.cppreference.com/w/cpp/memory/enable_shared_from_this) и[ в исходниках стандартной библиотеки от gcc](https://github.com/gcc-mirror/gcc/blob/1ad1bcc991b32d72d4de4758c0dcac611f20cda8/libstdc%2B%2B-v3/include/bits/shared_ptr.h#L918).

А также больше примеров применения CRTP можно найти [тут](https://vishalchovatiya.com/posts/crtp-c-examples/) ,[в библиотеке boost](https://www.boost.org/doc/libs/1_87_0/libs/iterator/doc/iterator_facade.html), [в базе данных ClickHouse](https://github.com/ClickHouse/ClickHouse/blob/master/src/Common/COW.h), [в довольно известном браузере Chrome](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/heap/cppgc/heap-visitor.h) и [в самом компилятора С++](https://clang.llvm.org/doxygen/RecursiveASTVisitor_8h_source.html).  

#### CRTP и deducing this

C++23 принес нам новую фичу - deducing this. Теперь мы можем явно специфицировать cv-ref квалифицированный тип объекта, на котором мы вызываем метод:

```cpp
struct Cat {
	std::string name;
    void print_name(this cat& self);
    void print_name(this const cat& self);
    void print_name(this cat&& self);
    void print_name(this const cat&& self);
};
```

У него одна особенность. this - это точный тип объекта, с которым вызван метод. Таким образом, даже в родительском методе мы можем вызвать метод ребенка и это будет работать!

```cpp
struct Animal {
	// здесь используем шаблон и используем универсальную ссылку, чтобы вызовать метод у объектов с разной константными и ссылочными квалификаторами
	template <typename Self>
	void print(this Self&& self) {
		self.print_name();
	}
};

struct Cat : public Animal {
	std::string name;
	void print_name() {
		std::println("Cat");
	}
};

Cat{}.print(); // Выведется "Cat"
```

Так это же и есть наш CRTP, только лаконичнее и без странного двунаправленного наследования. Давайте преобразуем наш прошлый пример с Executor с помощью deduction this:

```cpp
struct Executor {
	template <class Self>
	void execute(this Self&& self) {
		self.doWork();
	}
};

struct DetectFraudMessage : Executor {
	DetectFraudMessage(const std::string& message) : message_{message} {}
	void doWork() {
		std::println("Message: \"{}\" - is fraud!", message_);
	}
	std::string message_;
};

DetectFraudMessage{"message"}.execute(); // Выведется "Message: "message" - is fraud!"
```

Теперь код выглядит более читаемым и понятным. При этом сохраняются все бенефиты статического полиморфизма. Deduction this - одна из мажорных фич С++23, которая сильно упростило идиому CRTP.

#### Заключение

Давайте повторим, что мы сегодня узнали:

- В некоторых случаях накладные расходы на динамический полиморфизм могут быть неприемлемы
- CRTP позволяет реализовывать статический полиморфизм за счет уникальной механики наследования.
- Использование CRTP затрудняет понимание и чтение кода, но не требует дополнительных расходов на производительность и открывает возможности для оперирования наследниками в базовом классе 
- Миксины, основанные на технике CRTP позволяют подмешивать часто используемую функциональность в наследников.
- Используйте наследование от std::enable_shared_from_this, когда вам нужно создавать инстансы шаред поинтера, которые указывают на текущий объект.



Динамический полиморфизм так не может

Больше примеров использования CRTP можно найти [тут](https://vishalchovatiya.com/posts/crtp-c-examples/) 

  
