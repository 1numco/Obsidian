1. CRTP и статический полиморфизм  
  
- понимает идею CRTP 
- применяет CRTP для реализации полиморфизма времени компиляции  
- применяет std::enabled_shared_from_this


Динамический полиморфизм и его проблемы. На примере паттерна команда и нескольких производных классов.
Статический полиморфизм CRPT. Упоминаем policy based pattern, говорим, что шаблон неявно задает интерфейс и делаем один шаг к наследованию политики от шаблонного класса. На примере того же паттерна команда.
Преимущества и недостатки по сравнению с динамическим полиморфизмом
Когда стоит использовать CRTP вместо policy? Когда мы переопределяем методы из базового класса. Базовый класс предоставляет базовую имплементацию, наследники могут решать, переопределять ее или нет..
Концепция миксинов. Вторая причина использовать crtp, можем подмешивать функционал к классу
Пример из стандартной либы std::enabled_shared_from_this. Объясняем, почему нельзя просто так создавать std::shared_ptr из себя.





## Введение

В С++ много уникальных паттернов и идиом связанных с шаблонами. Но CRTP выделяется среди них и представляет особый интерес, как с точки зрения реализации, так и с точки зрения решаемой задачи. Сегодня вы узнаете:

- Как реализовать статический полиморфизм с помощью CRTP и задавать интерфейс времени компиляции.
- Что такое миксины и как они могут помочь однотипно расширять функционал классов.
- Как правильно использовать стандартный класс std::enable_shared_from_this.


## Динамический полиморфизм

Чтобы перейти к полиморфизму времени компиляции, давайте для начала вспомним, как реализуется полиморфизм времени выполнения.

```cpp
// базовый класс
struct Task {
	virtual void execute() = 0;
};

// наследники
struct DetectFraudMessage: public Task {
	DetectFraudMessage(const std::string& message) : message_{message} {}
	void execute() override {
		std::println("Message: \"{}\" - is fraud!", message_);
	}
	std::string message_;
};

struct DetectCursedWordsMessage: public Task {
	DetectCursedWordsMessage(const std::string& message) : message_{message} {}
	void execute() override {
		std::println("Message: \"{}\" - has cursed words!", message_);
	}
	std::string message_;
};
// единоообразно обрабатываем разные задачи с помощью указателя на базовый класс
std::unique_ptr<Task> command = std::make_unique<DetectFraudMessage>("Malicios message");
command->execute();
command = std::make_unique<DetectCursedWordsMessage>("Cursed Word");
command->execute();```

Код выше демонстрирует реализацию известного паттерна "Команда"(Всплывашка: **Команда** (Command) —  поведенческий паттерн проектирования, используемый при объектно-ориентированном программировании, представляющий действие. Конкретный объект команды заключает в себе само действие и его параметры.) Создаем интерфейс Task и наследуем от него конкретные действия: распознавание мошеннических сообщений и нецензурной лексики.

Прелесть в том, что мы можем единообразно с помощью указателя на базовый класс управлять объектами наследников и выполнять то действие, которое нам в данный момент нужно.

Это хорошее и стандартное решение задачи единообразной обработки данных. Но оно неидеальное.

За счет того, что мы не знаем реальных типов во время компиляции, компилятору сложно оптимизировать выполнение методов для этих типов. Например, в таком случае затрудняется инлайнинг кода методов(Всплывашка: Инлайнинг — процесс встаивания низкоуровнего кода функции в то место, откуда функция вызывается. За счет снижения накладных расходов на создание нового стекового фрейма и больше локальности инструкций и данных достигается значительное увеличение производительности.). В высоконагруженных real-time приложениях или в приложениях, которые работают на малопроизводительных процессорах(embedded), высокие затраты на виртуальные вызовы могут быть критичными.

#### Статический полиморфизм

В случае, если для вас неприемлемы затраты на вызов виртуальных функций, на помощь может прийти статический полиморфизм. Давайте перепишем предыдущий пример с помощью Policy based design pattern:

```cpp
struct DetectFraudMessage {
	DetectFraudMessage(const std::string& message) : message_{message} {}
	void doWork() {
		std::println("Message: \"{}\" - is fraud!", message_);
	}
	std::string message_;
};

struct DetectCursedWordsMessage {
	DetectCursedWordsMessage(const std::string& message) : message_{message} {}
	void doWork() {
		std::println("Message: \"{}\" - has cursed words!", message_);
	}
	std::string message_;
};

// Task - политика
template<typename Task>
struct Executor {
	Executor(const Task& task) : task_{task} {}
	void execute() {
		// выполняем задачу
		task_.doWork();
		std::println("Work has been done!");
	}
	Task task_;
};

Executor ex{DetectFraudMessage{"Malicios message"}};
ex.execute();
Executor ex1{DetectCursedWordsMessage{"Cursed Word"}};
ex1.execute();
```

Мы достигли того же самого, а именно единообразной обработки задач.

Давайте заметим несколько особенностей. 

1. В методе execute мы используем у политики метод do_work. Если у конкретной политики, с которой мы инстанцировали Executor не будет реализован этот метод, то произойдет ошибка компиляции. Таким образом в классе Executor мы задали неявный интерфейс, которому должна следовать политика.

2. Через Executor мы не просто выполняем другие задачи, мы инкапсулировали в него какую-то общую для обработки любой задачи логику(логирование завершения задачи). 

Погодите. Executor задает интерфейс и содержит общую логику. А что если ...

#### CRTP

А что если мы попробуем отнаследоваться от класса Executor? Больно уж он походит своими свойствами на базовый класс. Так мы избавимся от явного создания объекта Executor и все наследники будут иметь непосредственный доступ к общей функциональности через методы базового класса. Давайте посмотрим на нашем примере:

```cpp
template<typename Task>
struct Executor {
	void execute() {
		static_cast<Task*>(this)->doWork();
	}
};

struct DetectFraudMessage : Executor<DetectFraudMessage> {
	DetectFraudMessage(const std::string& message) : message_{message} {}
	void doWork() {
		std::println("Message: \"{}\" - is fraud!", message_);
	}
	std::string message_;
};

struct DetectCursedWordsMessage : Executor<DetectCursedWordsMessage> {
	DetectCursedWordsMessage(const std::string& message) : message_{message} {}
	void doWork() {
		std::println("Message: \"{}\" - has cursed words!", message_);
	}
	std::string message_;
};

DetectFraudMessage{"Malicios message"}.execute();
DetectCursedWordsMessage{"Cursed Word"}.execute();
```

Давайте отметим несколько особенностей:

1 Так как базовый класс у нас шаблонный, то наследники должны наследоваться от базового класса с собой в качестве шаблонного параметра.

2 Executor перестал иметь конструктор, он ему теперь ненужен, так как Executor теперь находится в одному иерархии с конкретными задачами.

3 Чтобы корректно вызвать метод конкретной таски, Executor должен получить доступ к реальному указателю на объект таски. При обычном наследовании базовый класс ничего не знает про своих наследников. Но у нас необычный случай. У Executor есть шаблонный параметр, который представляет из себя точный тип наследника. Поэтому мы можем привести this к указателю на наследника с помощью static_cast

Таким образом, у нас появился интерфейс, который наследуют конкретный задачи(DetectFraudMessage, DetectCursedWordsMessage) и все они теперь имеют доступ к методу execute. Также Executor неявно задает интерфейс наследникам, так как внутри своего execute использует метод наследника. Теперь Executor, как сущность в пользовательском коде, вообще не нужен! Выходит, что с помощью такой техники наследования, мы получили возможности схожие с динамическим полиморфизмом на виртуальных функциях

Подобная идея такого хитрого наследования наизнанку раз за разом возникала еще в раннем шаблонном коде С++(еще до стандартизации) применительно к совершенно разным ситуациям. Поэтому ее так и назвали "любопытно повторяющийся паттерн в шаблонах". Или Curiously recurring template pattern, CRTP.

#### Преимущества и недостатки CRTP

CRTP предлагает интересное и необычное решение для статического полиморфизма. Особенности реализации диктуют нам особенности в использовании. Давайте посмотрим, чем CRTP лучше или хуже динамического полиморфизма на виртуальных функциях.

Больше примеров использования CRTP можно найти [тут](https://vishalchovatiya.com/posts/crtp-c-examples/) 

  

## Примерная структура

  

Динамический vs статический полиморфизм

  

Основная идея CRTP

  

сравнение policy based design и полиморфизм через CRTP, движение от PBD к CRTP

  

квиз по пониманию CRTP, показываем варианты реализации, предлагаем выбрать верные.

  

реализация шаблонного метода через CRTP

  

о других возможностях CRTP, доступ к полям, wrapper на специализации шаблона CRTP

  

Контроль интерфейса через CRTP

  

сниппет по CRTP предлагаем сделать рефакторинг, уйти от PBD к CRTP сделать более внятным код, и понятной ошибку.

  

std::enable_shared_from_this как пример CRTP

  
  

# Контент урока

  

## Введение

  

Недавно мы говорили о policy based дизайне на шаблонах и его аналогиях на основе полиморфизма виртуальных функций.

Эта тема имеет продолжение, есть способы получить свойства и других сторон полиморфизма в статике, с помощью шаблонов.

Сегодня мы:

  

- познакомимся с идиомой CRTP

- сравним использование динамического и статического полиморфизма на нескольких примерах

- и известным случаем её применения - std::enable_shared_from_this

  

## Динамический и статический полиморфизм, основная идея CRTP

  

Вспомним ещё раз, как это выглядит на основе виртуальных функций

  

```cpp

#include <iostream>

#include <memory>

  

struct Base {

virtual void doWork() { std::cout << "Base work\n"; }

virtual ~Base() = default;

};

  

struct Derived : public Base {

void doWork() override { std::cout << "Derived work\n"; }

};

  

void process(Base& obj) {

obj.doWork(); // Вызов через vtable

}

  

int main() {

std::unique_ptr<Base> obj = std::make_unique<Derived>();

process(*obj); // Выведет "Derived work"

}

```

  

Ключевой момент - обращение к типу, который представляет интерфейс, может вести к разным реализациям этого интерфейса, т.е за Base может быть Derived, может другой класс, наследник Base.

Проблемы и преимущества уже известны, и, поскольку мы говорим о шаблонах, а значит о времени компиляции, здесь для нас только лишние затраты ресурсов из за виртуальных функций.

  

Шаблонный дизайн на основе политик:

  

```cpp

#include <iostream>

  

// Политики работы

struct FastWork {

void doWork() { std::cout << "Fast work\n"; }

};

  

struct SafeWork {

void doWork() { std::cout << "Safe work\n"; }

};

  

// Основной класс с параметризуемым поведением

template <typename WorkPolicy>

class Worker {

public:

void doWork() {

policy.doWork();

}

private:

WorkPolicy policy;

};

  

// Шаблонная функция, дающая косвенное обращение к типу реализации

template <typename T>

void process(Worker<T>& obj) {

obj.doWork(); // Вызывает метод без vtable!

}

  

int main() {

Worker<FastWork> fastWorker;

Worker<SafeWork> safeWorker;

  

fastWorker.doWork(); // "Fast work"

safeWorker.doWork(); // "Safe work"

  

process(fastWorker);

}

```

  

Он не только обеспечивает статический полиморфизм, но и ограничивает интерфейс.

Здесь параметризуемый класс Worker аналог базового класса Base. Классы, которыми он специализируется - аналог реализаций в производных классах. То есть реализация и интерефейс оказались разделены.

В коде функции process известно, что obj это Worker, компилятор следит за этим, так же как и в случае с Base, и мы можем использовать Worker как интерфейс, вроде Base из первого примера с виртуальными функциями.

Итак, если параметр policy играет роль реализации собственного интерфейса Worker как в примере выше, то во многом воспроизводятся свойства интерфейсов на виртуальных функциях, и вообще наследования.

Можно сделать общий функционал в Worker, как в базовом классе при наследовании.

Можно сделать аналог расширения интерфейса в производном классе

там где с виртуальными функциями мы расширяли бы интерфейс дополняя базовый класс, и его получали все подклассы при наследовании - здесь меняете сам Worker.

Мало того, можно сделать статические функции со свойствами виртуальных функций.

  

Но такой вариант бывает очень неудобен.

Во первых наследование в с++ воспринимается как отношение "является",

т.е если мы хотим сказать, что FastWork это Worker, то наследуем FastWork от Worker. Здесь же приходится писать ```cpp Worker<FastWork>. ```

Во вторых классом наследником можно манипулировать напрямую, здесь его аналог спрятан внутри параметризуемого класса. Это второе обстоятельство вырастает в серьёзную проблему урезания интерфейса, или разделения доступа.

Она видна, если в некоторых производных классах добавить специфический метод. Например. какая то особенная инициализация, которая нужна только при инициализации, а некоторым пользователям её трогать нельзя.

  

```cpp

#include <iostream>

#include <memory>

  

struct Base {

virtual void doWork() { std::cout << "Base work\n"; }

virtual ~Base() = default;

  

};

  

struct Derived1 : public Base {

void doWork() override { std::cout << "Derived work\n"; }

void init(int){ }//специфический методпроизводного класса, не обязательно инициализация, просто хотим ограничить круг пользователей.

};

  
  

struct Derived2 : public Base {

void doWork() override { std::cout << "Derived work\n"; }

void init(const std::string){ }

};

  

void process(Base& obj) {

obj.doWork(); // Вызов через vtable

// obj->init(2);// здесь об этом методе ничего не знаем, использовать не можем

}

  

int main() {

std::unique_ptr<Base> obj = std::make_unique<Derived1>();

obj->init(2);// здесь имеем доступ к расширенному интерфейсу.

process(*obj); // а здесь - нет.

}

```

  

Как это сделать шаблонами?

Например добавив ещё уровень наследования, который можно обрезать при передаче в process().

  

Например так:

```cpp

  

// Политики работы

struct FastWork {

void doWork() { std::cout << "Fast work\n"; }

void init(int) { }

};

  

struct SafeWork {

void doWork() { std::cout << "Safe work\n"; }

void init(const std::string) { }

};

  

// Основной класс с параметризуемым поведением

template <typename WorkPolicy>

class Worker {

public:

void doWork() {

policy_.doWork();

}

protected:

WorkPolicy policy_;

};

  

template <typename WorkPolicy>

class WorkerDerived :

public Worker<WorkPolicy> // показываем потребителю всё тот же урезаный интерфейс

{

public:

WorkPolicy& accessImpl() { return Worker<WorkPolicy>::policy_; }// даём доступ к расширенному интерфейсу.

};

// Шаблонная функция, дающая косвенное обращение к типу реализации

template <typename T>

void process(Worker<T>& obj) {

obj.doWork(); // Вызывает метод без vtable!

//obj.accessImpl().init(3);// не получится!

}

  

int main()

{

WorkerDerived<FastWork> fastWorker;

WorkerDerived<SafeWork> safeWorker;

fastWorker.accessImpl().init(2);

process(fastWorker);

return 0;

}

```

  

А можно создавать policy отдельно, и и обращаться к ним напрямую.

В общем, способы есть. Все они не решают всех проблем, создают новые, и выглядят избыточно.

  

Возможно поэтому, ещё на заре шаблонов с++ коллективное бессознательное энтузиастов с++ раз за разом в разных проектах порождало странный рекурсивный код, где базовый класс параметризован дочерним, и обращается к методам дочернего. Этот подход так и называется - CRTP (Curiously Recurring Template Pattern). Это вывернутое наследование как раз позволяет то, что не может подобие стратегии на основанном на политиках дизайне - прямой аналог виртуального наследования с похожей семантикой. Но главное, ограничение интерфейса стало более явным, и более контролируемым. И никаких дополнительных классов!

  

Ниже пример, такого кода. На класс Base можно посмотреть как на случай того же статического полиморфизма, что и в policy based, но в качестве параметра шаблона передан тип производного класса.

  

```cpp

#include <iostream>

  

// Базовый CRTP-класс

template <typename Derived>

class Base {

public:

void doWork() {// Обращение к базовому классу

static_cast<Derived*>(this)->doWorkImpl();

}

  

protected:

Base() = default;// отдельно Base создавать нельзя!

};

  

// Производный класс

class Derived : public Base<Derived> {

public:

void doWorkImpl() {

std::cout << "Derived doing work\n";

}

void init(int){ }

};

  

// Шаблонная функция, принимающая CRTP-класс

template <typename T>

void process(Base<T>& obj) {//Ожидаем Base, который и определяет интерфейс

obj.doWork(); // Вызывает метод без vtable!

}

  

int main() {

Derived d;

process(d); // Выведет: "Derived doing work"

}

```

  

Теперь к реализации Derived доступ через интерфейс Base, как и должно быть при наследовании с виртуальными функциями. При этом все преимущества шаблонной реализации сохраняются, к дополнительным минусам можно отнести явное приведение типа в doWork(), static_cast<Derived*>(this)->doWorkImpl(); На производительности это в конечном счёте на скажется, но читаемость, а значит стоимость поддержки кода - страдает. Поскольку это фактически интерфейс - стабильная часть любой системы, недостаток оказывается незначительным.

Из за рекурсивности шаблона нельзя создавать базовые объекты отдельно, поэтому конструктор защищается в коде, - нечаянная аналогия с абстрактным базовым классом.

  

Итак, у нас в распоряжении замечательный инструмент.

Конечно, основной смысл CRTP вовсе не в цирковом эффекте похожести некоторых шаблонов на виртуальные функции.

Ценность реализации полиморфизма в очень полном виде с помощью CRTP как в примере выше - в простом и интуитивном определении и ограничении интерфейса, в нашем случае Base, который имеет разную реализацию.

  

## квиз по пониманию CRTP

  

Какой из следующих вариантов демонстрирует корректное использование CRTP?

Формат: радиобаттон

[] A
```cpp
template <typename T>
struct Base {
	virtual void interface() = 0;
};

struct Derived : Base<Derived> {
	void interface() override { /* ... */ }
};
```

*Пояснение*: Неверно, данный пример использует виртуальные функции, что противоречит принципу CRTP, основанному на статическом (компилируемом) полиморфизме.

[] B
```cpp
template <typename Derived>
struct Base {
	void interface() { static_cast<Derived*>(this)->implementation(); }
};

struct Derived : Base<int> {
	void implementation() { /* ... */ }
};
```

*Пояснение*: Неверно, поскольку Derived должен наследоваться от Base\<Derived>, а не Base\<SomeDifferentClass>. Такая ошибка приводит к неопределенному поведению из-за каста к неправильному типу.

[X] C
```cpp
template <typename Derived>
struct Base {
	void interface() { static_cast<Derived*>(this)->implementation(); }
};

struct Derived : Base<Derived> {
	void implementation() { /* ... */ }
};
```

*Пояснение*: Этот пример корректно демонстрирует CRTP: производный класс наследуется от базового класса, параметризованного самим собой, что позволяет базовому классу вызывать метод implementation() из производного класса.

[] D
```cpp
template <typename Derived>
struct Base {
	void interface() { static_cast<Derived*>(this)->implementation(); }
};

struct Derived : Derived<Base> {
	void implementation() { /* ... */ }
};
```

*Пояснение*: Здесь перепутаны местами классы при наследовании Derived. Должно быть так: `struct Derived : Base<Derived>`


## конец квиза по пониманию CRTP

  
  
  

## реализация шаблонного метода через CRTP

  

Идея о доступности типа производного класса в базовом даёт множество возможностей.

Помимо аналога виртуального базового класса можно, например, реализовать шаблонный метод, со всеми преимуществами шаблонов.

  

> шаблонный метод, шаблон проектирования, где алгоритм реализован в базовом частично, и некоторые его части можно заменить или дополнить. Классический с++ вариант реализации предусматривает вызовы в методе базового класса помимо прочего кода - виртуальных функций, которые определяются, или переопределяются в производных классах.

  

Динамический, на виртуальных функциях вариант шаблонного метода:

  

```cpp

struct Base {

void templateMethod() {

std::cout << "Start\n";// здесь может быть каркасс функционала, общая часть шаблонного метода.

step(); // Виртуальный вызов

std::cout << "End\n";// здесь тоже

}

virtual void step() = 0;// настраиваемая часть шаблонного метода, таких виртуальных вызовов может быть множество, и вызываться они могут в довольно сложном коде шаблона метода.

};

  

struct Derived : public Base {

void step() override { std::cout << "Step in Derived\n"; }//текущая настройка шаблонного метода

};

  

int main() {

Derived d;

d.templateMethod();

}

```

  

Статический вариант:

  

```cpp

template <typename Derived>

struct Base {

void templateMethod() {

std::cout << "Start\n";

static_cast<Derived*>(this)->step();

std::cout << "End\n";

}

};

  

struct Derived : public Base<Derived> {

void step() { std::cout << "Step in Derived\n"; }

};

  

int main() {

Derived d;

d.templateMethod();

}

```

  

Как видим, помимо вызова метода step() производного класса, в шаблонном коде есть другой код, тот самый "шаблон", который может быть сколь угодно сложным.

  

## другие возможности CRTP

  

Самый первый вариант СРТP, рассмотренный сегодня, может быть основой реализации ещё одного шаблона проектирования - адаптер, преобразователь одного интерфейса к другому.

Класс Base определяет общий интерфейс, а вот в производных классах он может отличаться. Здесь специализация для разных классов помогает адаптировать интерфейс производного класса к базовому.

  

```cpp

  

// Предварительное объявление Derived2

class Derived2;

  

// Базовый CRTP-класс (для всех классов, кроме специализированных)

template <typename Derived>

class Base {

public:

void doWork() {

static_cast<Derived*>(this)->doWorkImpl();

}

};

  

template <>

class Base<Derived2> {

public:

void doWork();

};

  

// === Производный класс Derived ===

class Derived : public Base<Derived> {

public:

void doWorkImpl() {

std::cout << "Derived doing work\n";

}

};

  

// Производный класс Derived2 (определяется ПОСЛЕ специализации Base<Derived2>)

class Derived2 : public Base<Derived2> {

public:

void doWorkImpl2() {

std::cout << "Derived2 doing work\n";

}

};

  

// Определение метода doWork() после полного объявления Derived2

void Base<Derived2>::doWork() {

static_cast<Derived2*>(this)->doWorkImpl2(); // Теперь static_cast работает!

}

  

// Шаблонная функция, принимающая CRTP-класс

template <typename T>

void process(Base<T>& obj) {

obj.doWork(); // Вызывает метод без vtable!

}

  

int main()

{

Derived d;

process(d); // Derived doing work

  

Derived2 d2;

process(d2); // Derived2 doing work

return 0;

}

```

  

Здесь стоит обратить внимание на последовательность определения классов и функций в коде, устройство шаблонов, особенности их инстанцирования требуют доступность исходного кода там, где он используется. Это усложняет код, здесь у шаблонного адаптера есть дополнительный минус.

  

Доступ к базовому типу означает большую свободу, можно просто использовать поля базового класса, или его типы, для всех случаев даже не подобрать типовых решений, или шаблонов проектирования. Это просто способ обеспечить свободу разработчика, которому даже нет аналогий в динамическом варианте.

  

```cpp

template <typename Derived>

struct Base {

void set(int val) {// доступ к полю базового класса

static_cast<Derived*>(this)->value = val;

}

};

  

struct Derived : public Base<Derived> {

int value;

};

  

int main() {

Derived d;

d.set(10);

std::cout << d.value; // 10

}

```

Теперь можно попрактиковаться:

  

проведите рефакторинг попытки использовать статический полиморфизм. В исходном виде код с может легко менять реализации функции, но интерфейс этой реализации явно не определён. При попытке использовать класс Increment, нарушающий неявный интерфейс - ошибка указывает на реализацию функции runStrategy. Сделайте интерфейс явным с помощью CRTP, чтобы упростить поддержку стратегии. Increment не соответствует интерфейсу и должен давать более понятную ошибку.

  

## Сниппет 1 (с проверкой)

  

```cpp

template<typename T>

class Strategy

{

public:

int execute(int a, int b) {

return 0;

}

};

  

class Add

{

public:

int compute(int a, int b) { return a + b; }

};

  

class Multiply

{

public:

int compute(int a, int b) { return a * b; }

};

  

class Increment // этот класс не поддерживает общий интерфейс и используется ошибочно.

{

public:

int compute(int a) { return ++a; }

};

  

template<typename T>

void runStrategy( T& strat, int a, int b ) {

strat.compute(a, b);

}

  

int main()

{

Add add;

Multiply mul;

Increment inc;

  

runStrategy(add, 1, 2);

runStrategy(mul, 1, 2);

runStrategy(inc, 1, 2);

return 0;

}

```

  

```cpp

template<typename T>

class Strategy

{

public:

int execute(int a, int b) {

return static_cast<T*>(this)->compute(a, b);

}

};

  

class Add: public Strategy<Add>

{

public:

int compute(int a, int b) { return a + b; }

};

  

class Multiply: public Strategy<Add>

{

public:

int compute(int a, int b) { return a * b; }

};

  

class Increment

{

public:

int compute(int a) { return ++a; }

};

  

template<typename T>

void runStrategy(Strategy<T>& strat, int a, int b) {

strat.execute(a, b);

}

  

int main()

{

Add add;

Multiply mul;

Increment inc;

  

runStrategy(add, 1, 2);

runStrategy(mul, 1, 2);

runStrategy(inc, 1, 2);// теперь ошибка указывает на вызов с параметром не соответствующим интерфейсу.

return 0;

}

  

```

## Подсказка

Сделайте Strategy интерфейсом для runStrategy

  

## на что обратить внимание

не забудьте унаследовать Strategy< > все типы, которые должны поддерживать интерфейс.

не забудьте при этом параметризовать Strategy этими типами.

  

## Текст успеха

  

Прекрасно, вы прошли по стопам энтузиастов, переоткрывавших эту идиому друг за другом десятки лет назад !

  

## Конец сниппета 1

  
  

## std::shared_from_this, как пример CRTP

  

std::enable_shared_from_this — это стандартный класс в C++, который решает проблему получения shared_ptr из this.

Основная его цель - безопасно создавать shared_ptr на текущий объект (this) внутри его методов. Этот класс используется как базовый, и для корректной работы должен иметь точный тип производного класса. Конечно, он использует CRTP.

  

Ниже набросок enable_shared_from_this с основными элементами.

  

```cpp

template <typename T>

class enable_shared_from_this {

protected:

std::weak_ptr<T> weakThis; // Храним слабую ссылку на объект

  

public:

std::shared_ptr<T> shared_from_this() {

return weakThis.lock(); // Создаём shared_ptr только если объект ещё существует

}

};

```

  

Здесь видна причина потребности в CRTP, в коде требуется тип, который может быть получен от параметра шаблона, т.е. от базового типа.

  

```cpp

#include <iostream>

#include <memory>

  

class Safe : public std::enable_shared_from_this<Safe> {

public:

std::shared_ptr<Safe> getPtr() {

return shared_from_this(); // Безопасно! Возвращает тот же shared_ptr

}

};

  

int main() {

std::shared_ptr<Safe> ptr1 = std::make_shared<Safe>();

std::shared_ptr<Safe> ptr2 = ptr1->getPtr(); // Получаем тот же shared_ptr

  

std::cout << "ptr1 use_count: " << ptr1.use_count() << std::endl;

std::cout << "ptr2 use_count: " << ptr2.use_count() << std::endl;

}

```

  

## квиз по enable_shared_from_this

Как правильно использовать std::enable_shared_from_this в пользовательском классе?

Формат: чекбокс

  

[X] A

Наследовать класс от std::enable_shared_from_this<Derived> и вызывать shared_from_this() только после того, как объект уже находится в std::shared_ptr.

*Пояснение*: Это корректное использование. Наследование с параметром самого класса гарантирует, что shared_from_this() будет работать правильно, если объект управляется shared_ptr.

  

[] B

Наследовать класс от std::enable_shared_from_this<Base> и вызывать shared_from_this() в конструкторе для инициализации внутренних полей.

*Пояснение*: Неверно, параметр шаблона должен быть именно производным классом, а вызов в конструкторе приведёт к неопределенному поведению, так как объект ещё не находится под управлением shared_ptr.

  

[] C

Просто объявить метод shared_from_this() в классе без наследования от std::enable_shared_from_this.

*Пояснение*: Неверно, без наследования отсутствует внутренняя поддержка механизма, и метод реализовать нельзя.

  

[] D

Использовать std::enable_shared_from_this и вызывать shared_from_this() даже если объект создан на стеке.

*Пояснение*: Неверно, вызов shared_from_this() для объекта, не управляемого shared_ptr, приводит к неопределенному поведению.

## конец квиза по enable_shared_from_this

  
  

## Заключение

  

Сегодня мы

- разобрали идею CRTP, выяснили, что рекурсивное наследование позволяет получать столь е выразительное применение интерфейсов как и виртуальное наследование.

- применяли CRTP для реализации полиморфизма времени компиляции на примере шаблонного метода и адаптера интерфейса.

- изучили применение std::enabled_shared_from_this

  

Помимо преимуществ, мы упоминали и недостатки некоторых решений на основе шаблонов, в следующих уроках будет возможность попытаться от них избавиться.