

Кейсы применения ref-qualified методов
#опытным
В нескольких предыдущих постах мы говорили про ref-qualified методы и как компилятор выбирает правильную перегрузку. Эта фича многим незнакома и сходу не очень понятно, где ее можно использовать. Давайте сегодня чуть подробнее поговорим о том, где они могут быть реально полезны, чтобы вы вдохновились и использовали такую перегрузку методов чаще.

1 Разработка библиотек. Довольно очевидно, что разработчикам всяких библиотек нужно учитывать примерно все сценарии использования их классов. Пользователи(безумные) могут скастить объект к константной правой ссылке и методы класса должны работать корректно. Тут очень важно, чтобы тип возвращаемого значения методов соответствовал типу объекта. Пример:

```cpp
template <typename T>
class optional {
  // version of value for non-const lvalues
  constexpr T& value() & {
    if (has_value()) {
      return this->m_value;
    }
    throw bad_optional_access();
  }

  // version of value for const lvalues
  constexpr T const& value() const& {
    if (has_value()) {
      return this->m_value;
    }
    throw bad_optional_access();
  }

  // version of value for non-const rvalues... are you bored yet?
  constexpr T&& value() && {
    if (has_value()) {
      return std::move(this->m_value);
    }
    throw bad_optional_access();
  }

  // you sure are by this point
  constexpr T const&& value() const&& {
    if (has_value()) {
      return std::move(this->m_value);
    }
    throw bad_optional_access();
  }
  // ...
};
```

Если объект временный, то возвращаем правую ссылку на мувнутый ресурс. Если объект lvalue, то возвращаем обычную ссылку.

2 Форсить ограничения на методы. Если у вас методы возвращают левые ссылки(константные и неконстантные), то неплохо бы их пометить `&`, чтобы эти методы могли вызываться только у именованных объектов. Ведь если получить ссылку на внутренний ресурс временного объекта, то временный объект уничтожится, а вы получите висячую ссылку. Спасибо @d7d1cd за [кейс](https://t.me/grokaemcpp/627?comment=46515))

```cpp
struct Vector {
	int & operator[](size_t index) & { // notice & after arguments
		return vec[index];
	}
	std::vector<int> vec;
};

Vector v;
v.vec = {1, 2, 3, 4};
v[1]; // ok
Vector{{1, 2, 3, 4}}[1]; // compile error
```

Также прикрепляю ссылочку на [быстрый ответ](https://isocpp.org/blog/2015/11/quick-q-const-reference-qualified-member-function) из блог стандарта С++ посвященный этому кейсу. 


3 Оптимизации. Иногда для определенных ссылочных типов мы может оптимизировать какой-то метод. Например, в С++23 ввели rvalue reference перегрузку для метода substr класса std::basic_string. Мы знаем, что метод substr формирует новую строку, копируя туда рэндж из оригинальной строки. С++23 теперь сделал так, чтобы при вызове метода substr у правых ссылок объект подстроки тырил данные у  оригинальной строки и фактически формировался из ее внутреннего буфера. Более подробно можно почитать в [пропоузале](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2438r2.html).

Также, если вы возвращаете из метода легковесный объект, то в перегрузке для rvalue ссылок вы можете возвращать объект по значению. Так вы избавляетесь от избыточной ссылочной семантики и, возможно, улучшаете перформанс. Ведь маленькие типы быстрее передавать и возвращать именно по значению:

```cpp
struct Vector {
	int operator[](size_t index) && { // notice & after arguments
		return vec[index];
	}
	std::vector<int> vec;
};
```


auto аргументы функций
#опытным 

Проследим историю с возможностью объявлять аргументы функций, как auto. 

До С++14 у нас были только шаблонные параметры в функциях и лямбда выражения, без возможности передавать в них значения разных типов

Начиная с С++14, мы можем объявлять параметры лямбда выражения auto и передавать туда значения разных типов:

```cpp
auto print = [](auto& x){std::cout << x << std::endl;};
print(42);
print(3.14);
```

Это круто повысило вариативность лямбд, предоставив им некоторые плюшки шаблонов.

У обычных функции, тем не менее, так и остались обычные шаблонные параметры.

Но! Начиная с С++20 параметры обычных функций можно также объявлять auto:

```cpp
void sum(auto a, auto b)
{
    auto result = a + b;
    std::cout << a << " + " << b << " = " << result << std::endl;
}

sum(1, 3);
sum(3.14, 42);
sum(std::string("123"), std::string("456));
// OUTPUT:
// 1 + 3 = 4
// 3.14 + 42 = 45.14
// 123 + 456 = 123456
```

Если для лямбд это было необходимым решением из-за того, что их не хотели делать шаблонными(хотя в С++20 их уже можно делать такими), то auto параметры обычных функций призваны немного упростить шаблонную логику там, где не нужно использовать непосредственно тип шаблонного параметра. Так сказать, шаблоны на чилле и расслабоне.

Осталось только добавить, что параметры auto работают по принципу выведения типов для шаблонов, а не по принципу выведения типов auto переменных.

История небольшая, но становится понятно, что С++ все больше уходит в неявную типизацию. С одной стороны это хорошо, проще писать код и не задумываться над типами. С другой стороны, чтобы этим пользоваться на высоком уровне, нужно знать всякие маленькие нюансики, которых становится все больше и больше.

Кому нравится, тот обрадуется и будет пользоваться. Кому не нравится, может писать в стиле С++03 и все будет у него прекрасно.

Remove unused details. Stay cool.

#cpp11 #cpp14 #cpp20 #template




Проблемы ref-qualified методов
#опытным 

Мы поняли, что перегрузки методов по ссылочным типам объектов могут быть полезными в разных контекстах. Они могут использовать как в совокупности для достижения универсальности в обработке объектов, или точечно для тонкой настройки-подкрутки функциональности

Но один из примеров выбивается из общей массы. Обратимся к первому куску кода из прошлого поста:

```cpp
template <typename T>
class optional {
  // version of value for non-const lvalues
  constexpr T& value() & {
    if (has_value()) {
      return this->m_value;
    }
    throw bad_optional_access();
  }

  // version of value for const lvalues
  constexpr T const& value() const& {
    if (has_value()) {
      return this->m_value;
    }
    throw bad_optional_access();
  }

  // version of value for non-const rvalues... are you bored yet?
  constexpr T&& value() && {
    if (has_value()) {
      return std::move(this->m_value);
    }
    throw bad_optional_access();
  }

  // you sure are by this point
  constexpr T const&& value() const&& {
    if (has_value()) {
      return std::move(this->m_value);
    }
    throw bad_optional_access();
  }
  // ...
};
```

Это примерно то, как метод value класса std::variant был введен в стандарт С++17.
Мягко говоря, есть ощущение, что код дублируется.  А если не считать мува, то вообще квадруплицируется. 

Это вот стандартная штука, когда функции отличаются немного и их нельзя объединить в одну.

В таких случаях обычно помогают шаблоны. А учитывая, что у нас для левых ссылок нет мува, а для правых - есть, очень сильно напрашиваются универсальные ссылки и шаблонный std::forward.

Но тут шаблон вообще никак не вписывается. Методы же не принимают даже никаких аргументов. Какой шаблонный параметр сюда вообще вписывается?

Ну вообще говоря, методы принимают неявный аргумент this....

To be continued.

Intrigue people. Stay cool.

#cppcore 


Deduction this
#опытным 

Все методы принимают неявный параметр - указатель this на текущий объект. Также мы можем вызывать методы для объектов с разной константностью/ссылочностью. И главное - компилятор знает в момент компиляции вызова метода настоящий тип объекта со всеми квалификаторами. Единственное, что отделяется нас от возможности введения шаблонности - это указательный тип this, который не инкапсулирует в себе информацию о квалификаторах объекта.

И в С++23 именно этот момент и изменили. Теперь мы можем явно указывать тип объекта, на который указывает this. И это по сути полностью заменяет cv и ref квалификацию методов. Выглядит это так:

```cpp
struct cat {
    std::string name;

    void print_name(this cat& self) {
        std::cout << name;       //invalid
        std::cout << this->name; //also invalid
        std::cout << self.name;  //all good
    }
    void print_name(this const cat& self) {
        std::cout << self.name;
    }
    void print_name(this cat&& self) {
        std::cout << self.name;
    }
    void print_name(this const cat&& self) {
        std::cout << self.name;
    }
};
```

Особенности:
- Мы явно указываем параметр this
- Явно указываем тип объекта и его квалификаторы
- Считайте, что это статические методы, внутрь которых передали объект того же класса. Синтаксис доступа в полям соотвествующий: нельзя упоминать this, нельзя неявно обращаться к членам класса, только через имя параметра.
- Поэтому нельзя такие методы объявлять статическими, ибо невозможно будет различить вызов статического и нестатического метода с одинаковым именем.


Теперь у нас есть все инструменты и мы можем сделать шаблонный this. Давайте посмотрим на обновленный метод value класса optional:

```cpp
template <typename T>
struct optional {
  // One version of value which works for everything
  template <class Self>
  constexpr auto&& value(this Self&& self) {
    if (self.has_value()) {
        return std::forward<Self>(self).m_value;
    }
    throw bad_optional_access();
  }
};
```

Вот это бэнгер! Мы деквадруплицировали код! 

Здесь мы используем шаблонный параметр Self с универсальной ссылкой. В этом случае параметр self будет в точности повторять тип объекта, на котором вызван метод. И для правильной передачи значения наружу мы используем идельную передачу и std::forward + auto&& возвращаемое значение, которое тоже будет соответствовать cv+ref типу объекта. 

Настоящая магия, причем вне хогвартса!

Имена Self и self использовать необязательно, это отсылки к питону и первом параметру методов классов self.

Можно также использовать 

Вот вам [пропоузал](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html) по этой замечательной фиче. А мы в нескольких следующих постах будем разбирать кейсы, где она может быть применима.

Simplify your life. Stay cool.

#cpp23 #template


Передача объекта в методы по значению
#опытным 

Небольшие типы данных, особенно до 8 байт длиной, быстрее передавать в методы или возвращать из методов по значению.

С помощью deducing this мы можем вызывать методы не для ссылки(под капотом которой указатель), а для значения объекта. 

Семантика будет ровно такая, как вы ожидаете. Объект скопируется внутрь метода и все операции будут происходить над копией.

Давайте посмотрим на пример:

```cpp
struct just_a_little_guy {
    int how_small;
    int uwu();
};

int main() {
    just_a_little_guy tiny_tim{42};
    return tiny_tim.uwu();
}
```

Здесь используется старая нотация с неявным this.

Посмотрим, какой код может нам выдать компилятор:

```asm
sub     rsp, 40                           
lea     rcx, QWORD PTR tiny_tim$[rsp]
mov     DWORD PTR tiny_tim$[rsp], 42     
call    int just_a_little_guy::uwu(void)  
add     rsp, 40                            
ret     0
```

Пройдемся по строчкам и посмотрим, что тут происходит:

- первая строчка аллоцирует 40 байт на стеке. 4 байта для объекта tiny_tim, 32 байта [теневого пространства](https://stackoverflow.com/questions/30190132/what-is-the-shadow-space-in-x64-assembly) для метода uwu и 4 байта паддинга.
- инструкция lea загружает адрес tiny_tim в [регистр rcx, в котором метод uwu ожидает](https://en.wikipedia.org/wiki/X86_calling_conventions) свой неявный параметр.
- mov помещает число 42 в поле объекта tiny_tim.
- вызываем функцию-метод uwu
- наконец деаллоцируем памяти и выходим из main

А теперь применим deduction this с параметром по значению и посмотрим на ассемблер:

```cpp
struct just_a_little_guy {
    int how_smol;
    int uwu(this just_a_little_guy);
};
```

Ассемблер:

```asm
mov     ecx, 42                           
jmp     static int just_a_little_guy::uwu(this just_a_little_guy)
```

Мы переместили 42 в нужный регистр и сразу же прыгнули в функцию uwu, а не вызвали ее. Поскольку мы не передаем объект в метод по ссылке, нам ничего не нужно аллоцировать на стеке. А значит и деаллоцировать ничего не нужно. Раз нам не нужно за собой подчищать, то можно просто прыгнуть в функцию и не возвращаться оттуда.

Конечно, это искусственный пример, оптимизация есть и мы можем в целом ожидать, то объекты маленьких типов можно быстрее обрабатывать с помощью deducing this.

Optimize yourself. Stay cool.

#cpp23 #optimization #compiler 



Идеально передаем данные из лямбды
#опытным 

Передавать копию захваченных данных из лямбды легко:

```cpp
auto func(std::vector<int> vec) {
	for (auto& item: vec)
		item *= 2;
	return vec;
}

std::vector vector{1, 2, 3, 4, 5};
auto double_vec = [vec = vector]() {
	// pass by copy
	return func(vec);
};
```

Перемещать захваченное лямбдой значение тоже просто:
```cpp
auto func(std::vector<int> vec) {
	for (auto& item: vec)
		item *= 2;
	return vec;
}

std::vector vector{1, 2, 3, 4, 5};
auto double_vec = [vec = vector]() {
	// pass by a value
	return func(std::move(vec));
};
```
А что если мы захоти



Deducing this и CRTP
#опытным 

У deducting this есть одна особенность. При обычном наследовании(без виртуальных функций) методы родительского класса знают про точный тип объектов наследников, которые вызывают метод:

```cpp
struct Machine {
	template <typename Self>
	void print(this Self&& self) {
		self.print_name();
	}
};

struct Car : public Machine {
	std::string name;
	void print_name() {
		std::cout << "Car\n";
	}
};

Car{}.print(); // Выведется "Car"
```

Вам ничего это не напоминает? CRTP конечно.

Этот паттерн и используется в принципе, чтобы родители имели доступ к точному типу объекта наследника:

```cpp
template <typename Derived>
struct add_postfix_increment {
    Derived operator++(int) {
        auto& self = static_cast<Derived&>(*this);

        Derived tmp(self);
        ++self;
        return tmp;
    }
};

struct some_type : add_postfix_increment<some_type> {
    // Prefix increment, which the postfix one is implemented in terms of
    some_type& operator++();
};
```

За счет шаблонного параметра Derived, который должен быть точным типом наследника, мы можем безопасно кастануть this к указателю на наследника и вызывать у него любые методы.

Но с появлением deducing this мы можем избежать рождения этого странного отпрыска наследования и шаблонов:

```cpp
struct add_postfix_increment {
    template <typename Self>
    auto operator++(this Self&& self, int) {
        auto tmp = self;
        ++self;
        return tmp;
    }
};

struct some_type : add_postfix_increment {
    // Prefix increment, which the postfix one is implemented in terms of
    some_type& operator++();
};
```

Ну вот. У нас только один шаблонный метод. Но для пользователя он ничем не отличается от обычного нешаблонного метода.

Все красиво, эстетично и не ломает голову людям, мало работающим с шаблонами.

Make things more elegant. Stay cool.

#template #cpp23


Рекурсивные лямбды. Невозможно?
#новичкам

Лямбды по сути - функциональные объекты. Можем ли мы вызвать лямбду внутри самой себя? То есть существуют ли рекурсивные лямбды?

```cpp
int main() {
	auto factorial = [&factorial](int n) {
		return n > 1 ? n * factorial(n - 1) : 1;
	};    
	return factorial(5);
}
```

Вот мы пытаемся с помощью лямбды посчитать факториал числа. В чем здесь проблема?

Фактически данный код значит, что компилятор должен сгенерировать замыкание и в поля этого замыкания поместить ссылку на само замыкание:

```cpp
class lkdlkhbahbahkl_danfaksdf_lamba
{
public:
     int operator()(int n) const
     {
          return n > 1 ? n * factorial(n - 1) : 1;
     } 
private:
     ???? factorial;
};
```

В этом случае нужно указать тип factorial, но он еще не известен. Он будет известен только после генерации замыкания. А при попытке сгенерировать замыкание... Ну вы уже знаете, что будет.

В общем влипли мы в то, что рекурсивные лямбды невозможны из-за рекурсии. 

Однако если в таком виде мы не можем писать рекурсивные лямбды, это не значит, что ни в каком другом виде мы это делать не сможем. Об этом следующий пост.

Don't close on yourself. Stay cool.

#cppcore


Рекурсивные лямбды. Хакаем систему.
#опытным 

Поговорим сегодня о способах, как вы можете сделать свои лямбды рекурсивными. Ну почти.

1 Вместо использования auto, явно приводим лямбду к std::function. Тогда компилятор будет знать точный тип функционального объекта и сможет его захватить в лямбду:

```cpp
std::function<int(int)> factorial = [&factorial](int n) -> int { 
	return (n) ? n * factorial(n-1) : 1;
};
```

Но использование std::function очень затратно по всем критериям. Компиляция ощутимо замедляется, асма намного больше становится, и std::function обычно сильно медленнее обычных функций и лямбд. А его и аллокации.

Поэтому не самый хороший пример

2 Используем С++14 generic лямбды:

```cpp
auto factorial = [](int n, auto&& factorial) {
    if (n <= 1) return n;
    return n * factorial(n - 1, factorial);
};
auto i = factorial(7, factorial);
```

Тут надо разобраться. Мы не могли захватывать лямбду в себя, потому что мы не знали ее тип. Сейчас мы тоже не знаем ее тип, но нам это и не нужно, потому что мы используем дженерик лямбду, которая под капотом превращается в замыкание с шаблонным оператором(). Благодаря cppinsides мы можем заглянуть под капот:

```cpp
class __lambda_24_20
  {
    public: 
    template<class type_parameter_0_0>
    inline /*constexpr */ auto operator()(int n, type_parameter_0_0 && factorial) const
    {
      if(n <= 1) {
        return n;
      } 
      
      return n * factorial(n - 1, factorial);
    }
    
    #ifdef INSIGHTS_USE_TEMPLATE
    template<>
    inline /*constexpr */ int operator()<__lambda_24_20 &>(int n, __lambda_24_20 & factorial) const
    {
      if(n <= 1) {
        return n;
      } 
      
      return n * factorial.operator()(n - 1, factorial);
    }
    #endif
    
  };
```

У класса есть шаблонный оператор, но это полностью завершенный тип. После объявления лямбды компилятор уже знает конкретный тип замыкания и может инстанцировать с ним шаблонный метод.

Тут не будет никакой рекурсивной инстанциации, потому что внутри оператора мы вызываем ту же самую инстанциацию.

Форма использования такой лямбды оставляет желать лучшего, потому что нам нужно постоянно передавать ее в качестве параметра. Полечить это, как всегда, можно введением дополнительного уровня индирекции. Обернем лямбду в лямбду!

```cpp
auto factorial_impl = [](int n, auto&& factorial) {
    if (n <= 1) return n;
    return n * factorial(n - 1, factorial);
};
auto factorial = [&](int n) { return factorial_impl(n, factorial_impl); };
auto i = factorial(7);
```

Теперь не нужно передавать доп параметры.

3 Если лямбда ничего не захватывает, то ее можно приводить к указателю на функцию. На этом основан следующий метод:

```cpp
using factorial_t = int(*)(int);
static factorial_t factorial = [](int n) {
    if (n <= 1) return n;
    return n * factorial(n - 1);
};
auto i = factorial(7);
```

Статическая локальная переменная видна внутри лямбды, поэтому такой трюк прокатывает.

Если у вас есть какие-то еще подобные приемы - пишите в комменты.

Но это все какие-то обходные пути. Хочется по-настоящему рекурсивные лямбды.

И их есть у меня!

Об этом в следующий раз.

Always find a way out. Stay cool.

#template #cppcore #cpp11 #cpp14



Рекурсивные лямбды. Идеал.
#опытным 

Все предыдущие примеры были воркэраундами вокруг неспособности лямбды обращаться к самой себе. Какие-то из них имеют ограничения в использовании, какие-то - накладные расходы.

Но по-настоящему рекурсивные лямбды появились только в С++23 с введением deducing this.

Если лямбда - это класс с методом operator(), значит мы внутрь этого метода можем передать явный this и тогда лямбда сможет вызвать сама себя!

```cpp
auto factorial = [](this auto&& self, int n) {
    if (n <= 1) return n;
    return n * self(n - 1, self);
};
```

У нас конечно в С++20 есть шаблонные лямбды, но здесь это немножко оверкилл. Поэтому используем автоматический вывод типа с помощью auto aka дженерик лямбду.

У нас была цель, мы к ней шли и, наконец, пришли.

Однако как будто бы слишком много разговоров о сущности, которой пользовались полтора дровосека.

Да, рекурсивные лямбды - это скорее экзотика. Но и у них есть свои юзкейсы. Поговорим о них в следующем посте.

Find true yourself. Stay cool.

#cppcore #cpp23


Рекурсивные лямбды. Кейсы
#опытным 

Сегодня разберем пару кейсов, в которых можно использовать рекурсивные лямбды.

1 Начнем с очевидного. Где рекурсия, там всегда ошиваются какие-то древовидные структуры. Рекурсивные лямбды могут помочь сделать простые и не очень DFS обходы деревьев.

Можно обходить literaly деревья:

```cpp
struct Leaf { };
struct Node;
using Tree = std::variant<Leaf, Node*>;
struct Node {
	Tree left;
	Tree right;
};

template<typename ... Lambdas>
struct Visitor : Lambdas...
{
	Visitor(Lambdas... lambdas) : Lambdas(std::forward<Lambdas>(lambdas))...
	{}
	using Lambdas::operator()...;
};

int main()
{
	Leaf l1;
	Leaf l2;
	Node nd{l1, l2};
	Tree tree = &nd;
	int num_leaves = std::visit(Visitor(
			[](Leaf const&) { return 1; },
			[](this const auto& self, Node* n) -> int {
				return std::visit(self, n->left) + std::visit(self, n->right);
			}
		), tree);
}
```

Наше дерево хранит вариант ноды и листа. И мы можем с помощью [паттерна overload](https://t.me/grokaemcpp/578) обойти все веточки и посчитать листочки. 

У вас может возникнуть вопрос: а как мы рекурсивно проходим все варианты лямбдой, которой предназначена только для нод?

Все дело в магии явного this. [Здесь](https://t.me/grokaemcpp/659) мы с вами говорили, что при наследовании и вызове метода базового класса this вывыводится в тип класса наследника. А наш визитор как раз является наследником лямбды, которая обходит ноды дерева. Таким образом мы рекурсивно используем весь визитор.

Можно таким же образом попробовать обходить какие-нибудь джейсоны и другие подобные структуры.

2 С помощью рекурсивных лямбд можно обходить compile-time структруры, типа туплов(даже вложенных):

```cpp
auto printTuple = [](const auto& tuple) constexpr {
	auto impl = []<size_t idx>(this const auto& self, const auto& t) constexpr {
		if constexpr (idx < std::tuple_size_v<std::decay_t<decltype(t)>>) {
			std::cout << std::get<idx>(t) << " ";
			self.template operator()<idx+1>(t); // Рекурсивный вызов
		}
	};
	impl.template operator()<0>(tuple);
};

std::tuple<int, double, std::string> tp{1, 2.0, "qwe"};
printTuple(tp);

// Output:
// 1 2 qwe
```

Тут нам придется использовать шаблонные лямбды с индексом текущего элемента тупла в качества шаблонного параметра. Обратите внимание, как вызываются лямбды в данном случае. Так как у нас шаблонный оператор(), то компилятору надо явно сказать, что мы вызываем шаблон и также явно передать в него шаблонный параметр. Подобные лямбды с явным вызовом шаблонного оператора() желательно оборачивать в еще одну лямбду, чтобы коллеги случайно кофеем не подавились, увидев эту кракозябру.


3 Обход вложенных директорий с помощью std::filesystem:

```cpp
auto listFiles = [](const std::filesystem::path& dir) {
    std::vector<std::string> files;
    auto traverse = [&](this const auto& self, const auto& path) {
        for (const auto& entry : std::filesystem::directory_iterator(path)) {
            if (entry.is_directory()) {
                self(entry.path());
            } else {
                files.push_back(entry.path().string());
            }
        }
    };
    traverse(dir);
    return files;
};
```

Ну тут вроде без пояснений все плюс-минус понятно.

Вообще, в любом месте, где применима небольшая по объему кода рекурсия, вы можете использовать рекурсивные лямбды.

Пишите в комменты, если в вас есть что добавить по юзкейсам. Если кто использует какие-то генеративные алгоритмы, для реализации которых подойдет рекурсивная лямбда, тоже пишите. В общем, пишите любые мысли по теме)

Be useful. Stay cool.

#cppcore #cpp23 #template


Mutable lambda
#опытным 

Лямбда выражения имеют одну интересную особенность. И эта особенность аффектит то, что можно делать внутри лямбды.

Простой пример:
```cpp
int val = 0;
auto lambda1 = [&val]() { std::cout << ++val << std::endl; };
auto lambda2 = [val]() { std::cout << ++val << std::endl;  }; 
```

Определяем 2 лямбды: в одну захватываем `val` по ссылке, во второй - по значению.

В чем здесь проблема?

А в том, что во втором случае мы получим ошибку компиляции.

На самом деле  operator() у замыкания по умолчанию помечен как const метод, видимо чтобы его можно было вызывать на константных объектах замыкания. То есть это значит, что мы не можем изменять поля замыкания при вызове лямбды. 

Ссылки интересным образом это ограничение обходят. Так как ссылки сами по себе неизменяемы(так как по факту это обертка над константным указателем), то формально требования выполняются. А то, что мы используем изменяем объект, на который указывает ссылка,  это "другое". 

Под одним из прошлых постов разгорелась дискуссия по этому моменту. @KpacHoe_ympo [в этом комменте](https://t.me/c/2009887601/49027) упомянул, что в константных методах можно менять объекты, на которые ссылаются ссылки. Однако на мой вгляд(и подтверждений в стандарте я не нашел), что это не уб. Иначе в лямбду нельзя было бы захватывать ссылки вообще. Вряд ли весь захват по ссылке в лямбду держится на уб.

А вот объекты, захваченные по значению, не умеют обходить ограничения константности. В замыкании они превращаются в обычные поля класса, которые нельзя изменять внутри константных методов.

Но если нам очень нужно изменять захваченные по значению поля? На помощь приходит уже полюбившийся нам mutable. Лямбду можно пометить этим ключевым словом и тогда ее константный оператор() перестанет быть константным! Тогда мы можем как угодно изменять любые захваченные значения:

```cpp
int val = 0;
auto lambda2 = [val]() mutable { std::cout << ++val << std::endl;  }; 
```

Теперь все работает отлично.

То есть **в лямбда выражениях mutable используется в случаях, когда необходима модификация объектов, захваченных по значению.**

Это может использоваться, например, для перемещения захваченных объектов в one-shot коллбэках:

```cpp
auto callback = [message=get_message(), &scheduler]() mutable {
	// some preparetions 
	scheduler.submit(std::move(message));
};
SomeTask task{callback};
task.run();
```

По завершению таски, коллюэк кладет в шедулер мувнутое сообщения без накладных расходов на копирование.

Мутабельные лямбды - не такая популярная фича, еще менее известная, чем обычный mutable, но о их существовании нужно знать.

Break the rules. Stay cool.

#cppcore


std::forward_like
#опытным 

Сегодня рассмотрим функцию-хэлпер, которая поможет нам в рассмотрении одного из юзкейсов применимости deduction this. Их одновременное введение в стандарт логично, хэлпер дополняет и расширяет применимость deduction this.

Эта функция очень похожа на std::move и, особенно, на std::forward. Она потенциально аффектит только категорию выражения и может добавлять константности.

Если std::forward  объявлена так

```cpp
template< class T >  
constexpr T&& forward(std::remove_reference_t<T>& t ) noexcept;

template< class T >  
constexpr T&& forward(std::remove_reference_t<T>&& t ) noexcept;
```

За счет перегрузок для lvalue и rvalue, она правильно передавать тип параметра, объявленного универсальной ссылок, во внутренние вызовы. Здесь задействован всего один шаблонный параметр.

std::forward_like делает шаг вперед. Функция позволяет выполнять идеальную передачу данных на основе типа другого выражения.

```cpp
template< class T, class U >  
constexpr auto&& forward_like( U&& x ) noexcept;
```

Заметьте, что здесь 2 шаблонных параметра. Мы будем кастить x к ссылочному типу параметра Т.

Зачем вообще так делать?

Без deduction this особо незачем. Но вместе с ним мы можем на основе типа объекта, на котором вызывается метод, идеально передавать данные наружу.

Раньше это было возможно только если бы мы возвращали мемберы объекта. На С++20 это выглядело так:

```cpp
return forward<decltype(obj)>(obj).member;
```

Это работало с кучей ограничений. Но с появлением deducing this мы можем делать так:

```cpp
struct adapter {
  std::deque<std::string> container;
  auto operator[](this auto&& self, size_t i) -> std::string {
    return std::forward_like<decltype(self)>(container[i]);

} };
```

Мы можем из оператора индексации вернуть правую ссылку на строку внутри container, если мы вызываем оператор на правоссылочном объекте.  Также тут используем auto параметр для выведения типа объекта.

Follow the head. Stay cool.

#cpp23 #template


Идеальная передача из лямбды
#опытным 

Мутабельные лямбды позволили нам перемещать захваченные по значению объекты в сторонние функции:

```cpp
auto callback = [message=get_message(), &scheduler]() mutable {
	// some preparetions 
	scheduler.submit(std::move(message));
}
```

Ну и передача копии вообще никогда не была проблемой:

```cpp
auto callback = [message=get_message(), &scheduler]() {
	// some preparetions 
	scheduler.submit(message);
}
```

Однако подобную функцию можно использовать в двух контекстах: с возможностью повторного выполнения и одноразового исполнения:

```cpp
callback(); // retry(callback)
std::move(callback)(); // try-or-fail(rvalue)
```

Так вот что, если мы хотим в первом случае сабмитить в шедулер копию сообщения, чтобы иметь возможность повторить вызов, а во втором случае - мувнуть сообщение в шедулер. То есть хотелось бы на основании типа ссылочности объекта подстраивать тип поля класса и передавать поле во внутренние вызовы.

Это все можно делать с помощью явного this и std::forward_like:

```cpp
auto callback = [message=get_message(), &scheduler](this auto &&self) {
    return scheduler.submit(std::forward_like<decltype(self)>(message));
};
```

Пара интересных наблюдений:

- Если c std::forward мы могли идеально передать лишь объект замыкания, то с использованием std::forward_like мы можем кастить любой объект к точно такому же ссылочному типу, как и у объекта замыкания. Это позволяет мувать сообщение внутрь шедулера при использовании try-or-fail подхода вызова лямбды.

- Можно заметить, что лямбда не мутабельная, хотя в ней возможно изменение объекта message. Это потому что при использовании явного this оператор() у замыкания по умолчанию мутабельный. Таков ~~закон~~ стандарт.

Из адекватных примеров явного this на этом все.

Deducting this - одна из мажорных фичей 23-го стандарта. Рано или поздно все на него перейдут и нужно заранее знать кейсы, где фичу можно использовать, чтобы писать более понятный и оптимальный код.

Be a major figure. Stay cool.

#template #cpp23
