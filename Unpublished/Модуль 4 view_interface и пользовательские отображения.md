ОР:
- применяет вспомогательный класс view_interface с CRTP для реализации отображений

Структура:
- мы хотим написать собственное отображение, совместимое со всей библиотекой ranges.
- возвращаемся к концепту отображения и есть несколько способов реализовать собственное отображение Например, можно наследоваться от view_base, явно выставить ranges::enable_view для нашего класса в true. Эти способы несовершенны, так как требуют написания большого количества бойлерплейта.
- есть вариант получше - отнаследоваться от view_interface, как CRTP.
- разбираем по шагам как написать свое отображение на примере cycle_view, который циклически выдает объекты из входного диапазона.

Введение

До сих пор мы использовали готовые отображения из стандарта языка и из библиотеки ranges-v3. Но сегодня это изменится. Вы узнаете:

- какой базис выбрать для реализации своего собственного отображения.
- как правильно наследоваться от view_interface, чтобы избежать написания бойлерплейт кода.
- какие ключевые компоненты нужно реализовать, чтобы получить свое отображение.

Контент

## Кастомное отображение

Стандартная библиотека хоть и содержит много всего полезного, однако постоянно случаются ситуации, когда в ней нет подходящего инструмента.

Например, вы пишете нагрузочный тест.  Чтобы провести нагрузочный тест, нужно определить несколько типовых запросов, чтобы сэмулировать боевую работу модуля, и нагружать модуль большим количеством запросов из этой выборки. Самое простое в этой ситуации - циклически повторять элементы выборки при выборе очередного запроса. Выглядеть это может примерно так:

```cpp
auto test_data = generate_test_samples() | std::views::cycle;
for (const auto& sample: test_data | std::take(100500)) {
	some_module.process(test_data);
}
```

Но вот беда. std::views::cycle не существует в стандарте.

Так давайте сами напишем это отображение!

## Концепт отображения

Давайте вернемся к истокам, а именно к концепту отображения и вспомним, что из себя представляет отображение с точки зрения стандарта:

```cpp
template<class T>  
concept view = std::ranges::range<T> && std::movable<T> && std::ranges::enable_view<T>;

template<class T>  
constexpr bool enable_view = std::derived_from<T, std::view_base> || /*is-derived-from-view-interface*/<T>;

struct view_base { };
```

Отображение - это диапазон(то есть начало и ограничитель), который можно перемещать и для которого std::ranges::enable_view возвращает true. std::ranges::enable_view возвращает true либо для наследников пустого класса view_base, либо для явных специализаций(std::string_view, std::span), либо для особенных наследников view_interface. И если мы хотим написать свое отображение, то нам нужно выбрать одну из трех опций.

## Составные части отображения

Что нам вообще нужно концептуально, чтобы определить свое отображение? Нам нужно задать определить методы begin() и end() + возможно свой итератор, чтобы понимать, как двигаться от одного элемента к другому. И эти сущности для любых отображений разные. Однако это еще не все. Нужно еще написать кучу boilerplate кода (Всплывашка: от англ. "boilerplate" — шаблонный, стандартный — это повторяющийся, шаблонный код, который приходится писать вручную для выполнения стандартных задач, но который не несёт уникальной логики программы). Например:

- методы empty(), front() и оператор приведения к bool, если категория итератора отображения  forward_iterator.
- метод data, если категория - contiguous_iterator.
- метод size, если категория - forward_iterator или sized_sentinel.
- метод back(), если bidirectional_iterator.
- и тд.
Это очень простые в реализации методы, но для каждой категории итераторов отображения набор методов, которые нужно реализовать, свой.

Если же мы отнаследует наше отображение от view_base, или явно специализируем std::ranges::enable_view для него, то нам придется весь этот код писать своими руками. Но есть один способ, как можно избежать написания по крайней мере части этого кода.

## view_interface

Можно наследоваться от view_interface, который предоставляет за нас реализацию части вышеуказанных методов. Как вы думаете, как устроен view_interface и каким образом надо от него наследоваться?

*Кнопка* Хм, интересный вопрос...

Если во view_interface будут виртуальные методы, то будут накладные расходы в рантайме на поддержание виртуального полиморфизма.

Если view_interface будет просто классом, то никакого полиморфизма не будет и поведение кода невозможно будет подстроить под наследника. 

Остается один вариант - CRTP(Всплывашка: Curiously recurring template pattern). view_interface является базой CRTP, шаблонно-параметризованный своим наследником:

```cpp
template<class Derived>  
class view_interface;

class my_view: public std::ranges::view_interface<my_view>
```

За счет того, что view_interface на этапе компиляции уже знает, кто будет его наследником, он может вызывать методы наследника и предоставлять публичный интерфейс, в котором будут использоваться методы и поля наследника. Это и позволяет view_interface предоставлять часть описанного выше бойлерплейт интерфейса.

Все. Мы обсудили самые важные составные части и готовы в реализации своего отображения views::cycle.

## Реализация views::cycle

```cpp
namespace my_views {

// шаблонный параметр V определяет тип view, на основе которого cycle_view будет генерировать элементы
template <std::ranges::view V>
// CRTP наследование от view_interface
class cycle_view: public std::ranges::view_interface<cycle_view<V>> {
private:
	V base_; // это 
public:
	cycle_view() = default;

	constexpr explicit cycle_view(V base)
		: base_(std::move(base)) {}
	
	// Итератор для cycle_view
	class iterator {
	// ...
	// рассмотрим позже
	};

	// метод begin возвращает итератор на первый элемент исходного отображения, ограниченного своими begin и end
	constexpr auto begin() {
		return iterator(std::ranges::begin(base_), std::ranges::begin(base_), std::ranges::end(base_));
	}
	// метод end возвращает ограничитель, который говорит о том, что последовательность бесконечная
	constexpr auto end() const {
		return std::unreachable_sentinel;
	}
};

} // namespace my_views
```


Как мы и говорили, кастомное отображение - это по сути структура с определенными методами begin и end, которая отнаследована от view_interface как CRTP. Аргумент конструктора base должен удовлетворять концепту std::ranges::view, чтобы мы могли хранить легковесную "ссылку" на исходный диапазон. Помимо begin и end в классе нужно определить итератор:

```cpp
class iterator {
	using Base = std::ranges::iterator_t<V>;
	using Sentinel = std::ranges::sentinel_t<V>;
	Base current_{};
	Base begin_{};
	Sentinel end_{};

public:

	// необходимые для всех итераторов зависимые типы
	using iterator_category = std::bidirectional_tag;
	using value_type = std::ranges::range_value_t<V>;
	using difference_type = std::ranges::range_difference_t<V>;
	
	iterator() = default;
	// конструктор, с помощью которого специфициется текущий элемент, начало и конец исходного диапазона
	constexpr iterator(Base current, Base begin, Sentinel end)
		: current_(current)
		, begin_(begin)
		, end_(end) {}
	
	// дальше идут методы, которые нужны всем итераторам

	// оператор разыменования
	constexpr auto operator*() const -> std::ranges::range_reference_t<V> {
		return *current_;
	}

	// оператор префиксного инкремента
	constexpr iterator& operator++() {
		if (++current_ == end_) {
			current_ = begin_;
		}
		return *this;
	}

	// оператор постфиксного инкремента
	constexpr iterator operator++(int) {
		auto tmp = *this;
		++*this;
		return tmp;
	}
	
	// операторы декремента нужны поддержания требований bidirectional итератора, так как мы можем вперед и назад по последовательности ходить. Для этого мы также требуем, чтобы V был bidirectional диапазоном, чтобы мы могли декрементировать нижележащий итератор
	
	constexpr iterator& operator--() requires std::ranges::bidirectional_range<V>	{
		if (current_ == begin_) {
			current_ = end_;
		}
		--current_;
		return *this;
	}
	
	constexpr iterator operator--(int) requires std::ranges::bidirectional_range<V>	{
		auto tmp = *this;
		// реализуем постфиксный декремент с помощью префиксного
		--*this;
		return tmp;
	}

	// операторы сравнения
	constexpr bool operator==(const iterator& other) const {
		return current_ == other.current_;
	}
	constexpr bool operator==(std::default_sentinel_t) const {
		return false;
	}

};
```

При создании итератора мы задаем первый элемент исходной последовательности, а также ее границы - итератор начала и ограничитель. После этого определяем все необходимые операторы, которые говорят, как двигаться по нашей циклической последовательности. Базово это операторы инкремента и сравнения. Если нам передали отображение, по которому мы можем ходить вперед и назад, то в этом случае мы определяем операторы декремента, чтобы иметь возможность циклически двигаться в обоих направлениях.

И нам остался еще один элемент пазла. Чтобы писать такой, привычный для отображений, код:

```cpp
std::vector vec = {1, 2, 3};
auto cycle_vec = vec | views::cycle
```

нам нужен адаптер, который бы обогащал cycle_view возможностью быть использованым в pipe-синтаксисе:

```cpp
  
namespace my_views {

// Адаптер для создания cycle_view
struct CycleAdapter : public std::ranges::range_adaptor_closure<CycleAdapter> // Наследование!
{
	// требуем, чтобы из входного диапазона можно было сконструировать отображение
	template <std::ranges::viewable_range R>
	constexpr auto operator()(R&& r) const {
		// берем ссылочное отображение от входного диапазона и создаем объект cycle_view
		return cycle_view(std::views::all(std::forward<R>(r)));
	}
};

// определяем переменную-helper для удобного использования адаптера
inline constexpr auto cycle = CycleAdapter{};

} // namespace my_views
```

Для этого нам достаточно отнаследовать CycleAdapter, как CRTP, от std::ranges::range_adaptor_closure и определить в нем operator() от одного диапазона. В этом случае range_adaptor_closure предоставит нашему адаптеру готовую реализацию operator|.

Также мы определяем переменную cycle для удобного использования адаптера.

У нас готовы все составные части. Полный код со сценариями использования можете посмотреть [здесь](https://godbolt.org/z/nfW6nY6ja).

Ура! Мы с вами только что написали собственное отображение!

## Заключение

Сегодня вы узнали:

- Если писать свое отображение с нуля или наследоваться от view_base, то придется писать много boilerplate кода.
- Базовый класс view_interface предоставляет реализации некоторых стандартных методов, что избавляется пользователя от их самостоятельной реализации.
- Чтобы view_interface корректно предоставлял свою функциональность, от него нужно наследоваться, как CRTP.
- Для реализации собственного отображения нужно определить методы begin и end, итератор и его методы, а также адаптер для более удобной работы.