
Порядок вызовов конструкторов и декструкторов дочерних классов

Сегодня такой, довольно попсовый пост. Но, как говорится, это база и это нужно знать.

Вот есть у вас какая-то иерархия классов.

```cpp
struct Base1 {
	Base1() {std::cout << "Base1" << std::endl;}
	~Base1() {std::cout << "~Base1" << std::endl;}
};

struct Derived1 : Base1 {
	Derived1() {std::cout << "Derived1" << std::endl;}
	~Derived1() {std::cout << "~Derived1" << std::endl;}
};

struct Base2 {
	Base2() {std::cout << "Base2" << std::endl;}
	~Base2() {std::cout << "~Base2" << std::endl;}
};

struct Derived2 : Base2 {
	Derived2() {std::cout << "Derived2" << std::endl;}
	~Derived2() {std::cout << "~Derived2" << std::endl;}
};

struct MostDerived: Derived2, Derived1 {
	MostDerived() {std::cout << "MostDerived" << std::endl;}
	~MostDerived() {std::cout << "~MostDerived" << std::endl;}
};

MostDerived{};
```

Что мы увидим в консоли, если запустим этот код? Вот это:

```
Base2
Derived2
Base1
Derived1
MostDerived
~MostDerived
~Derived1
~Base1
~Derived2
~Base2
```

Мы имеем 2 невиртуальные ветки наследования в класса MostDerived. В самих классах могут быть виртуальные функции, это роли не играет. В этом случае правила конструирования объекта такое: переходим в самую левую ветку и вызываем поочереди констукторы базовых классов сверху вниз. Как только дошли до MostDerived, переходим в следующую ветку и также вызываем конструкторы сверху вниз. И только после этого конструируем MostDerived.

В общем случае, для n веток, можно представить, что наш наследник - корень дерева с n ветками. Так вот для такого графа констукторы вызываются, как при обходе в глубину слева-направо.

А вот деструкторами все легко, если вы запомнили порядок вызовов конструкторов. Деструкторы выполняются в обратном порядке вызовов конструкторов соответствующих классов. Вы можете заметить, что вывод консоли из примера полностью симметричен относительно момента, когда объект уже создан. 

Казалось бы, тривиальное знание для программиста. Но очень важно осознавать эти вещи для того, чтобы понять более сложные концепции или отвечать на более сложные вопросы. Например: "Зачем нужен виртуальный деструктор?", "В какой момент инициализируется указатель на виртуальную таблицу?", "Какой конкретно метод вызовется, если позвать виртуальный метод из констуруктора базового класса?". Без четкого понимания базы создания объектов, на эти вопросы конечно можно заучить ответы, но понимания никакого не будет. А программирование - это только про понимание, как и любая другая техническая дисциплина.

Поэтому

Understand essence of basic concepts. Stay cool.

#OOP #cppcore 





Шаблонный сеттер

Увидел на ревью интересный кейс. Мы о нем уже говорили, что не сильно акцентировали внимание. Сегодня больше времени уделим одному интересному явлению.

Если у вас есть какой-то шаблонный класс, который хранит тип Т, и в этом классе есть сеттер на этот тип, то по давней привычке(еще с 98 стандарта) его можно написать вот так:

```cpp
template <class T>
struct TemplateClass {
	void SetValue(const T& value) {
		value_ = value;
	}
private:
	T value_;
};
```

Привычка - дело хорошее и экономит ресурс мозга на выполнение действий. Не так много когнитивного внимания нужно тратить на деятельность. 

Но иногда привычки ограничивают нас. Мы-то уже в modern C++ эре. И в данном случае как раз такой кейс.

Что будет, если мы захотим передать в этот метод временный объект? Например так:

```cpp
struct ShowConstruct {
	ShowConstruct() = default;
	ShowConstruct(int value) : field{value} {
		std::cout << "Param construct " << field << std::endl;}
	ShowConstruct& operator=(const ShowConstruct& other) {
		field = other.field;
		std::cout << "Copy assign " << field << std::endl;
		return *this;}
	ShowConstruct& operator=(ShowConstruct&& other) {
		field = other.field;
		std::cout << "Move assign " << field << std::endl;
		return *this;}
	int field = 0;
};

TemplateClass<ShowConstruct> obj;
obj.SetValue(ShowConstruct{5});
```

На экран выведется:

```
Param construct 5
Copy assign 5
```

Это значит, что даже если мы передаем в такой сеттер временный объект, у которого можно забрать его ресурсы и сэкономить на копировании, мы все равно не получаем этих бенефитов.

Потому что в сеттере value уже относится к категории lvalue. А при присваивании объекта от lvalue будет вызываться копирующий оператор присваивания. 

А нам бы хотелось, чтобы вызывался перемещающий оператор. Как этого достичь?

Использовать универсальную ссылку. Скажет прошаренный читатель.

Для шаблонного кода мы можем пометить параметр метода двумя амперсандами и дальше внутри передавать его во все места через std::forward. Таким образом, если нам на вход пришел именованный объект, то std::forward скастует его к lvalue ссылке, а если временный, то к rvalue ссылке. И это поможет нам в нужных случая вызывать правильный оператор присваивания. И std::forward и universal reference доступны с 11-го стандарта вместе с введением мув-семантики.

```cpp
template <class T>
struct TemplateClass {
	void SetValue(T&& value) {
		value_ = std::forward<T>(value);
	}
private:
	T value_;
};

TemplateClass<ShowConstruct> obj;
obj.SetValue(ShowConstruct{5});
```

Теперь мы получаем нужный вывод:

```
Param construct 5
Move assign 5
```

Однако этот прошаренный читатель оказался не таким уж и прошаренным! Такая штука не сработает для шаблонных параметров класса!

```
in class template argument deduction, template parameter of a class template is never a forwarding reference
```

Универсальная ссылка(она же forwarding reference) появляется только, когда тип выводимого параметра T&&. В нашем случае нет никакого вывода - тип Т известен из класса. Поэтому и никакой универсальной ссылки не появляется.

Мы просто определили метод, который принимает rvalue ссылку. При попытке передать туда lvalue будет ошибка:

```cpp
TemplateClass<ShowConstruct> obj;
ShowConstruct lvalue{7};
obj.SetValue(lvalue);

//ERROR: rvalue reference to type 'ShowConstruct' cannot bind to lvalue of type 'ShowConstruct'
```

Какой выход? Просто рядышком с сеттером для константной lvalue ссылки написать сеттер для rvalue ссылки.

```cpp
template <class T>
struct TemplateClass {
	void SetValue(const T& value) {
		value_ = value;
	}
	void SetValue(T&& value) {
		value_ = std::move(value);
	}
private:
	T value_;
};

TemplateClass<ShowConstruct> obj;
obj.SetValue(ShowConstruct{5});
ShowConstruct lvalue{7};
obj.SetValue(lvalue);
```

Тогда все нормально скомпилируется и в нужных места будут вызваны нужные операторы.

Stay universal. Stay cool.

#cpp11 


Swap idiom

Рассуждения в комментах под предыдущим постом навели меня на мысли рассказать о swap idiom. 

Дело в том, что, когда у вас есть рабочие деструктор, конструктор копирования и перемещения, вы можете соединять методы, которые должны принимать константную lvalue ссылку и rvalue ссылку, в один метод, который принимает параметр по значению. То есть можно вместо 2-х методов сеттеров можно написать 1:

```cpp
template <class T>
struct TemplateClass {
	void SetValue(T value) {
		value_ = std::move(value);
	}
private:
	T value_;
};
```

Этой же концепцией вдохновлено появление swap идиомы. На самом деле я немного вру, но с появлением мув-семантики она пришла в этому.

Суть в чем. Есть у вас класс, который мэнэджит какие-то ресурсы. Например самописный класс массива:
```cpp
class SimpleArray
{
public:
    SimpleArray(std::size_t size = 0)
        : mSize(size),
          mArray(mSize ? new int[mSize]() : nullptr) {}

    SimpleArray(const SimpleArray& other)
        : mSize(other.mSize),
          mArray(mSize ? new int[mSize] : nullptr) {
        std::copy(other.mArray, other.mArray + mSize, mArray);
    }
	SimpleArray(simple_array&& other) noexcept
        : mSize(other.mSize),
          mArray(other.mArray) {}

    ~SimpleArray()
    {
        delete [] mArray;
    }

private:
    std::size_t mSize;
    int* mArray;
};
```

Все хорошо, но для выполнения правила 5 нам нужно определить еще и 2 оператора присваивания: перемещающий и копирующий. Обычно в них в начале очищают существующий объект и потом записываются новые данные. Покажу на примере конструктора копирования:

```cpp
SimpleArray& operator=(const SimpleArray& other) {
    if (this != &other) {
        delete [] mArray;
        mArray = nullptr;
        mSize = 0;

        mSize = other.mSize;
        mArray = mSize ? new int[mSize] : nullptr;
        std::copy(other.mArray, other.mArray + mSize, mArray);
    }
    return *this;
}
```

В такой реализации есть 3 проблемы:

1 Нам просто необходима проверка на самоприсвоение, чтобы в объекте остались те же данные. Но это настолько редкий кейс, что каждый раз при присвоении тратить время на проверку не очень хочется. А хочется операторы без этой проверки.

2 У нас есть только базовая гарантия исключений. Если из new бросится исключение, то состояние изменяемого объекта хоть и останется согласованным, но оно все равно изменится. А операция не завершится до конца. Хотелось бы строгой гарантии безопасности исключений.

3 Мы повторяем код. Помимо проверки самоприсваивания и очищения ресурсов тупо повторяется код копирующего конструктора. Хочется этого не делать.

Чтобы решить эти проблемы, мы можем сделать интересную штуку - принимать параметр оператора присваивания на обычное значение. Тогда на входе оператора у нас уже будет готовый скопированный(или перемещенный объект) и нам нужно будет лишь поменять содержимое этих двух объектов местами. И нам не нужно беспокоиться о том, что останется в параметре функции - он все равно удалится после выхода из нее. Теперь оператор будет выглядеть так:

```cpp
SimpleArray& operator=(SimpleArray other) noexcept {
	swap(*this, other);
	return *this;
}
```

Как же красиво! Нам осталось только реализовать функцию swap. Она может быть и методом класса, но почему бы еще не иметь просто фукцию, которая свапает контент. Поэтому покажу реализацию дружественной функции.

```cpp
friend void swap(SimpleArray& first, SimpleArray& second) noexcept {
	using std::swap;
	swap(first.mSize, second.mSize);
	swap(first.mArray, second.mArray);
}
```

Выглядит кратко, читаемо, да еще и исключений нет(об этом даже явно в коде можно сказать)! Ляпота.

Теперь оператор присваивания может принимать сразу и левые ссылки, и правые ссылки. На их основе он создает временный объект своего параметра, который удалится после выхода из скоупа. Сколько кода мы сэкономили! Да еще и гарантию безопасности усилили.

Однако у идиомы есть и слабые места, о которых расскажу позже.

Stay laconic. Stay cool.

#patter #cppcore #cpp11 




Swap idiom. Pros and cons
#опытным

В [этом посте](https://t.me/grokaemcpp/336) поговорили про суть swap идиомы. Сегодня обсудим ее плюсы и минусы.

Плюсы вроде как обсуждали, но я финализирую, когда можно рассмотреть внедрение swap idiom:

1 Если у вас конструктор копирования может бросить исключение и вы можете написать небросающую функцию swap. Тогда за счет того, что захват ресурсов(копирование или перемещение во временный объект параметра функции) происходит до модификации текущего объекта, то мы получаем строгую гарантию безопасности исключений при работе с присваиванием объектов.

2 Если вы хотите красивый, лаконичный и понятный код без повторений действий. 

3 Вы не очень беспокоитесь о потенциальных потерях производительности.

Погнали по минусам:

1 Не всегда можно написать nothrowing swap. Для базовых типов и указателей - да. Но swap нетривиальных типов использует временный объект. При создании которого и может возникнуть исключение. Сейчас swap делается с помощью перемещающих операций, но например в С++03 std::string мог кинуть исключение в копирующем конструкторе. Да и сейчас поля класса могут быть немувабельными и бросающими при копировании. Это надо иметь ввиду.

2 Каждый раз при присваивании мы выполняем 2 операции: конструктор копирования + swap или конструктор перемещения + swap. "Потери производительности" надо конечно тестить и смотреть реальные результаты, но в голове все равно надо держать потенциальные просадки.

3 Самостоятельно писать деструктор для менеджинга ресурсов в 2к24 - такая себе практика **в большинстве случаев.** Давно есть std::unique_ptr<T[]>, указатели с кастомными делитерами и прочие вещи. Одно из ключевых преимуществ идиомы - сокращение и переиспользование кода. Так вот с отсутствием деструктора вам вообще может не понадобится кастомное присваивание и вы сможете объявить операции дефолтными, поэтому надобность в идиоме сама по себе отпадет. 

4 Часто пропускаемый огромный минус: технически у нас есть оператор перемещения, который может принимать rvalue ссылки. Однако мы явным образом не реальзовывали присваивание перемещением, поэтому по правилу 5, компилятор не будет его генерировать за нас и у класса просто будет отсутствовать этот специальный метод. 
И хоть текущий класс мы можем мэнэджить без присваивания перемещением, то ситуация изменится, когда мы сделаем текущий класс полем другого. Тогда у этого другого класса не будет генерироваться дефолтный оператор присваивания перемещением! Для его генерации все поля должны иметь такие операторы. А в нашем классе его нет.
Это значит, что по дефолту будет использоваться копирующее присваивания и все остальные поля нового класса будут копироваться. А вы об этом даже не знали! И получили жесткую просадку и, потенциально, некорректную логику.

```cpp
struct FirstField {
	FirstField() = default;
	FirstField(const FirstField& other) {
		std::cout << "FirstField Copy ctor" << std::endl;
	}
	FirstField& operator=(FirstField other) {
		std::cout << "FirstField assign" << std::endl;
		return *this;
	}
	FirstField(FirstField&& other) {
		std::cout << "FirstField Move ctor" << std::endl;
	}
};

struct SecondField {
	SecondField() = default;
	SecondField(const SecondField& other) {
		std::cout << "SecondField Copy ctor" << std::endl;
	}
	SecondField& operator=(const SecondField& other) {
		std::cout << "SecondField Copy assign" << std::endl;
		return *this;
	}
	SecondField(SecondField&& other) {
		std::cout << "SecondField Move ctor" << std::endl;
	}
	SecondField& operator=(SecondField&& other) {
		std::cout << "SecondField Copy assign" << std::endl;
		return *this;
	}
};

struct Wrapper {
	FirstField ff;
	SecondField sf;
};

Wrapper w;
w = std::move(Wrapper{});

// OUTPUT:
// FirstField Move ctor
// FirstField assign
// SecondField Copy assign
```

Выбор использовать или не исопльзовать - как всегда за вам. Тестируйте гипотезы и выбирайте из них лучшую.

Analyse your solutions. Stay cool.

#cppcore #cpp11 

https://cppdepend.com/blog/top-7-most-used-c-idioms-part1/


Правильный swap двух объектов Ч1 

В статье про swap идиому мы реализовали свап объектов класса через дружественную функцию. Сегодня поговорим почему так делать правильно.

В принципе нам нужна функциональность, которая сможет обменять данных двух объектов местами. Она может называться как угодно, никто не запрещает назвать вам swap функцию как TheMostTrickyFunction.

Но так делать не очень удобно. Все привыкли использовать std::swap для обмена значений. Поэтому логично как минимум назвать функцию swap.

Дальше будем рассматривать по очереди возможные варианты.

Можно определить метод swap внутри класса:

```cpp
struct my_type
{
    void swap(my_type&) { /* swap members */ }
};
```

И хоть это будет работать в пользовательском коде just fine, но мы не сможем для такого типа например использовать std::sort, которая вызывает свободную функцию swap.

Но мы можем найти примеры такого дизайна даже в стандартной библиотеке. Например std::vector имеем метод swap, который обменивает данные двух векторов. Но тут важен контекст: до появления мув-семантики обмен векторов через std::swap приводило бы к нежелательным копированиям. Поэтому в те времена многие объекты имели свою оптимизированную версию в виде метода. 

Сейчас вы можете использовать std::swap на двух векторах и не парится по поводу перфоманса. Так что просто swap метод класса нам не подходит.

Раз мы хотим использовать std::swap, то может тогда просто специализируем эту функцию для нашего типа в скоупе std? Давайте попробуем.

```cpp
namespace std
{
    template <> // important! specialization in std is OK, overloading is UB
    void swap(my_type& one, my_type& two)
    {
        one.swap(two);
    }
}
```

И это даже может и заработает. Но С++20 говорит нам, что специализировать шаблоны из неймспейса std - неопределенное поведение. Поэтому этот вариант - совсем не вариант.

Попробуем определение свободной функции swap в неймспейсе класса

```cpp
namespace my_ns {

struct my_type
{
    void swap(my_type&) { /* swap members */ }
};

void swap( my_type<T> & lhs, my_type<T> & rhs ) noexcept
{
    lhs.swap(rhs);
}

}
```

Однако это выглядит просто как обертка для метода swap, который больше нигде не используется. Может как-то схлопнуть две эти сущности?

Сделаем эту свободную функцию дружественной нашему классу! Тогда можно выкинуть ненужный метод и оставить просто функцию.

```cpp
struct my_type
{
    friend void swap(my_type& first, my_type& second) noexcept {
	  // swap
	}
};
```

Так-то лучше. Все работает и выглядит культурно. Далее поговорим про то, что должно быть внутри функции.

Be nice. Stay cool.

#template #cppcore  #cpp20

Правильный swap двух объектов Ч2

Вчера мы разобрались, почему swap лучше всего определять через дружественную функцию. Сегодня разберем то, что должно быть у нее внутри.

Очень хочется написать просто типа такого:

```cpp
struct my_type
{
    friend void swap(my_type& first, my_type& second) noexcept {
		std::swap(first.member_1, second.member_1);
		std::swap(first.member_2, second.member_2);
	}
	Type1 member1;
	Type2 member2;
};
```

И это работает для тривиальных типов Type1, Type2. Если у вас тривиальные члены - пожалуйста пользуйтесь.

Но если Type1, Type2 - пользовательские типы не из стандартной библиотеки? Понятное дело, что для стдшных типов есть специализации std::swap. Но вот для обычных смертных - нет. И если для этого смертного типа определена своя функция swap, которая лучше знает, как обменивать данные, то таким образом вы никогда ее не вызовете. А если какой-то из ваших мемберов не удовлетворяет условию std::is_move_constructible_v\<T> && std::is_move_assignable_v\<T>, то вы вообще не скомпилируете этот код.

Выход - нужно как-то разрешить искать функцию swap в неймспейсе класса. Так как она более специализирована под ваш конкретный тип, то она будет предпочтительнее, чем стдшная, и будет вызываться вместо него.

Такая штука есть и называется она ADL или Argument Dependent Lookup. С ее помощью мы можем найти нужную функцию по типу аргумента. Можно написать:

```cpp
struct my_type
{
    friend void swap(my_type& first, my_type& second) noexcept {
		swap(first.member_1, second.member_1);
		swap(first.member_2, second.member_2);
	}
	Type1 member1;
	Type2 member2;
};
```

И если для Type1 и Type2 определены свои функции swap, то они найдутся и все скомпилируется.

Однако выискивать для каждого типа своего мембера, есть ли у него своя собственная swap - задача неблагодарная. Хотелось бы и рыбку съесть и машку за ляшку(Подчеркнуть) не задумываться о выборе нужной функции и положить эту задачу на плечи компилятора. И это можно сделать!

```cpp
struct my_type
{
    friend void swap(my_type& first, my_type& second) noexcept {
	    using std::swap;
		swap(first.member_1, second.member_1);
		swap(first.member_2, second.member_2);
	}
	Type1 member1;
	Type2 member2;
};
```

Какая тут магия произошла. Мы попрежнему используем ADL для поиска наиболее подходящей функции. Но если мы ее не нашли, то остается бэкап в виде std::swap, которая может вызваться благодаря using std::swap.

Примерно так и выглядит каноничный вид функции swap для ваших кастомных классов.

Sit on both chairs. Stay cool.

#cppcore 

std::swap и ADL

В коммьюнити есть определенное заблуждение, что когда мы вызываем std::swap для наших кастомных типов,  эта функция в начале ищет через ADL самую подходящую перегрузку, которую мы возможно определили, и только в случае неудачи вызывается дефолтная реализация обмена. Особенно это стало актуально после появления С++11. Это конечно не так и вот причины.

Первая, довольно косвенная. Все алгоритмы стандартной библиотеки никогда не используют вызов std::swap напрямую для обмена элементов последовательности. Там все делается как в предыдущем посте с помощью using std::swap, чтобы как раз разрешить ADL найти самую подходящую перегрузку. Зачем это делать, если std::swap и так самостоятельно ищет через ADL?

Вторая - подобная реализация std::swap вгоняет в бесконечную рекурсию следующий код:

```cpp
namespace ns
{
	struct foo
	{
		foo() : i(0) {}
		int i;
	};
	void swap(foo& lhs, foo& rhs)
	{
		std::swap(lhs.i, rhs.i);
	}
}

template <typename T>
void do_swap(T& lhs, T& rhs)
{
	std::swap(lhs, rhs);
}

int main()
{
	ns::foo a, b;
	do_swap(a, b);
}
```

Неважно хороший ли это код или нет, он может встречаться в проектах. Зачем определять свою функцию swap через std::swap - загадка, но это работает.

Почему вообще должно быть важно, что работает такой плохой код? Потому что обратная совместимость. Такой код вполне мог существовать и использование ADL внутри std::swap его бы сломало.

Тем не менее были [предложения в стандарт ](https://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4381.html), которые предлагали разрешить ADL внутри std::swap. И они вроде даже попали в драфт С++20, но в сам стандарт так и не вошли. Думаю, что в том числе и по причине обратной совместимости.

Так что для правильного свопа необходимо приписывать using std::swap. Или нет?

Я уже говорил, что в стандартной библиотеке алгоритмов не используется обмен элементов последовательности через std::swap. Но не сказал, как именно. А обменивают их через std::iter_swap(логично, там же итераторы используются). И вот его возможная имплементация:

```cpp
template<class ForwardIt1, class ForwardIt2>
constexpr //< since C++20
void iter_swap(ForwardIt1 a, ForwardIt2 b)
{
    using std::swap;
    swap(*a, *b);
}
```

То, что нужно! Теперь можно писать так:

```cpp
struct my_type
{
    friend void swap(my_type& first, my_type& second) noexcept {
		std::iter_swap(&first.member_1, &second.member_1);
		std::iter_swap(&first.member_2, &second.member_2);
	}
	Type1 member1;
	Type2 member2;
};
```

Немного корявенько, зато думать не надо.

Ну или можно бустовскую версию свапа взять, которая делает примерно то же, что и iter_swap. Но надо ли вам тянуть буст - это вопрос.

Properly exchange values. Stay cool.

#cppcore


Зачем вообще нужен кастомный swap?

Коротко - незачем)

Но как всегда есть нюансы. Забайтились? Погнали разбираться

Как всю историю человечества разделяет Рождество Христово, так и история С++ делится на две эпохи появлением стандарта С++11. Получается, что С++11 - Иисус в мире плюсов...

И вот до С++11 мы не имели семантики перемещения и функция std::swap обменивала два значения через копирование. Ну и естественно это никому не нравилось. Зачем такой оверхед, когда мне нужно только местами данные поменять?

И вот в те времена кастомная функция swap была как нельзя кстати. Именно поэтому std::vector имеет отдельный метод swap. Рудимент архаичного прошлого...

С тех пор все стандартные алгоритмы в первую очередь ищут use-defined swap и уже на крайняк используют std::swap.

Если ваш класс управлял хоть каким-то ресурсом, даже строкой, вам нужен был свап.

Но по сути-то, свап - это такой одновременный мув друг в друга(идейно). Ну и с появлением мув-семантики стандратная swap стала выглядеть именно так, как нам нужно идейно:

```cpp
template <typename T>
void swap(T& x, T& y)
{
    T temp(std::move(x));
    x = std::move(y);
    y = std::move(temp);
}
```

Эта версия свапа делает ровно то, что ожидали практически от всех кастомных swap'ов - эффективный обмен двух значений.

Она позволяет даже некопируемым объектам, типа стримов, мьютексов и прочих, обменяться местами. То есть она буквально отобрала весь хлеб у кастомной swap: теперь стандратная функция делает такой же эффективный обмен значениями, плюс может также обменять некопируемые объекты. Красота!

Но у самописной swap остается одно преимущество: Не происходит никаких вызовов конструкторов классов обмениваемых объектов. Мы напрямую обмениваем содержимое объектов. А std::swap все-таки вызывает один мув-конструктор и 2 мув присваивания. О производительности надо думать...

А еще надо думать об оптимизациях компилятора. Специальные методы могут быть заинлайнены и std::swap превратится ровно в то же, что сгенерирует компилятор для вашей самописной обменивалки.

Итог какой: кастомный своп был придуман, в основном, чтобы эффективно обменивать объекты. std::swap на стероидах мув-семантики позволяет делать это очень эффективно. Самописный своп имеет на первый взгляд незначительные преимущества по производительности. Но на практике как всегда надо тестировать оба варианта. Ну или не заниматься преждевременной оптимизацией и использоват std::swap.

Use standard things. Stay cool.

Гарантии безопасности исключений

Правильный swap

Число 42

Вот живет программист по С++ своей прекрасной и беззаботной жизнью. Все у него хорошо: код пишется, баги фиксятся, деньги мутятся. И имя у него такое прекрасное - Иннокентий.

Иногда он лазается по cppreference, чтобы освежить знания по каким-то фичам или узнать что-то новое. Представим себе, что он зашел просмотреть на доку std::atoi и видит там такой фрагмент:
```cpp
const auto data =
    {
        "42",
        "0x2A", // treated as "0" and junk "x2A", not as hexadecimal
        "3.14159",
        "31337 with words",
        "words and 2",
        "-012345",
        "10000000000" // note: out of int32_t range
    };
```

Ничего необычного, просто определяется std::initializer_list<const char \*> и записываются туда разные строки. Ну ладно, работает дальше.

А дальше ищет статейку по std::variant. И находит там вот какой отрывок:

```cpp
int main()
{
    std::variant<int, float> v, w;
    v = 42; // v contains int
    int i = std::get<int>(v);
    assert(42 == i); // succeeds
    w = std::get<int>(v);
    w = std::get<0>(v); // same effect as the previous line
    w = v; // same effect as the previous line
	...
}
```

Почему-то он обратил внимание на число 42. "Где-то я его уже видел.". И вспоминает, что недавно видел это же число в коде для std::atoi. Это, конечно, немного странно - подумал, он. Но решил, что это просто случайность.

Приходит наш герой домой с работы и, как каждый уважающий себя программист, вместо ужина садится писать свой пет-проект. А вы не знали, что программисты могут годами жить на диете "код+кофе"?

Пишет он какое-то многопоточное приложение. Чтобы адекватно писать такие штуки, нужны глубокие знания о модели памяти в С++ и как работает синхронизация данных в многопроцессорном мире. Поэтому кодер снова идет на cppreference и находит там статейку про std::memory_order. Читает, читает. И херак, вылупил глаза в экран. "Это уже очень странно". А увидел он следующий фрагмент:

```cpp
std::vector<int> data;
std::atomic<int> flag = {0};
 
void thread_1()
{
    data.push_back(42);
    flag.store(1, std::memory_order_release);
}
```

Опять это 42! "Что за приколы такие? Это что, любимое число плюсовиков, что они его везде пихают?". На том и порешил. Не нервничать же по поводу чьего-то любимого числа. Может именно на этот день рождения Страуструпу подарили маленького щеночка....

В общем, затерпели и забыли.

Иннокентий только начинает писать свой проект и ему нужен хороший сборочный скрипт. Выбор языка пал на модныймолодежный питухон, поэтому он полез в документацию изучать базовый синтаксис питона. И тут на тебе:

```python
x = int(input("Please enter an integer: "))
Please enter an integer: 42
if x < 0:
    x = 0
    print('Negative changed to zero')
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')
```

Whatafuck? Страуструп здесь уже никак не может быть замешан. Ситуация больше похожа на массонский заговор. Кенни не выдержал и пошел распутывать тайну века.

Оказалось, что это отсылка на книгу Дугласа Адамса "Автостопом по галактике".  Там люди создали супермощный супекомпьютер только с одной целью - узнать ответ на "Главный вопрос жизни, Вселенной и всего такого". Этот вопрос настолько сложный и комплексный, что на нахождение ответа суперкомпьютер потратил целых 7.5 млн лет вычислений. И в окончании выдал: "42".

Роман вышел в период расцвета sci-fi, поэтому оставил глубокий отпечаток в массовой культуре. Оно появлялось в популярных сериалах типа "Остаться в живых". Даже один из радиотелескопов НАСА использует ровно 42 тарелки в честь отсылки к произведению.

Неудивительно, что гики по всему миру начали пихать это число во всех места в качестве пасхалки. Сейчас почти где-угодно встречая 42, вы можете быть на 99% уверены, что это именно отсылка на "Автостопом по галактике".

Так и была разгадана величайшая из тайн иллюминатов и Иннокентий довольный пошел спать. The end.

Make references to the great things. Stay cool.

#fun



Теги

Иногда бывают случаи, когда нужно реализовать класс, каждый инстанс которого будет содержать в себе какую-то характеристику. И, главное, эта характеристика не меняется в течение всего времени жизни объекта. Условно: есть базовый класс "Деталь" и у него есть характеристика "материал". Так вот очевидно, что материал детали не поменяется после того, как ее создали. И это можно использовать для своей выгоды.

Давайте чуть менее абстрактный пример. Есть кастомный класс строки. И иногда в этих строках хранятся секреты и при попытке вывести ее на стандартный вывод мы хотим печатать что-то вроде "\*\*\*\*\*\*\*". Чтобы в логах не было утечки этих секретов.  А если строка не содержит секрета, то мы ее спокойно печатаем без изменений. Выглядеть это может примерно так:

```cpp
struct String {
	String(std::string s, bool is_secret) : str{s}, is_secret{is_secret} {}
	void Log() {
		if (is_secret) {
			std::cout << "********" << std::endl;
		} else {
			std::cout << str << std::endl;
		}
	}
	... other member functions
	std::string str;
	bool is_secret;
};

String str{"qwerty", false};
str.Log();
String str1{"qwerty", true};
str1.Log();
```

Вывод ожидаемый:
```
qwerty
********
```

Но вот вопрос. А прям нужно ли нам хранить этот несчастный bool? Как будто бы напрашивается 2 разных класса для двух этих кейсов. Тогда и потребность в отдельном поле иссякнет, и класс будет весить меньше. Но вот уж очень не хочется дублировать код для других методов, потому что их вообще не волнует, как мы отображаем данные. И выход из этого тупика есть!

Техника называется тегирование. Введем шаблонный параметр, который будет отвечать за выбор стратегии логирования. Этот шаблонный параметр будет называться тег. А так как тег - часть типа, то на это не будет тратится память. Посмотрим, как это будет выглядеть.

```cpp
enum class LogType {
	Open,
	Hidden
};

template <LogType log_representation = LogType::Open>
struct String {
	String(std::string s) : str{s} {}
	void Log() {
		if constexpr (log_representation == LogType::Open) {
			std::cout << str << std::endl;
		} else {
			std::cout << "********" << std::endl;
		}
	}
	std::string str;
};

String str{"qwerty"};
str.Log();
String<LogType::Hidden> str1{"qwerty"};
str1.Log();
```

В качестве типа тега будет использовать enum class(c++11 фича). Также введем значение шаблонного параметра по умолчанию, чтобы для несекретной строки не указывать параметр.

Здесь очень важно использовать if constexpr в выборе способа логирования, так как log_representation доступен на момент компиляции и нет смысла переносить выполнение условия в рантайм.

Также подтверждаю, что размер стандартного класса строки и нашего кастомного теперь одинаковый!

```
sizeof(String<LogType::Open>) == sizeof(String<LogType::Hidden>) == sizeof(std::string); // true
```

Такая вот техника. Пользуйтесь, кто не знал. Потому что в очень многих местах в коде вы можете применить ее и получить маленький, но буст в производительности. А еще по типу будет сразу понятно, как себя будет вести объект. Еще и читаемости кода увеличите. В общем, сказка.

Optimize your life. Stay cool.

#optimization #cpp11 #cpcore #goodpractice 



Сравнение объектов тегированных классов

Вернемся к предыдущему примеру со строками. А что если мы хотим сравнить две строки? Причем мы хотим иметь возможность сравнивать строки с разными тегами. Как нужно написать сравнивающий оператор?

Сходу может показаться, что можно написать так:

```cpp
enum class LogType {
	Open,
	Hidden
};

template <LogType log_representation = LogType::Open>
struct String {
	String(std::string s) : str{s} {}
	void Log() {
		if constexpr (log_representation == LogType::Open) {
			std::cout << str << std::endl;
		} else {
			std::cout << "********" << std::endl;
		}
	}
	//!!
	bool operator==(const String<log_representation>& other) {
		return str == other.str && log_representation == other.log_representation;
	}
	
	std::string str;
};
```

Но на второй, более осознанный, взгляд становится понятно, что это не сработает. У объекта other нет никакого поля representation. Эта строчка просто приведет к ошибке компиляции.

Да и вообще, если задуматься, то в таком виде оператор сравнения принимает на вход только одноименную строку с таким же тегом. Поэтому проверять его бессмысленно, для объекта \*this и other теги будут одинаковы при такой нотации оператора\=\=.

Как правильно надо делать.

Вводить отдельный шаблонный параметр для метода. Тогда у нас появится возможность принимать на вход строки с другими тегами и учитывать эти теги в сравнении. 

```cpp
template <LogType log_representation = LogType::Open>
struct String {
	template <LogType other_log_representation>
	bool operator==(const String<other_log_representation>& other) {
		if constexpr (log_representation == other_log_representation) {
			return str == other.str;	
		} else {
			return false;
		}
	}
	std::string str;
};

String str{"qwerty"};
String<LogType::Hidden> str1{"qwerty"};
String str2{"qwerty"};
std::cout << (str == str2) << std::endl;
std::cout << (str1 == str2) << std::endl;
//OUTPUT:
1
0
```

Теперь код скомпилится и будет работать, как ожидается.

Как видите, шаблоны - тема непростая и даже под такими, казалось бы, привычными вещами могут скрываться подлянки.

Compare things properly. Stay cool.


Чем friend operator лучше метода operator

В примере из прошлого поста я использовал оператор== в качестве метода.

```cpp
template <LogType representation = LogType::Open>
struct String {
	template <LogType representation1>
	bool operator==(const String<representation1>& other) {
		if constexpr (representation == representation1) {
			return str == other.str;	
		} else {
			return false;
		}
	}
	std::string str;
};
```

Но есть и другая нотация введения этого оператора - через дружественную функцию. friend function - такая свободная функция, которая объявляется в теле класса и получает доступ ко всем секретикам этого класса. А это приватные и защищенные члены. Выглядит это так:

```cpp
```cpp
template <LogType representation = LogType::Open>
struct String {
	template <LogType representation1>
	friend bool operator==(const String<representation>& lhs, const String<representation1>& rhs) {
		if constexpr (representation == representation1) {
			return lhs.str == rhs.str;
		} else {
			return false;
		}
	}
	std::string str;
};
```

Здесь мы определяем дружественный оператор\=\=, который левым операндом принимает объект текущей инстанциации, а правым - неизвестной, поэтому там дополнительный шаблонный параметр. 

Ничего сложного. Но в чем разница? И та, и эта форма решают одну задачу и решают ее одинаково хорошо. Какой способ выбрать по итогу?

Есть один герой, который стоит на страже членов(класса)! Называется он - инкапсуляция.

Как по мне, использование дружественных функций ее нарушает. Подумайте, для чего функции нужен доступ к закрытым полям? Может у вас API плохое и его стоит допилить?

Поэтому я за максимальное использование методов. Однако все же есть кейсы, когда все-таки придется использовать функции(дружественные или нет - вопрос другой).

В методы всегда неявно передается указатель на объект, из которого метод был вызван. Значит для того, чтобы использовать метод, левый операнд должен быть этого же типа(чтобы у него вызвался метод). Но не во всех кейсах есть такая гарантия.

Самый банальный пример - перегрузка operator<< для вывода объекта в какой-то поток вывода. Там слева будет стоять объект нужного потока и только справа наш класс. И это хрестоматийный пример, когда "разрешается" использовать friend.

В общем виде это выглядит так:

```cpp
class A {
    // a lot of fields
    friend std::outstream& operator << (std::outstream& out, const A& a); // must be friend here
};
```

И то как бы спорно. Я еще понимаю, когда в классе много полей и там довольно нетривиальная сериализация. Тогда просто выгодно заглянуть внутрь и сразу все упаковать. Но в нашем прошлом примере с классом String(забудем, что там был метод Log) можно не объявлять этот оператор дружественным, если сделать номальный геттер константной внутренней строки.

```cpp
friend std::outstream& operator << (std::outstream& out, const String<LogType::Open>& rhs) {
	return out << rhs.GetString();
}
friend std::outstream& operator << (std::outstream& out, const String<LogType::Hidden>& rhs) {
	return out << "*****";
}
```

Поэтому всегда дважды думайте перед тем, как сделать одну сущность дружественной другой. Возможно, стоит пересмотреть ваш дизайн.

Пост и так довольно длинный получился. Если хотите еще примеров, когда функцию необходимо делать дружественной - накидайте лайков.

Have a true friends. Stay cool.

#cppcore #design #goodpractice 


Приватный деструктор

Все мы с вами знаем, что можно делать конструкторы приватными. Например, для синглтон паттерна такое используется или для запрета создания объекта класса никаким другим образом, кроме как вызовом статический метода Create. Раньше, до появления возможности удаления функций в С++11 с помощью =delete, конструктор копирования делали приватным, чтобы запретить внешнему коду возможность копирования объекта. 

Однако есть и симметричный сценарий, с которым вы явно не так часто сталкивались. Можно объявить приватным деструктор! Как это изменение отражается на поведении класса?

Вот у нас есть класс. Там не будет ничего, кроме приватного деструктора. И дальше мы попытаемся посоздавать объекты этого класса.

```cpp
struct CreationTest {
private:
	~CreationTest() {};
}

CreationTest global_obj;

int main() {
	CreationTest auto_obj;
	CreationTest * dynamic_obj = new CreationTest;
	// delete dynamic_obj;
}
```

Пойдем по порядку. `global_obj`. Его конструктор вызывается в статической области памяти до вызова main. А деструктор по идее должен вызваться после завершения main в функции std::exit. Однако проблема: std::exit - внешний код для класса CreationTest, поэтому она не имеет право вызвать деструктор. Значит, на этой строчке будет ошибка компиляции. Вы не можете создавать объекты с приватным деструктором в статической области.

Далее `auto_obj`. Память под этот объект выделяется на стеке и конструктор вызывается на этой памяти. А деструктор этого объекта вызывается после выхода из скоупа самим рантаймом. У которого опять нет доступа к `auto_obj`. Да чтож такое. Опять ошибка компиляции. 

Теперь dynamic_obj. Конструкто здесь вызывается самим оператором new, который в начале аллоцирует память и потом на этой памяти вызывает конструктор. С этим все хорошо. Но здесь намеренно допущена утечка, потому что если бы мы вызвали оператор delete, то и на этой строчке была бы ошибка. 

То есть динамическая область - единственное место, где мы нормально можем создавать объекты. Но без удаления этих объектов жить будет как-то грустновато. Утечки памяти, ее фрагментация. В общем ничего хорошего. Нужно решать проблему гениально! Я подключаюсь к Галилео(ЗАЧЕРКНУТЬ).

Кто может получить доступ к приватным полям класса? Либо его методы, либо его кореша. То есть друзья. И это единственные сущности, которые помогут решить нам проблему. Покажу сразу оба варианта.

```cpp
struct CreationTest {
	static void Destroy(CreationTest * obj) {
		delete obj;
	}
	friend void DestroyFunc(CreationTest * obj);
private:
	~CreationTest() {};
}

void DestroyFunc(CreationTest * obj) {
	delete obj;
}

int main() {
	CreationTest * dynamic_obj = new CreationTest;
	CreationTest::Destroy(dynamic_obj);
	CreationTest * dynamic_obj1 = new CreationTest;
	DestroyFunc(dynamic_obj1);
}
```

Теперь все компилируется без проблем. 

Можно конечно немного позалупаться и создавать объекты через placement_new в автоматической области и также внутри функции вызывать деструктор, но это как будто бы борщ. Не очень добно. В предыдущем примере мы хоть заменили delete на destroy, а тут надо создавать отдельно массив, на нем создавать объект, и еще одну писать функцию, которая будет явно деструктор вызывать. Много сомнительных действий.

Кстати, можно для таких динамических объектов использовать и умные указатели с кастомными делитерами, чтобы не беспокоиться о ручном управлении памятью.

```cpp
auto deleter = [](CreationTest * obj) {DestroyFunc(obj);};
std::unique_ptr<CreationTest, decltype(deleter)> smart_obj(new CreationTest, deleter);
```

В следующем посте поговорим о том, зачем вообще может понадобиться делать конструктор приватным.

Protect your private life. Stay cool.

#cppcore #cpp11



Зачем может понадобиться делать деструктор приватным?

Вчера мы узнали, что можно делать деструктор приватным. Те, кто не слышал о этой технике, скорее всего подумали: "Сомнительно........но.....окэй". Потому что с первого взгляда не очень понятно, для чего вообще нужно заниматься этими непристойностями in the first place. Чтобы запретить пользователю создавать объекты на стеке и в статической области?

Ну и действительно, этот паттерн используется нечасто. Однако кейсы применения все же есть.

Один из основных - ATL COM объекты. Их цикл жизни регулируется с помощью подсчета ссылок. И чтобы никто не смог удалить объект, на который все еще ссылаются ссылки, для объектов вводят приватный деструктор и метод Release, который обязан реализовать класс. В методе происходит декремент ссылки, проверка их количества и удаление объекта, если он остался больше никому не нужным. Выглядеть это может примерно так:

```cpp
int MyRefCountedObject::Release() 
{
	_refCount--;
	if ( 0 == _refCount ) 
	{
		delete this;
		return 0;
	}
	return _refCount;
}
```

Как можно было понять, это довольно устаревшая и нишевая виндовая история. Сейчас такую архитектуру никто бы и не вздумал создавать при наличии стандартных умных указателей. Раньше паттерн подсчета ссылок был более популярен. Теперь это скорее странное легаси.

Помимо этого примера, для меня вообще довольно странная история, чтобы позволять какому-то коду создавать объект, но не позволять удалять его. Это же абсурд! Если я бы захотел контролировать удаление объекта, то с вероятностью 99% я бы захотел контролировать его создание. Чтобы так сказать стать властелином его цикла жизни. Поэтому, на мой взгляд, приватный деструктор должен идти вместе с приватным конструктором.

Для синглтонов имеет смысл сделать деструктор приватным, чтобы никто по ошибке не смог явно вызвать на ссылке деструктор. Сам деструктор вызывается в статическом методе-геттере, который имеет доступ к приватным полям, тут все аккуратно работает.

Также приватные конструктор и деструктор могут идти в комплекте с  двумя статическими методами: Create() и Destroy().

Например, из Create возвращать умный указатель и указывать в качестве его делитера **приватный** статический метод Destroy. Таким образом вы можете реализовать довольно сложную логику создания и удаления объекта. Когда, например, у вас есть конструктор и метод init, то для ограничения работы с созданным, но не инициализированным объектом, используется метод Create. По аналогии для деструктора и finalize мы используем Destroy. Мы никого не ограничиваем в правильном создании и удалении объектов. Просто хотим, чтобы только через эти два метода проходило создание и удаление объектов.
```cpp
class ControlLifeCycle
{
public:
	static std::unique_ptr<ControlLifeCycle, void(*)(ControlLifeCycle*)> Create() // Factory
	{
		auto deleter = [](ControlLifeCycle * obj)
		{
			ControlLifeCycle::Destroy(obj);
		};
		std::cout << "I was born!" << std::endl;
		return std::unique_ptr<ControlLifeCycle, decltype(deleter)>(new ControlLifeCycle, deleter);
	}
private:
	static void Destroy(ControlLifeCycle* ptr)
	{
		std::cout << "I've been destroyed!" << std::endl;
		delete ptr;
	}
	ControlLifeCycle() {} // Private CTOR and DTOR
	~ControlLifeCycle() {}
};

ControlLifeCycle global_var;                          // error: ctor and dtor are private

int main ()
{
    ControlLifeCycle stack_var;                          // error: ctor and dtor are private
    ControlLifeCycle* dynamic_var = new ControlLifeCycle;     // error: private ctor
    auto smart_var = ControlLifeCycle::Create();  // OK
}
```

Можно из метода Create возвращать просто указатель и оставить метод Destroy публичным. Тогда только мы своими очумелыми ручками сможем напечатать в нужном месте кода "Class::Destroy(ptr);" и только тогда произойдет освобождение ресурсов и ни в каком другом случае.

Можно даже вместо Destroy сделать статический метод RequestDestroy, который будет решать, можно ли на данный момент удалить объект. Принимать такое решение класс может на основе какого-то условия, типа открытого коннекшена к базе, или  наличие незакрытого файла, находящегося в процессе записи. 

В общем, эта техника может использоваться в любом месте, где нам необходим полный контроль над циклом жизни объекта и над способом его рождения и захоронения. 

Control cycle of your life. Stay cool.

#cppcore #goodpractice #design 





XOR Swap

Есть такая интересная техника для свопинга содержимого двух переменных без надобности во временной третьей! Стандартный подход выглядит примерно так:

```cpp
template <class T>
void swap(T& lhs, T& rhs) {
	T tmp = std::move(lhs);
	lhs = std::move(rhs);
	rhs = std::move(tmp);
}
```

Все мы с программистких пеленок уже выучили это. И примерно так и реализована функция std::swap из стандартной библиотеки. Однако вот вам задали на собесе вопрос: "вот у вас есть 2 числа, но я хочу, чтобы вы обменяли их значения без временной переменной?". Какие мысли? Подумайте пару секунд.

Как всегда, на помощь приходит магия математики и битовых операций. Можно использовать 3 подряд операции xor над этими числами и мы получим нужный результат.

```cpp
template <class T, typename std::enable_if_t<std::is_integral_v<T>> = 0>
void swap(T& x, T& y) {
	if (&x == &y)
		return;
	x = x ^ y;
    y = x ^ y;
    x = x ^ y;
}
```

Доказывать сие утверждения я, конечно, не буду. Однако можете почитать в [английской вики](https://en.wikipedia.org/wiki/XOR_swap_algorithm), там все подробно выводится из свойств исключающего или.

Тут есть один интересный момент, что в случае подачи на вход функции одной и той же переменной, то произойдет эффект зануления. Первый же xor занулит x, а значит и y. Поэтому в самом начале стоит условие на проверку одинакового адреса.

При подаче на вход просто одинаковых значений, все работает и без условия.

Но предостерегаю вас - не используйте эту технику в современных программах! Результаты этих трех ксоров напрямую зависят друг от друга по цепочке. А значит параллелизма на уровне инструкций можно не ждать. 

Современные компиляторы вполне могут и соптимизировать третью переменную и вы ее вовсе не увидите в ассемблере. Да и еще и вариант с доп переменной тупо быстрее работает. Всего 2 store'а и 2 load'а, которые еще и распараллелить можно, против 3 затратных ксоров. 

Зачем я это все рассказываю тогда, если эта техника уже никому не уперлась? Для ретроспективы событий. Дело в том, что раньше люди писали программы без компиляторов, напрямую на ассемблере. Плюс в то время компьютеры имели такое маленькое количество памяти, что биться приходилось буквально за каждый байт. А используя операции xor, мы экономим 33% памяти на эту операцию. Довольно неплохо. В стародавние времена как только не извращались люди, чтобы выжимать все из железа. Эх, были времена...

Понимание тонкостей операции xor и ее возможных приложений делают ее довольно мощным инструментом в низкоуровневых вычислениях. А в некоторых задачах вы и вовсе никогда даже не подумаете, что они могут наиболее эффективным образом решаться с помощью xor.

Learn technics from the past. Stay cool.

#cppcore #fun #algorithms


Задача

Продолжаем рубрику #задачки, где мы разбираем интересные задачи из мира программирования и не только. Сегодня на очереди довольно интересная задачка, которая сформулирована очень просто и просто решается большинством из нас. Однако в ней зарыт демон - и он заберет у вас пальцы, если вы не решите ее за линейное время и константную сложность по памяти. Как вы тогда код писать будете? То-то же. Придется решать.

Формулировка такая: дан непустой массив интов. Каждый элемент массива встречается ровно 2 раза, кроме одного, который встречается 1 раз. Необходимо найти этот элемент.

Напоминаю правила: под этим постом проходят все обсуждения возможного решения задачи. Знающих решение прошу воздержаться от комментирования. Вечером выйдет пост с решением, где можно уже обсуждать все, что угодно, касаемо задачи и не только.

Всем удачи и погнали решать!

Challenge your life. Stay cool.



Решение задачи

Повторюсь, что какое-то решение задачи написать можно довольно легко. Банальный вариант - вложенный цикл, для каждого элемента массива ищем другой такой же элемент, у которого не совпадают индексы. Это очень просто, но очень неэффективно - квадратичное время и константные затраты памяти.

Можно чуть получше - догадаться, но в отсортированном массиве одинаковые элементы будут стоять рядом и нам нужно лишь найти тот, у которого нет пары. Время - O(nlogn), память - константная.

Можно еще лучше - закидывать элементы в хэш-мапу и потом пройтись по ней и найти то число, количество вхождений которого в массив - 1. Время линейное, затраты по памяти тоже линейные.

Но все это не удовлетворяет демоненка задачи. Ему хочется крови и константной памяти при линейном времени. Что же поможет удовлетворить его голод перед тем, как он набросится на пальцы?

Математика!

Не зря вчерашний пост был про операцию xor. Это была подводка к этой задаче. 

Очевидным свойством операции xor над числами - xor двух одинаковых чисел дает ноль. И ксор любого числа с нулем в результате будет давать то же самое число.

Представим себе, что числа в нашем массиве расположены определенным образом - в начале идут парные числа, а в самом конце - наше одинокое число.

Тогда мы выставим результирующую переменную в ноль и будем ксорить по порядку все числа с этим результатом. Применяя эти два свойства мы получим следующее:

```
3 3 2 2 7 7 5
int res = 0;
res ^= 3; // res == 3
res ^= 3; // res == 0
res ^= 2; // res == 2
res ^= 2; // res == 0
res ^= 7; // res == 7
res ^= 7; // res == 0
res ^= 5; // res == 5
```

по итогу результат будет равен последнему числу, то есть и нужному нам ответу.

"Но это же фигня какая-то. Порядок совсем не такой! Он может быть любым."

Все верно. Однако мы добавляем в этот коктейль пару щепоточек свойства коммутативности xor и пару столовых ложек его ассоциативности (aka от перемены мест слагаемых сумма не меняется) и получим вкуснейшее решение. Как угодно переставляйте местами числа в массиве - результат будет ровно тот же по свойствам операции xor. 

Тут можно такую аналогию провести. Вместо xor использовать операцию "+", а вместо одинаковых чисел - число и его отрицательный брат. Выглядеть это может так:

```
-3 + 1 + 5 + (-4) + 3 + (-1) + (-5)
```

У вас же не возникает сомнений, что результатом вычисления этого выражения будет -4. И я даже знаю, как вы это делаете. Находите противоположные числа, в уме зачеркиваете их и как бы зануляете их. По итогу остается сирота.

Ровно то же самое происходит и в нашей сегодняшней задаче.

Пока писал пост еще глубже понял прикол задачи. Она удивительно красивая! И подходит для решения разработчикам и энтузиастам разных уровней: начинающие решают за 2 цикла, продвинутые колдуют ксорами. Надеюсь, решение вам тоже понравилось)

Solve your problems. Stay cool.


Усложняем задачу

Пока мы далеко не уехали от прошлой #задачки, предлагаю порешать ее усложненную версию, предложенную нашим подписчиком Антоном в этом [комменте](https://t.me/c/2009887601/8466). В чате было вялое обсуждение, но прям конкретного решения не было предложено. Да и с тех пор в чате примерно 2к сообщений написали(за 2 дня!), поэтому вы вряд ли что-то найдете) Кстати, пользуясь моментом, призываю вас вступить в наш чат https://t.me/+qJ8-vWd97nExZGIy. Там ребята постоянно обсуждают код, фреймворки, метапрограммирование. Да и вообще просто веселятся и играют в шахматы)

А условие обновленной задачи такое: дан непустой массив интов. Каждый элемент массива встречается ровно 2 раза, кроме **двух**, которые встречаются 1 раз. Необходимо найти эти элементы за линейную временную сложность и константные затраты по памяти.

Всего один аспект условия изменили, и как сразу непонятнее все стало)

Знающим решение - просьба не отбирать хлеб у пытливых умов. Вечером выйдет ответ.

Challenge your life. Stay cool.


Ответ

Опять же, откидывает все решения через сортировку и мапы - они не самые эффективные. Вернемся к решению к ксором.

Вот мы проксорили первым проходом весь массив. Получили на выходе ксор наших одиноких элементов. И что теперь делать? Как из этого значения получить оригинальные элементы.

А никак! Но мы можем использовать эту информацию для нахождения нужных элементов. Для определенности представим, что наши искомые числа обозначаются, как `a` и `b`, `a ^ b` - полученный результат после первого прохода.

Так как для одинаковых чисел xor будет давать ноль, то для разных чисел он будет давать какой-то ненулевой результат. Нунулевой - значит в бинарном представлении это значение будет иметь хотя бы единичку в каком-то из битов. Именно в этом бите N и будут различаться наши числа. А раз мы знаем, в каком бите различаются числа, то во время второго прохода мы можем отдельно ксорить числа с выставленным N битом и с невыставленным. По условию, только два числа непарные, а все остальные - парные. Пары чисел будут попадать в одну из групп и при ксоре будут занулять друг друга. Тогда у нас будут две суммы по модулю 2, которые и будут равняться нашим искомым `a` и `b`.

Битовые манипуляции - вещь, поэтому очень круто знать разные приемы с их использованием. Иногда это может значительно облегчить вам жизнь.

Solve your problems. Stay cool


Виртуальный деструктор
#новичкам

Возможно САМЫЙ популярный вопрос на собеседованиях на джунов и мидлов. Оно и справедливо в принципе: очень простой и понятный вопрос, но ответ на него требует хорошего уровня понимания ООП в принципе и как оно конкретно работает в плюсах. Динамический полиморфизм, наследование, порядок вызовов конструкторов и деструкторов - да, это база. Но именно ее и нужно проверить у начинающих и продолжающих разработчиков.

Обычно они заходят немного издалека и просят вангануть, что выведется в консоль для примерно такого кода:

```cpp
struct Resource {
	Resource() { std::cout << "Resourse has been acquired\n";}
	~Resource() { std::cout << "Resource has been released\n";}
};

struct Base {
	Base() { std::cout << "Base Constructor Called\n";}
	~Base() { std::cout << "Base Destructor called\n";}
};

struct Derived1: Base {
	Derived1() { 
		ptr = std::make_unique<Resource>(); 
		std::cout << "Derived constructor called\n";
	}
	~Derived1() {std::cout << "Derived destructor called\n";}
private:
	std::unique_ptr<Resource> ptr;
};

int main() {
	Base *b = new Derived1();
	delete b;
}
```

Вроде ничего сложного, но вот надо все штуки вспомнить, как там объекты создаются, в каком порядке что вызывается. Для начинающих тут часто затупки начинаются.

В коде вроде все хорошо написано и невнимательный кандидат может выдать вот это:

```
Base Constructor Called
Resourse has been acquired
Derived constructor called
Derived destructor called
Resource has been released
Base Destructor called
```

Вот тут-то его и подловили! **На самом деле никакого деструктора наследника вызвано не будет и соответственно ресурсы не освободятся**. Интервьюер дает наводку посмотреть на деструктор базового класса. И кандидат с красным лицом кричит: "Деструктор - невиртуальный! По указателю на базовый класс вызовется сразу деструктор этого класса, а деструктор дочернего не вызовется. Будет утечка памяти". Его так на курсах научили говорить. И дальше он выдает правильный вывод программы.

И тут интервьюер говорит: "А что будет, если наследник не будет содержать никаких полей? Какие проблемы будут у этого кода?".

И молодой разработчик в ступоре: он же знает, что невиртуальный деструктор приводит к утечкам. Но тут вроде как и утекать нечему. И говорит, что вроде как и проблем не будет.

Естественно, это неправда.

Если с виду ничего плохого не может произойти и даже при запуске программы ничего плохого не происходит - это не значит, что в программе нет проблем. Стандарт говорит:

```
if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and **the static type shall have a virtual destructor or the behavior is undefined**.
```

Отсутствие виртуального деструктора при удалении через базовый класс приводит к **неопределенному поведению**. И точка. Можете даже больше не упоминать утечки. Потому что может память утечь, а может и Пентагон задудосится от такой программы. Никто не знает.

Для корректного поведения полиморфных объектов и вызова деструктора дочернего класса вам обязательно нужен виртуальный деструктор.

Часто встречал эту проблему у младших разработчиков, да и сам я спотыкался на этом. Но теперь наши подписчики вооружены и опасны!

Stay armed. Stay cool.

#cppcore #interview


Виртуальный деструктор и std::shared_ptr

Плюсы - поистине удивительный язык. Вот подписчик изучил у нас на канале пользу виртуального деструктора и пошел в комментарии. А там Василий прислал пример, который говорит о том, что в определенном случае виртульность деструктора не важна и без него все работает корректно. И подписчик действительно удивляется: "What the fuck is going on?!?!?!?". Разберем все по порядку.

Пример вот такой:
```cpp
struct Base {
	~Base() {
		std::cout << "Base::~Base()" << std::endl;
	}
};

struct Derived : Base {
	~Derived() {
		std::cout << "Derived::~Derived()" << std::endl;
	}
};

int main() {
	std::shared_ptr<Base> p1 = std::make_shared<Derived>();
}
```

Прикол в том, что при удалении p1 вызовется деструктор наследованного класса:

```
Derived::~Derived()
Base::~Base()
```

Почему так?

Во время создания std::shared_ptr вы можете задать свой кастомный делитер. Но даже если вы его не предоставили, делитер все равно создается. Просто компилятор сам выведет по его мнению подходящий удалятель. И сохранит его в контрол блок умного указателя.

Так вот логично, что, если мы создаем указатель от объекта тип Derived, то и делитер выбирается соотвествующий. И в контрол блоке правого шареда будет делитер, который удаляет Derived*. Далее при присваивании указатель на этот конкретный контрол блок копируется левому шареду. После этого контрольный блок `p1` содержит тот самый изначальный делитер, который условно говоря сделает перед удалением указателя каст к классу наследника(delete static_cast<Derived*>(ptr)).
Именно поэтому и вызывается деструктор наследника.

Если мы попытаемся создать std::shared_ptr вот так:

```cpp
std::shared_ptr<Base> shared(static_cast<Base*>(new Derived));
```

то никакой магии уже не будет и деструктор наследника не вызовется. Потому что делитер ничего не будет знать о наследнике, так как мы явным образом привели указатель наследника в указателю на базовый класс.

Ну и с уникальным указателем такая штука тоже не сработает. Там делитер не хранится в объекте указателя, он зашит в сам тип. Поэтому для такой строчки:

```cpp
std::unique_ptr<Base> p1 = std::make_unique<Derived>();
```

для p1 не вызовется деструктор наследника, потому что делитер типа std::unique_ptr<Base\> удаляет только указатели на базовый класс. Чтобы объект удалялся корректно, нужен виртуальный деструктор базового класса. Без него никак.

Хоть такой интересный момент в плюсах и существует - не нужно на него полагаться. Одними шаредами жизнь не заканчивается, а классы должны вести себя корректно. Поэтому виртуальный деструктор - наше все!

Stay amazed. Stay cool.

#cpp11 #cppcore


Вектор ссылок
#новичкам

Не знаю, задумывались ли вы когда-нибудь создать вектор ссылок. Наверное задумывались, но не прям, чтобы пытались воплотить в жизнь. Не очень понятны кейсы применения этих сущностей. Однако они довольно хорошо подсвечивают одну интересную и базовую особенность вектора.

Дело в том, что вы не можете создать вектор ссылок. Не можете и все. Попробуйте написать что-то такое и запустить сборку:
```cpp
std::vector<int&> vec;
```

Вылезет какая-то совершенно монструозная кракозябра, по которой мы хрен пойми что должны понять. Это немного камней в огород бесполезных сообщений об ошибках в плюсах, но продолжим.

В сущности это происходит по одной причине. Шаблонный тип `vec` не удовлетворяет требованиям к типам элементов вектора.

До C++11 и появления [мув-семантики ](https://t.me/grokaemcpp/168) элементы вектора должны были удовлетворять требованиям CopyAssignable и CopyConstructible. То есть из этих объектов должны получаться валидные копии, притом что исходный объект оказывается нетронутым. Это условие, кстати, не выполняется для запрещенного в РФ иноагента [std::auto_ptr](https://t.me/grokaemcpp/164). Так вот ссылочный тип - не CopyAssignable. При попытке присвоить ссылке что-то копирования не происходит, а происходит просто перенаправление ссылки на другой объект.

После С++11 требования немного смягчились и теперь единственный критерий, которому тип элементов вектора должен удовлетворять - Erasable. Но ссылки также не попадают под этот критерий(для них не определен деструктор). Поэтому сидим без вектора ссылок. Или нет?

Можно хакнуть этот ваш сиплюсплюс и создать вектор из std::reference_wrapper. Это такая тривиальная обертка над ссылками, чтобы ими можно было оперировать, как обычными объектами. В смысле наличия у них всех специальных методов классов.

Но будьте осторожны, потому что есть одна большая проблема со ссылками. Вот мы создали и заполнили контейнер ссылками на какие-то объекты. И потом вышли из скоупа, где были объявлены объекты, на которые ссылки указывают. Вектор есть, ссылки есть, а объектов нет. Это чистой воды undefined behavior. Ссылки будут указывать на уже удаленные объекты. Пример:

```cpp
std::vector<std::reference_wrapper<int>> vec;
int * p = nullptr;
{
	int i;
	for (i = 0, p = &i; i < 5; i++) {
		vec.emplace_back(i);
	}
}

*p = 10;

for (int i = 0; i < 5; i++) {
	std::cout << vec[i] << std::endl;
}
```

Вывод будет такой:
```
10
10
10
10
10
```

Подумайте пару секунд, почему так. Переменная i меняется и мы добавляем ссылки на эту переменную в вектор. По итогу все элементы вектора указывают на одну и ту же переменную. Поэтому и элементы все одинаковы. 

Но раз ссылка - это обертка над указателем, то элементы вектора по факту хранят адрес того места, где была переменная i. Поэтому все изменения ячейки памяти этой переменной будут отражаться на ссылках, даже если переменная уже удалена. Вот мы и сделали грязь: сохранили адрес ячейки и изменили его после выхода из скоупа цикла и удаления переменной i. Так обычно и происходит на стеке: переменная кладется на стек, с ней работают, она удаляется при выходе из скоупа и потом другие объект занимают место удаленной переменной в памяти. Мы здесь сымитировали такой процесс. 

Так как вектор после выхода из скоупа цикла хранит висячие ссылки, то поведение в такой ситуации неопределено и наш грязный мув четко это показывает. После присваивания нового значения по указателю `p` все ссылки будут иметь то же самое значение. Хотя изначально такая ситуация вообще не предполагалась.

Будьте аккуратны со ссылками. В этом случае проще использовать какой-нибудь умный указатель. Все будет чинно и цивильно. И никакого UB.

Be careful. Stay cool.

#cpp11 #cppcore #STL 


Вектор констант

В прошлый раз мы рассмотрели вектор ссылок. А давайте чуть углубимся сюда и посмотрим, как будет себя вести вектор констант.

Константные объекты уже удовлетворяют требованию Erasable. Для них либо определен деструктор(пользовательские объекты), либо это константные тривиальные типы, которые тоже Erasable.

Казалось бы на этом можно закончить пост, можно создавать и ладно, много бубнить не нужно об этом. Но вот при использовании этой сущности могут возникать интересные эффекты.

```cpp
struct A {
	A(int num) : a{num} {}
	int a;
};

std::vector<const A> vec;

for (int i = 0; i < 5; i++) {
	vec.push_back(i);
}

for (int i = 0; i < 5; i++) {
	std::cout << vec[i].a << std::endl;
}
```

Ничего сверхъестественного. Просто создаем вектор, заполняем его и выводим. Что может пойти не так?

Это дело не соберется на методе push_back. Тип А - тривиально копируемый, что не допускается при вызове этого метода. Но как только мы добавим нетривиальный деструктор или конструктор копирования - все заработает нормально. Этот же факт значит, что для любых тривиальных типов вы не сможете добавлять так элементы в вектор констант. Не знаю, какие рассуждения лежат за этим, знающие могут оставить свои мысли в комментах.

Но это ладно. Дальше мы хотим поработать с этим вектором и, например, отсортировать его. 

```cpp
struct A {
	A(int num) : a{num} {}
	~A() {}
	int a;
};

std::vector<const A> vec;

for (int i = 0; i < 5; i++) {
	vec.push_back(i);
}

std::sort(vec.begin(), vec.end())
```

И тоже натыкаемся на ошибку компиляции. Внутри себя std::sort использует std::swap, которая меняет значения своих операндов inplace. Это значит, что мы должны иметь возможность присваивать объектам другие данные. А для константных объектов сделать это будет очень проблематично.

Метод erase также нерабочий из-за отсутствия возможности присваивания.

И хотя, интерфейс такого контейнера будет ограничен, мы все равно можем использовать читающие алгоритмы над ним. Например, подсчитывать какую-нибудь статистику по элементам. Также мы можем в рантайме свободно добавлять и удалять элементы из контейнера. Через emplace_back и pop_back. И это выгодно выделяет вектор констант на фоне константного вектора. Вы не хотите изменять сами элементы, но хотите иметь возможность изменять их множество и выполнять различные читающие операции над ним. Именно для этих задач и подходит вектор констант. Главное - аккуратнее с интерфейсом)

Be careful. Stay cool.

#cpp11 #STL


Переобуваемся

В прошлом посте я сказал, что лигитимно создавать вектор констант. Ну и конечно я не просто так написал весь этот пост от балды, все проверял на своей машинке. Хз, что в голове было у компилятора, но он пропускал вектор констант. Больше не буду полагаться на эту шайтан-машину. Да простит Бог его душу, а мы сейчас поправим то, что было написано вчера.

Нормальные компиляторы не соберут вам программу с вектором констант, потому что существуют ограничения, наложенные на аллокаторы. Вектор объявляется вот так:

```cpp
template<  
    class T,  
    class Allocator = std::allocator<T>  
> class vector;
```

Заметим, что шаблонный тип аллокатора совпадает с шаблонным типом элементов вектора. То есть мы будем инстанцировать аллокатор с тем же шаблонным параметром, что и элементы вектора.

А на все аллокаторы, которые могут работать со стандартной библиотекой, наложены ограничения. Одно из них гласит, что шаблонный параметр Т аллокатора должен быть cv-unqualified типом. То есть константные типы туда не входят.

Ну вот собственно и все. Сам контейнер здесь действительно не при чем, ограничения заложены в аллокатор. Спасибо Игорю за то, что подметил ошибку в посте. 

В том числе для таких ситуаций в нашем коммьюнити находятся крутые специалисты. Когда написание постов поставлено на поток, то ошибки неизбежны. Да они и в принципе неизбежны, мы тоже люди и многого не знаем. Иногда еще и инструментарий подводит. И это замечательно, что у нас в канале есть люди, которые вдумчиво читают посты и могут дать адекватную критику по фактам. От этого выигрывают все: критики экологично повышают свою значимость с своих глазах и глазах подписчиков, а в коммьюнити не пропускается ошибочная информация.

Не бойтесь делать ошибки, они уменьшают объем вашего незнания.

Make mistakes. Stay cool.

#cppcore

Фактор загрузки std:unordered_map
#новичкам 

Все мы знаем, как растет в размерах вектор с увеличением количества элементов. Может быть мы в конкретном случае не знаем мультипликатор увеличения вектора, но механизм мы понимаем.

Но например, неупорядоченная мапа - немного другой фрукт. За счет того, что мы сами можем предоставить свою хэш-функцию для нее, мы очень сильно можем влиять на поведение контейнера. Буквально все похерить плохим хэшом или сделать все по-красоте. Однако не всегда плохой хэш - действительно очень плохой. Может он и плохонький, но зато очень быстрый. Возможно, за счет этого будет много хэш-коллизий и появится проблема кластеризации. Но нам это может быть и не так важно, если у нас есть действительно быстрый хэш.

Таким образом мы реально влияет, если не на внутреннее устройство контейнера, то на тенденции фактического расположения элементов.

Такая возможность кастомизации должна идти вместе с влиянием на поведение мапы при увеличении размеров.

Да и просто может быть трейд офф между скоростью работы мапы и частотой реаллокаций. Если в вектор нельзя засунуть больше определенного числа элементов, то в мапу теоретически можно сколько угодно пихать. Если мы хотим скорость, то придется чаще реаллоцировать. И наоборот.

У вектора есть поле - capacity, которое говорит о том, сколько элементов может вмещать внутренний буффер. 

Мапа же за счет своей бакетной структуры может вмещать сколько угодно элементов. Но нам не хотелось бы прийти к ситуации, когда мапа вырождается в набор огромных связных списков. Поэтому для нее также должна быть какая-то эвристика, которая поможет предотвратить такую проблему и своевременно увеличивать размер внутренней хэш-таблицы.

```cpp
float load_factor() const;
```

Этот метод мапы возвращает ее фактор загрузки, который равен среднему числу элементов в одном бакете aka size() / bucket_count(). Эта та характеристика, которая определяет, когда мапа будет расширяться. Точнее не только она. Нужно же еще пороговое значение, при достижении которого произойдет расширение. А вот и оно.

```cpp
float max_load_factor() const;
void max_load_factor( float ml );
```

Максимальный фактор загрузки определяет максимальное среднее число элементов в бакетах, после достижения которого произойдет расширение хэш-таблицы.

И обратите внимание, что мы сами можем влиять на это значение!  Реализация безусловно предоставляет свое значение(скорее всего 1). Но с помощью экспериментов со своей хэш-функцией и кастомным лоад фактором, вы можете добиться по-настоящему желаемого поведения этого непростого контейнера.

Stay balanced. Stay cool.

#STL #cpcore 


Странный размер std::unordered_map
#опытным

Стандартная ситуация. Создаем контейнер, резервируем подходящий размер для ожидаемого количества элементов в коллекции и запихиваем элементы. Все просто. Но это с каким-нибудь вектором все просто. А хэш-мапа - дело нетривиальное. Смотрим на код:

```cpp
constexpr size_t map_size = 6;
std::unordered_map<int, int> mymap;
mymap.reserve(map_size);
for (int i = 0; i < map_size; i++) {
	mymap[i] = i;
}
std::cout << "mymap has " << mymap.bucket_count() << " buckets\n";
```

Все, как обычно. А теперь вывод: 

```
mymap has 7 buckets
```

WTF? Я же сказал выделить в мапе 6 бакетов, а не 7. Какой непослушный компилятор!

Вообще, поведение странное, но может там просто всегда +1 по какой-то причине?

Поменяем map_size на 9 и посмотрим вывод:

```cpp
mymap has 11 buckets
```

Again. WTF? Уже на 2 разница. Нужна новая гипотеза... Попробуем третье число. Возьмем 13.

```cpp
mymap has 13 buckets
```

А тут работает! Но это не прибавляет понимания проблемы... В чем же дело?

Из цппреференса про метод reserve:
```
**Request a capacity change**

Sets the number of buckets in the container (`bucket_count`) to the most appropriate to contain **at least** n elements.
```

То есть стандарт разрешает реализациям выделять больше элементов для мапы, чем мы запросили.

Легитимацию безобразия мы получили, но хотелось бы внятное объяснение причины предоставления такой возможности.

Реализации обычно выбирают bucket_count исходя из соображений быстродействия(как обычно). Тут они выбирают из двух опций:

1 Выбирают в качестве bucket_count степень двойки, то есть округляют до степени двойки в большую сторону. Это помогает эффективно маппить результат хэш функции на размер самой хэш-таблицы. Можно просто сделать битовое И и отбросить все биты, старше нашей степени. Что делается на один цикл цпу.

Но этот способ имеет негативный эффект в виде того же отбрасывания битов. То есть эти страшие биты никак не влияют на маппинг хэша на бакеты, то уменьшает равномерность распределения.

Таким способом пользуется Visual C++.

2 Поддерживают bucket_count простым числом. 

Это дает крутой эффект того, что старшие биты также влияют на распределение объектов по бакетам. В этом случае даже плохие хэш-функции имеют более равномерное размещение бакетов.

Однако наивная реализация такого подхода заставляет каждый раз делить на рантаймовое значение bucket_count, что может занимать до 100 раз больше циклов.
Более быстрой альтернативой может быть использование захардкоженой таблицы простых чисел. Индекс в ней выбирается на основе запрашиваемого значения bucket_count. Таким образом компилятор может заоптимизировать деление по модулю через битовые операции, сложения, вычитания и умножения. Можете посмотреть на эти оптимизации более подробно на [этом примере ](https://godbolt.org/z/K45cYE)в годболт.

Этой реализацией пользуется GCC и Clang.

Вот такие страсти происходят у нас под носом под капотом неупорядоченной мапы.

Optimize everything. Stay cool.

#STL #optimization #compiler


Правила константности
#новичкам 

Константность - важное свойство сущности в коде. Оно не только позволяет обезопасить объекты от изменения, но еще и говорит программисту о гарантиях, которые дает та или иная функция. Допустим, принимая параметр по константной ссылке, функция говорит программисту: "расслабься, ничего я не сделаю с твоим объектом". Это повышает читаемость кода.

В С++ много чего можно сделать константным. Объекты, указатели, ссылки, параметры функции, методы класса и тд. И зачастую новичкам сложно разобраться в правилах присваивания константности. Сегодня разберемся в этом.

Не будем долго задерживаться над константными методами. Константные объекты могут вызвать только константные методы. Все. Синтаксис такой:

```cpp
void Class::Method(Type1 param1, Type2 param2) const {}
```
Теперь и константные, и неконстантные объекты могут вызывать метод Method.

Дальше все так или иначе сводится к правилам в объявлении переменных. Что в качестве поля класса, параметра функции, что объявлении обычной переменной - разницы нет. Правила одни. Поехали.

Константный объект можно объявить двумя способами:

```cpp
const T obj;
// Либо
T const obj;
```

Это очень важно запомнить, потому что при разговоре о ссылках и указателях это  играет большую роль.

Собственно также есть 2 нотации объявления массивов констант:

```cpp
const T arr[5];
// либо
T const arr[5];
```

И 2 нотации определения ссылок:

```cpp
const T& ref;
// либо
T const & ref;
```

Помните, что при создании ссылки в скоупе функции вы обязаны ее инициализировать. 
При объявлении поля класса этого делать не обязательно, потому что вы не создаете объект прямо сейчас. Но вы обязаны инициализировать ссылку до входа в конструктор либо через список инициализации конструктора, либо через [default member initializer.](https://t.me/grokaemcpp/319), так как базового поля класса иницализируются до входа в конструктор. 
При объявлении параметра функции тоже не нужно сразу инициализировать ссылку, потому что функция принимает уже существующую и инициализированую ссылку на вход.

Обычно при таком объявлении ссылку называют константной. Это не совсем верно. Ссылка при любых обстоятельствах сама по себе является константной. Как только вы забиндили ссылку на объект, она всегда будет смотреть на этот объект и изменять его. Более подробно про особенности ссылок посмотреть [тут](https://t.me/grokaemcpp/9). При новом присваивании ссылки вызовется оператор присваивания и изменится существующий объект.

```cpp
struct Type {
	Type& operator=(const Type& other) { std::cout << "copy assign" << std::endl; return *this;}
};

Type a{};
Type& b = a;
b = Type{};
// OUTPUT:
// copy assign
```

Когда говорят "константная ссылка" имеют ввиду ссылку на константу. И при любом виде объявления const T& ref или T const & ref она также будет ссылкой на константу.

Теперь указатели. Наверное самое сложное из всего перечисленного. Указатели, в отличии от ссылок, сами могут быть константными, да еще и указывать на константные объекты. А еще могут быть многоуровненые указатели. В общем сложно. Но есть правило: при объявлении указателя каждое появление ключевого слова const относится к тому уровню вложенности, который находится слева от этого слова. Вы просто читаете объявление справа налево и получаете правильное понимание объявления. Примеры:

```cpp
// Читаем справа налево
int * const ptr; // ptr - это константный указатель на инт
int * * const ptr; // ptr - это константный указатель на указатель на инт
int * const * const ptr; // ptr - это константный указатель на константный укакатель на инт

// Самый низкий уровень, который относится к самому объекту, можно писать двумя способами, о которых мы говорили выше

int const * const * * const ptr; // ptr - это константный указатель на указатель на константный указатель на интовую константу
const int * const * * const ptr; // Тоже самое
```

Константные указатели нельзя изменять, то есть они указывают на один фиксированный участок памяти. Обычные указатели можно двигать в любую сторону операторами инкремента и декремента, переприсваивать на другую область памяти и так далее. 

Можно изменять сам указатель на константу, но при разыменовании этого указателя ничего нельзя менять в указываемом объекте.

Возьмем допустим const int * * const. Это константный указатель на указатель на константный инт. Два уровня индирекции. Это значит, что мы не можем никуда перенаправить верхний уровень указательности, но можем двигать второй уровень и только читать значения лежащих внутри чисел(потому что const int). Представьте себе, что где-то в памяти лежит матрица. Это набор указателей размером N, которые указывают на участки памяти, где лежат наборы интов размером M. Получается матрица NxM. Мы хотим смотреть только один столбец этой матрицы, поэтому фиксируем внешний указательный уровень. Когда мы разыменовываем этот внешний уровень, мы получаем второй указатель, который может ходить вперед и назад по конкретным ячейкам этого столбца. Но эти ячейки мы можем только читать, изменять их нам нельзя.

Если мы берем int * const * const, то мы фактически фиксируем адрес одной ячейки матрицы, но теперь можем через указатели изменять значение переменной, которая в ней содержится

Думаю, что так должно быть понятно, что такое вложенные константные указатели и что с ними можно делать. А также вообще как отражается на объектах слово const.

Rely on fixed thing in your life. Stay cool.

#cppcore 



Виртуальный конструктор
#новичкам

Виртуальные методы - это основа полиморфизма, одного из важнейших концептов объектно-ориентированного программирования, который позволяет нам реализовывать сложные конструкции из классов и строить гибкую-расширяемую архитектуру. Но вот если на секунду задуматься: конструктор - это ведь тоже метод. Можем ли мы сделать конструктор класса виртуальным?

Один из тех самых популярных вопросов на собеседованиях, который не проверяет никаких практически применимых знаний. Он скорее направлен больше на понимание концепции ООП и механизма создания объектов в С++.

Ответ: нет, не можем. Логика тут довольно простая. Виртуальные функции подразумевают собой позднее связывание объекта и вызываемого метода в рантайме. То есть для них нужны объекты(точнее vptr, которых находится внутри них). А объекты создаются в рантайме. И для создания объектов нужны констукторы. Получается, если бы конструкторы были виртуальными, то ~~собака постоянно гналась бы укусить себя за жёпу~~ получился бы цикл и парадокс(фанатам Шарифова посвящается). Нет указателя на виртуальную таблицу - нет виртуальности.

Если более формально и официально, то вот комментарий самого Бъерна по этому вопросу:

```
A virtual call is a mechanism to get 
work done given partial information. 
In particular, "virtual" allows us to 
call a function knowing only an interfaces 
and not the exact type of the object. 
To create an object you need complete 
information. In particular, you need to 
know the exact type of what you want to 
create. Consequently, a 
"call to a constructor" cannot be virtual.
```

Виртуальный вызов — это механизм выполнения работы при наличии частичной информации. В частности, «виртуальный» позволяет нам вызывать функцию, зная только тип базового класса, а не точный тип объекта. Для создания объекта необходима полная информация. В частности, вам необходимо знать точный тип того, что вы хотите создать. Следовательно, «вызов конструктора» не может быть виртуальным.

Однако, нам по сути этого и не нужно. Нам нужен механизм создания объекта, зависящий от типа полиморфного объекта. И у нас такой механизм есть! Называется он фабричным методом. В ту же степь идет и паттерн "метод clone()". 

В сущности, фабричный метод позволяет создавать объекты, тип которых зависит от типа объекта, у которого вызывается метод.

Метод clone позволяет создавать объекты именно того класса, который на самом деле лежит под данным указателем или ссылкой.

Выглядит это так:

```cpp
class Shape {
  public:
    virtual ~Shape() { } // A virtual destructor
    // ...
    virtual std::unique_ptr<Shape> clone() const = 0; // Uses the copy constructor
    virtual std::unique_ptr<Shape> create() const = 0; // Uses the default constructor
};
class Circle : public Shape {
  public:
    std::unique_ptr<Shape> clone() const override;
    std::unique_ptr<Shape> create() const override;
    // ...
};
std::unique_ptr<Shape> Circle::clone() const { return new Circle(*this); }
std::unique_ptr<Shape> Circle::create() const { return new Circle(); }
```

У класса Фигура есть метод clone, который позволяет скопировать текущий объект в новый объект. Метод create позволяет дефолтно создать объект того же класса.

В класса Circle эти методы переопределяются. Теперь можно не зная точного типа полиморфного объекта вызвать его конструктор по умолчанию и копирования.

```cpp
std::unique_ptr<Shape> ptr = std::make_unique<Circle>();

auto new_obj = ptr->create();

auto copy_obj = ptr->copy();
```

В эти методы также можно добавить аргументов, в том числе и полиморфных типов. Главное, чтобы сигнатуры методов в наследниках и базе совпадали.

Можете кстати порассуждать в комментах, как бы выглядели виртуальные конструкторы и код, который бы их использовал.

Use well-known tools for your task. Stay cool.

#interview #cppcore #pattern 


Ковариантные возвращаемые типы

Есть такое интересное понятие, о котором вы возможно ни разу не слышали. Пример из поста выше с методами clone и create можно было написать иначе:

```cpp
class Shape {
  public:
    virtual ~Shape() { } // A virtual destructor
    // ...
    virtual Shape* clone() const = 0; // Uses the copy constructor
    virtual Shape* create() const = 0; // Uses the default constructor
};
class Circle : public Shape {
  public:
    Circle* clone() const override;
    Circle* create() const override;
    // ...
};
Circle* Circle::clone() const { return new Circle(*this); }
Circle* Circle::create() const { return new Circle(); }
```

Вы скажете: "Сигнатуры не совпадают! Код не скомпилируется!". 

А я скажу: "Shape и Circle - ковариантные типы". С++ разрешает наследнику переопределять методы с возвращаемым типом, который является наследником типа метода из базового класса. Говорят, что это даже называется идиомой С++.

Какие юзкейсы у этой идиомы? По факту всего один. Представьте, что все методы возвращают один тип Shape. Вы создали объект Circle в куче и присвоили указатель на него к указателю на Circle. Тогда при клонировании объекта Circle вам вернется указатель на объект базового класса. И по хорошему его надо динамик кастить к Circle, чтобы работать с конкретным типом наследника. А это оверхэд:

```cpp
Circle *circle1 = new Circle();
Shape *shape = d1->clone();
Circle *circle2 = dynamic_cast<Circle *>(shape);
if(circle2) {
  // Use circle2 here.
}
```

Выглядит не очень. Посмотрим, как изменится код, если методы Circle будут возвращать указатель на Circle:

```cpp
Circle *circle1 = new Circle();
Circle *circle2 = d1->clone();
```

Выглядит намного лучше. Но вот вопрос: почему вы нигде не увидите в коде применения ковариантных типов?

Потому что этот подход не работает с умными указателями, которые де факто являются стандартом при возвращении объектов из фабрик. std::unique_ptr\<Circle> не является наследником std::unique_ptr\<Shape>, поэтому они и не ковариантные типы и сигнатуры методов будут несовместимы.

Возвращение сырых указателей - супер bad practice, один только этот факт заставляет отказаться от такого подхода.

Тем более полиморфные объекты и придумали для того, чтобы использовать их полиморфно. То есть через ссылку или указатель на базовый класс. Зачем оперировать полиморфным объектом с указателем на конкретный тип - не очень понятно.

Раньше, до изобретения умных указателей, идиома была легитимна. Теперь же она отправилась на свалку истории.

Только что вы прочитали очередную статью про совсем ненужную хрень. Ставьте (каменное лицо), если ваше лицо сейчас на него похоже)

Stay poker-faced. Stay cool.

#fun #cppcore


nullptr

Вероятно, каждый, кто писал код на C++03, имел удовольствие использовать NULL и постоянно ударяться мизинцем ноги об этот острый уголок тумбочки. Дело в том, что NULL использовался, как обозначение нулевого указателя, который никуда не указывает. Но если он для этого использовался - это не значит, что он таковым и являлся. Да и являлся он котом в мешке. Это макрос, который мог быть определен как `0` aka int zero или `0L` aka zero long int, но всегда это вариация интегрального нуля. И уже эти чиселки могли быть приведены к типу указателя.

Вот в этом-то и вся проблема. NULL очень явно хочет себя видеть в виде указателя, но по факту в зеркале видит число. Допустим, у нас есть 2 перегрузки одной функции: одна для инта, вторая для указателя:

```cpp
class Spell { /* ... */ };

void castSpell(Spell* theSpell);
void castSpell(int spellID);

int main() {
  castSpell(NULL);
}
```

Намерения ясны: мы хотим вызвать перегрузку для указателя. Но это гарантировано не произойдет! В произойдет один из двух сценариев: если NULL определен как `0`, то просто без объявления войны в 4 часа утра вызовется вторая перегрузка. Если как `0L`, то компилятор поругается на неоднозначный вызов: 0L может быть одинаково хорошо сконвертирован и в инт, и в указатель.

Проблему можно решить енамами и передавать для нулевого spellID что-то типа NoSpell. Но надо опять городить огород. Почему все не работает из коробки?!

С приходом С++11 начало работать из коробки. Надо только забыть про NULL и использовать nullptr. 

Ключевое слово nullptr обозначает литерал указателя. Это prvalue типа std::nullptr_t. И nullptr неявно приводится к нулевому значению указателя для любого типа указателя. Это объект отдельного типа, который теперь к простому инту не приводится.

Поэтому сейчас этот код отработает как надо:

```cpp
class Spell { /* ... */ };

void castSpell(Spell* theSpell);
void castSpell(int spellID);

int main() {
  castSpell(nullptr);
}
```


Так как nullptr - значение конкретного типа std::nullptr_t, то мы может принимать в функции непосредственно этот тип, а не общий тип указателя. Такая штука используется, например, в реализации std::function, конструктор которого имеет перегрузку для std::nullptr_t и делает тоже самое, что и конструктор без аргументов.

```cpp
/**
*  @brief Default construct creates an empty function call wrapper.
*  @post `!(bool)*this`
*/
function() noexcept
: _Function_base() { }

/**
*  @brief Creates an empty function call wrapper.
*  @post @c !(bool)*this
*/
function(nullptr_t) noexcept
: _Function_base() { }
```

По той же причине nullptr даже при возврате через функцию может быть приведен к типу указателя. А вот обычные null pointer константны не могут похвастаться таким свойством. Они могут приводиться к указателям только в виде литералов.

```cpp
template<class T>
constexpr T clone(const T& t)
{
    return t;
}
 
void g(int*)
{
    std::cout << "Function g called\n";
}
 
int main()
{
    g(nullptr);        // Fine
    g(NULL)            // Fine
    g(0);              // Fine
 
    g(clone(nullptr)); // Fine
//  g(clone(NULL));    // ERROR: non-literal zero cannot be a null pointer constant
//  g(clone(0));       // ERROR: non-literal zero cannot be a null pointer constant
}
```

clone(nullptr) вернет тот же nullptr и все будет работать гладко. А для 0 и NULL функция вернет просто int, который сам по себе неявно не конвертится в указатель.

Думаю, что вы все и так пользуете nullptr, но этот пост обязан быть на канале.

Как говорится "Use nullptr instead of NULL, 0 or any other null pointer constant, wherever you need a generic null pointer."

Be a separate subject. Stay cool.

#cppcore #cpp11

Присвоение лямбды
#новичкам 

Изучение лямбда выражений - не самая простая задача для начинающего плюсовика. Сложные термины, какие-то замыкания, списки захвата и прочее. В общем, непросто. И с виду можно подумать, что 2 одинаковые лямбды можно присваивать друг другу с легкостью. То есть может показаться, что такой код валидный:

```cpp
int main() {
  auto test = [](){};
  test = [](){};
    
  return 0;
}
```

Однако он генерирует примерно следующую ошибку:

```cpp
In function ‘int main()’:
error: no match for ‘operator=’ in ‘test = <lambda closure object>main()::<lambda()>{}’
note: candidate is:
note: main()::<lambda()>& main()::<lambda()>::operator=(const main()::<lambda()>&) <deleted>
no known conversion for argument 1 from ‘main()::<lambda()>’ to ‘const main()::<lambda()>&’
```

Не нашел нужного оператора присваивания.

Да и вообще, это ж все лямбды, почему я не могу их присваивать друг другу?

Дело в том, что каждое отдельное лямбда-выражение генерирует свой тип, который называется замыканием. Только компилятор знает этот тип, вы его наружу никак не можете получить. Стандарт говорит:

```
The type of the lambda-expression [...] is a unique, unnamed non-union class type — called the closure type.
```

Это легко проверить. Такой код выведет 0:

```cpp
auto test = [](){};
auto test2 = [](){};
std::cout << std::is_same_v<decltype( test ), decltype( test2 )> << std::endl;
```

Типы действительно разные.

В целом, поэтому вместе с лямбдами всегда нужно использовать auto. Потому что ничего другого вы вместо типа физически не сможете написать. Но компилятор знает тип замыкания и сможет вывести правильный тип для переменной.

Ну и естественно, для двух рандомных классов неопределены операторы присваивания своих объектов друг другу. Поэтому код из начала и фейлится.

Differentiate thing apart. Stay cool.

#cpp11



Квиз

Мы с вами недавно коснулись темы лямбд, поэтому вдогонку устроим #quiz по этой теме. Как всегда, тут нужно либо хорошее знание стандарта, либо хорошая интуиция.

Какой результат попытки компиляции(с одним флагом указания стандарта С++20) и выполнения этого кода:

```cpp
int main() {
  auto test = +[]{};
  test = []{};
    
  return 0;
}
```

Ошибка компиляции

Ошибка линковки

Segmentation fault

Программа успешно завершится

А это на каком языке вообще??


Магическое заклинание +[]{}

Правильный ответ на квиз - программа успешно завершится. Удивились? Погнали разбирать

Давайте сразу проясним, что лямбду можно записывать без списка параметров, это разрешенная тема. Да и работает это в целом довольно интуитивно: если ваша лямбда не принимает параметров, то вы можете их не указывать и все будет работать также, как и с пустыми круглыми скобками.

Дальше

Здесь(ССЫЛКА) мы рассматривали, что присвоение лямбд запрещено и приводит к ошибке компиляции. Каким образом один + переворачивает все сверх на голову и код работает?

Стандарт нам говорит:

```
The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type's function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type's function call operator.
```

То есть ламбды без захваченых значений имеют возможность прикидываться указателями на функции.

И так вышло, что оператор+ определен для всех типов указателей в виде:

```
For every type `T` there exist candidate operator functions of the form

    `T* operator+(T*);`
```
Он ничего не делает с указателем и просто его возвращает наружу.

Когда мы ставим + спереди лямбды, компилятор пытается найти подходящую перегрузку для оператора+. Логично, что для любого замыкания он не перегружен, поэтому что он не нужен там. Но зато есть перегрузка для указателя, под который может косить лямбда. Что она успешно и делает.

Поэтому для test компилятор выведет тип указателя на функцию, а не замыкания. И ничего нам не мешает перенаправлять этот указатель на другую функцию.

Снова один бессысленный плюс тащит катку.

Stay amazed. Stay cool.

#cpp11 #cppcore

Квиз

Сегодня будет довольно противоречивый #quiz.  Ничего не буду говорить. Просто задам вопрос. А подробный ответ будет вечером.

Какой результат попытки компиляции и выполнения этого кода:

```cpp
#include <algorithm>

struct foo {
	static const int qwerty = 100;
};

int main() {
	std::cout << std::max(0, foo::qwerty) << std::endl;
	return 0;
}
```

Ошибка компиляции

Ошибка линковки

Segmentation fault

0

100


Ответ

Несмотря на всю простоту и краткость кода, он не запустится! Будет ошибка линковки undefined reference to foo::qwerty.

Как такое возможно, если мы четко определили статическое поле qwerty?

Обратимся к стандарту:

```
If a non-volatile non-inline const static data member is of integral or enumeration type, its declaration in the class definition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression is a constant expression.

The member shall still be defined in a namespace scope if it is odr-used in the program and the namespace scope definition shall not contain an initializer
```


Мы хоть и можем указывать инициализатор для константного статического интегрального поля, но это скорее что-то типа маркера инициализации. То есть именно с этим инициализатором будет определяться поле.

Но этот маркет не является определением! Оно все равно нужно, так как foo::qwerty odr-использована. Один из маркетов того, что переменная odr-используется - на нее ссылается ссылка.

Так вот функция std::max принимает константные ссылки на объекты. А передаем мы в нее lvalue. Значит у этого lvalue должен быть существующий адрес, чтобы нормально забиндится на ссылку. 

Вот и получается порочная цепочка: чтобы забиндится на ссылку нам нужен адрес -> адрес глобальная переменная получает только если у нее есть определение -> так как мы используем ссылку на статическое поле класса нам нужно его определение -> мы его не предоставили -> получили по рукам от линкера.

Чтобы избежать ошибки можно использовать 3 стратегии:

1 Честно предоставить определение, согласно стандарту, без инициализатора.

```cpp
struct foo {
	static const int qwerty = 100;
};
const int foo::qwerty;
```

2 Использовать ключевое слово inline, которое, начиная с С++17, позволяет определять поля внутри описания класса.

```cpp
struct foo {
	inline static const int qwerty = 100;
};
```

3 Вместо const использовать ключевое слово constexpr. Это фактически сразу делает qwerty компайл тайм константой, которая должна быть инициализирована при объявлении и к которой спокойно можно обращаться в том числе и по ссылке.

```cpp
struct foo {
	static constexpr int qwerty = 100;
};
```

Вот такое тонкое место есть в С++)

Surprise everyone. Stay cool.

#cppcore #cpp17 

Один плюс решает все

Вчера мы рассматривали такой код и он фейлился при линковке:

```cpp
#include <algorithm>

struct foo {
	static const int qwerty = 100;
};

int main() {
	std::cout << std::max(0, foo::qwerty) << std::endl;
	return 0;
}
```

Но стоит нам добавить всего лишь + к имени переменной foo::qwerty и код сразу же начнет компилироваться и выдавать ожидаемый результат.

```cpp
int main() {
	std::cout << std::max(0, +foo::qwerty) << std::endl;
	return 0;
}
```

Почему?

Для интов определено унарный оперетор +, который возвращает временное значение. Он не реализован в рамках обычных функций С++ и компилятор может как угодно его оптимизировать, но главное, что нам нужно знать - компилятор рассматривает это как новое rvalue значение. Которое может кастится к константной ссылке. А так как оригинальная переменная foo::qwerty теперь не odr-used(от нее больше не берут ссылку), то и компилятору не нужно больше определение. Он прекрасно видит значение инициализатора и может просто подставить на место foo::qwerty значение его инициализатора.

Прикол в том, что оптимизации компилятора могут помочь вам угомонить линкер. Однако это вообще не значит, что в программе все хорошо. Вы по прежнему должны определить это статическое поле, чтобы использовать переменную  согласно стандарту, чтобы его можно было использовать во всех сценариях.

Focus on positive. Stay cool.

#cppcore


