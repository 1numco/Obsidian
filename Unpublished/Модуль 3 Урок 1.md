
Вступление

В этом уроке вы:

- Узнаете о конкретных недостатках C-style массивов
- Поймете особенности реализации контейнеров std::array и std::inplace_vector и  как они решают проблемы сишных массивов
 С++ предоставляет возможность писать программы на более высоком уровне. И стандартная библиотека С++ предоставляет намного более удобные и безопасные альтернативы C-style массивам: std::array и std::inplace_vector.







Проблемы С-style массивов
#опытным

В наследство от языка С С++ достались статические массивы. Так называемые С-style массивы. Это проверенные средства языка, успешно решающие свои задачи. Но у них есть серьезные недостатки, которые в основном связаны с низкоуровневостью этого инструмента.

Давайте кратко повторим, что такое C-style массив. 

Это непрерывная последовательность элементов одного типа и память под них выделяется на стеке и автоматически освобождается при выходе из функции.

Определяется сишный массив вот так:

```cpp
int arr1[5]; // создаем массив на 5 элементов, которые по умолчанию инициализируются нулями

int arr2[] = {1, 2, 3, 4, 5}; // создаем массив и предоставляем набор элементов, с помощью которых компилятор вычисляет длину массива и инициализирует элементы
```

Размер памяти, занимаемый массивом равняется количеству его элементов помноженному на размер типа данных:

```cpp
constexpr size_t array_size = 5;
int arr[array_size];
sizeof(arr) == array_size * sizeof(int); // true
```

Соответственно, для получения количества элементов массива, нужно поделить sizeof от массива на размер типа данных, которые он хранит.

```cpp
auto array_size = sizeof(arr) / sizeof(Type);
```

В чем же его недостатки?

- массивы нельзя сравнивать напрямую, а только поэлементно. Напрямую сравниваются указатели на первый элемент.
```cpp
int arr1[] = {0, 1, 2, 3};
int arr2[] = {0, 1, 2, 3};
arr1 == arr2; // ложь так как сраниваются указатели, а они разные для разных объектов
```
- мимикрирование под массивы разрешает странную семантику с условиями и арифметическими операциями.
```cpp
char arr[] = ""; // создаем пустую строку в виде массива
if (arr); // условие будет всегда true, хотя мы создали пустую строку
arr + 1; // разрешается, но зачем?
```
- в С разрешены [массивы переменной длины](https://t.me/grokaemcpp/56) на уровне стандарта. И синтаксис у них ровно такой же, как и у статических массивов, только при его создании размер указывается не константой, а переменной. В С++ это не стандартная фича, а расширения компилятора. То есть нельзя писать кроссплатформенный код с использованием массивов переменной длины. Но за счет идентичного синтаксиса очень легко спутать один вид массива с другим и похерить переменосимость.

- от синтаксиса сочетания функций и массивов хочется вырвать себе глаза:
```cpp
int foo(int arr[4]); // На самом деле такая сигнатура полностью эквивалентна int sum_edges(int * arr), что позволяет принимать в функцию массив любой длины и указатели. В С++ нет синтаксиса приема массива по значению

void foo(int (&arr)[4]); // зато есть синтаксис приема массива по ссылке

// Нормального синтаксиса для возврата массива из функции также не завезли. Вот воркэраунды.
int get_array()[10];
auto get_array() -> int[10];
```
- Массив не инкапсулирует в себе свой размер. Его нужно всегда вычислять, как мы говорили в начале урока.
- Из-за сложности синтаксиса, вы скорее всего захотите обрабатывать массивы с помощью функций с похожей сигнатурой:

```cpp
void foo(int * p, size_t size);
```

Это потенциально может привести к доступу за границы выделенной области, так как функция foo ничего не знает про то, какой реальный размер имеет область памяти, на которую указывает `p`. Она должна доверять программисту и переданному значению size. А программисту не всегда нужно верить...

В общем, сишные массивы - это не объекты и не обладают преимуществами ООП и универсальной семантики для объектов в С++.

Поэтому стандартная библиотека предоставляет нам инструмент, который решает все проблемы C-style массивов. Это контейнер std::array. О нем мы поговорим в следующий раз.

Upgrade your tools. Stay cool.

#cppcore #goodoldc



std::array
#новичкам

На самом деле, это очень-очень тонкая обертка над сишными массивами. Вот несколько упрощенная реализация, которая тем не менее полностью передает смысл и необходимые особенности.

```cpp
template<typename T, size_t N>
struct array
{
	T& operator[](size_t index) {
		return _data[index];
	}
	T& front() {
		return _data[0];
	}
	T& back() {
		return _data[N];
	}
	T* data() {
		return _data;
	}
	size_t size() const {
		return N;
	}
	bool empty() const {
		return N == 0;
	}
// еще const версии перечисленных методов и некоторые другие методы и алиасы типов
private:
	T _data[N];
};
```

За счет использования шаблоного типа нижележащего массива std::array может работать с любыми встроенными и кастомными типами. 

А за счет нетипового шаблонного аргумента N, std::array знает количество элементов, которое в нем находится. И не нужно ничего вычислять! Достаточно вызвать метод size().

Обычно удобство абстракций идет вместе с платой за это удобство. Но это не тот случай. За счет того, что все методы std::array буквально занимают одну строчку, компилятору очень удобно инлайнить их код в caller'ов. Это приводит к тому, что низкоуровневый ассемблерный код при работе с C-style массивами и std::array практически всегда идентичен.

std::array не мимикрирует ни под какой другой тип, так как это кастомный класс. Внутри себя он также инкапсулирует все необходимые операторы сравнения. В операциях с ним нет никакой путаницы, потому что они явно определены конкретно для этого класса. Его можно спокойно принимать в функцию по ссылке и по значению, а также указывать в качестве возвращаемого значения. И все это с привычной семантикой.

```cpp
template<typename T, size_t N>
std::array<T, N> double_elements(std::array<T, N>& array) {
	std::array<T, N> result = array;
	for (auto& elem: result)
		elem = elem * 2;
	return result;
}
```

Если мы создаем массив в локальной области функции(99.9% случаев), то элементы std::array располагаются непрерывно на стеке. И размер std::array равен размеру C-style массива с одинаковым количеством элементов и их типом.

```cpp
int c_arr[N]; // произвольное N
std::arrray<int, N>  cpp_arr;
sizeof(cpp_arr) == cpp_arr.size() * sizeof(int) == sizeof(c_arr) == N * sizeof(int); // условия попарно равны
```

За счет того, что все элементы располагаются на стеке, то доступ к ним можно получить с помощью обычного отступа от начала стекового фрейма. Это само по себе быстрее, чем получать доступ к памяти по указателю. Так еще и кэшом локальные переменные дружат лучше.

Итак. Выходит, что std::array идентичен сишному массиву по внутреннему устройству и произодительности, да еще и решает все проблемы последнего. Идеальный инструмент!

Так что std::array должен быть первым выбором в случае необходимости создания массива с длиной, известной на этапе компиляции.

Fix your flaws. Stay cool.

#STL #cppcore




