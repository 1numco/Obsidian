
Неименованные параметры функций

С++ позволяет не указывать имена параметров функций, если они не используются в коде.

```cpp
void foo(int /*no name here*/);

void foo(int /*no name here*/)
{
	std::cout << "foo" << std::endl;
}

foo(5);
```

Это можно делать и в объявлении функции, и в ее определении.

Важный момент, что отсутствие имени параметра не говорит о том, что параметра нет и его не нужно передавать. Для вызова такой функции вы должны передать в нее аргумент соответствующего типа. Даже если он ничего не делает полезного.

Но вот вопрос возникает тогда. Если параметр ничего не делает, нахрена он тогда вообще нужен?

На самом деле много кейсов, где неименованный параметр может пригодится.

1 Допустим, у вас есть функция, которая используется в очень многих местах кода, может даже через какие-нибудь указатели на функцию. И один момент времени часть функционала стала ненужной и один или несколько параметров стали ненужны. Править все вызовы этой функции было бы болью, особенно если туда вовлечены function поинтеры. Вместо этого вы можете сделать эти параметры безымянными, чтобы явно в коде показать, что этот параметр не используется. Его и нельзя даже будет использовать. 

2 Заглушки. Зачастую для тестирования функциональности применяют сущности-болванки, которые внешне ведут себя, как нормальные ребята, но на самом деле они лодыри и ничего путного не делают. Это нужно для мокания соседних модулей, чтобы протестировать только функциональность выбранного набора модулей. Такие заглушки должны выглядеть подобающе, то есть полностью повторять апи замоканой сущности, но могут не делать никакой полезной работы. Поэтому можно в этом апи сделать безымянные параметры, чтобы еще раз подчеркнуть, что они не используются.

3 Иногда существующие сущности в коде требуют коллбэки определенного вида. И вам в своем коллбэке возможно не нужно использовать весь набор параметров. Но для соблюдения апи вы должны их указать в сигнатуре своего обратного вызова. В этом случае можно сделать эти параметры безымянными.

4 Иногда в иерархии полиморфных классов в конкретном наследнике вам не нужны все параметры виртуальной функции. Но для поддержания корректности переопределения виртуального интерфейса вы должны включить все параметры в сигнатуру метода. Опять же, неиспользуемые параметры можно пометить безымянными.

5 Знаменитая перегрузка постфиксного оператора инкремента/декремента. Есть 2 вида этих операторов: префикстный и постфиксный. Проблема в том, что это все еще вызов функции operator++. Как различить реализации этих фукнкций? Правильно, нужна перегрузка. Вот здесь и приходит на помощь безымянный параметр: в коде он не нужен, но влияет на выбор конкретной перегрузки. Выглядит это так:

```cpp
struct Digit
{
    Digit(int digit=0) : m_digit{digit} {}
    Digit& operator++(); // prefix has no parameter
    Digit operator++(int); // postfix has an int parameter
private:
    int m_digit{};
};
```

В целом, эта фича нужна либо для соблюдения существующего апи, либо для того, чтобы при вызове функции гарантировано вызвалась правильная перегрузка.

Stay useful. Stay cool.

#cppcore #design

Различаем преинкремент и постинкремент
#новичкам 

Новичкам всегда не просто даются перегрузки операторов. Не то, чтобы кому-то часто приходится перегружать операторы инкремента/декремента. Но это особенный случай. Поэтому этот пост обязан быть на канале.

Есть операторы инкремента и декремента. Первые увеличивают значение, вторые - уменьшаю. Они подразделяются на 2 формы: пре- и пост-. Далее будем все разбирать на примере операторов инкремента, для декремента все аналогично, только меняете плюс на минус.

Преинкремент - увеличивает значение на единицу и возвращает ссылку на уже увеличенное значение. Синтаксис использования такой: `++value`.

Постинкремент - делает копию исходного числа, увеличивает на единицу оригинал, и возвращает копию по значению. Синтаксис использования такой: `value++`.

Обычно внешний вид перегрузки операторов внутри описания класса такой:

`возвращаемое_значение operator{символы_вызова_оператора}(аргументы)`.

Например, оператор копирования вызывается с помощью оператора присваивания(=). Поэтому подставляем в шаблон на место `возвращаемое_значение` ссылку на объект, на место `символы_вызова_оператора` подставляем =, на место аргументов - const Type&. Получается так:

```cpp
Type& operator=(const Type&);
```

Но теперь возникает вопрос. С++ не различает функции, у которых то же имя, то же те же аргументы, но разные возвращаемые значения. У нас как раз такая ситуация: названия одинаковые(operator++), возвращаемые значения разные(в одном случае возвращаем по ссылке, во втором - по значению) и одинаково отсутствуют аргументы. Если бы мы определили операторы так:

```cpp
Type& operator++() {
	value_ += 1;
	return *this;
}

Type operator++() {
	auto tmp_value = *this;
	value_ += 1;
	return tmp_value;
}
```

То была бы примерно такая ошибка компиляции: `functions that differ only in their return type cannot be overloaded`.

Что же делать?

Примерно таким же вопросом задался Страуструп и сделал ход конем(правда конь ходил на костылях). Он связал префиксный оператор с человеческой формой объявления, а постфиксный - с вот такой:

```cpp
Type operator++(int) {
	auto tmp_value = *this;
	value_ += 1;
	return tmp_value;
}
```

Он ввел безымянный интовый параметр функции. Теперь чисто технически, компилятор сможет различить 2 вызова этих операторов и правильно заметчить эти вызовы на нужные определения.

Если видит префикс - выбирает оператор без аргумента, видит постфикс - выбирает с аргументом. 

Вопрос, почему тип аргумента именно int - остается открытым. Наверное так было проще.

Итого, так перегружаются операторы инкремента:

```cpp
struct Type {
	Type& operator++() {
		value_ += 1;
		return *this;
	}
	
	Type operator++(int) {
		auto tmp_value = *this;
		value_ += 1;
		return tmp_value;
	}
private:
	IntegerLikeType value_;
};

```

Think of your decisions twice. Stay cool.

#cppcore 



Ну ладно, еще немного про эти операторы. Переиспользование кода - вещь хорошая. Поэтому принято перегружать постфиксный оператор через префиксный. Делается это так:

```cpp
struct Type {
	Type& operator++() {
		value_ += 1;
		return *this;
	}
	
	Type operator++(int) {
		auto tmp_value = *this;
		++*this; // Attention here!
		return tmp_value;
	}
private:
	IntegerLikeType value_;
};
```

Этот же прием иногда используют, чтобы реализовать пару методов: константный и неконстантный. Реализуют логику неконстантного метода. и через него имплементируют соседа.

Например, так можно сделать с каким-нибудь геттером. Оператор[] возвращает элемент по какому-то ключу. Для неконстантного объекта имеет смысл получать ссылку на внутренний элемент, чтобы иметь возможность его изменять. А для константного - получать копию. Делаем так:

```cpp
struct MyVector {
	int& operator[](size_t i) {
		return data_[i];
	}
	int operator[](size_t i) const {
		return (*this)[i];
	}
private:
	std::vector<int> data_;
};
```

Примеры довольно игрушечные. Но, когда у вас неконстантный метод довольно большой, то совсем не хочется эту логику повторять в const версии.

Don't repeat yourself. Stay cool.

#cppcore #goodpractice 



Почему перегрузки не могут иметь разные возвращаемые значения
#новичкам 

Обычно люди просто принимают это на веру. Впрочем, как и все, что вливается в голову в начале обучения. 

Но никогда не поздно задуматься над смыслом. А почему перегрузки не могут иметь разные возвращаемые значения?

Может вот так абстрактно рассуждая, и не сразу придет ответ. Но на самом деле все просто, если посмотреть на конкретный пример. Давайте представим, что этого запрета нет и у нас есть 2 функции, которые очень хотят быть перегрузками, но имеют разные возвращаемые значения.

```cpp
int GetRandomNumber();
float GetRandomNumber();
```

Пускай мы хотим генерировать и целые числа, и дробные числа. И то, и то число, общее название оправдано.

Теперь попробуем вызвать первую версию.

```cpp
int number = GetRandomNumber();
```

А вы уверены, что мы сейчас вызвали именно первую версию? Флоат спокойно кастуется к инту. Ничего не мешает компилятору выбрать вторую версию для этого вызова.

Ситуация становится комичной, если использовать auto:

```cpp
auto number = GetRandomNumber();
```

Тут как бы вообще нет ни намека на то, какую версию вызывать. Компилятор не умеет читать ваши мысли и намерения. Он не знает, какую версию вы хотели вызвать. Просто рандомно он выбрать не может. Появляется парадокс и вселенная схлопывается.

Вот и получили противоречие.

Компилятор просто не может отличить вызовы таких функций. Поэтому это и запрещено.

Don't be confusing. Stay cool.

#cppcore 




Достаем элемент из последовательного контейнера

Обработка ошибок, да и в принципе нежелательных путей развития ситуации, может порождать много споров, боли, баттхерта и, возможно, вызывать глобальное потепление. А ее отсутствие может порождать много багов. И вот один из интересных кейсов, на который все не обращают внимание и, при этом, все пользуются этой функциональностью.

Я говорю о попе элементов. Не вот этой ( | ), а вот этом

```cpp
void pop_back();

void pop_front();
```

Эти методы достают из контейнера элементы из зада или из переда соответственно.

"Какие тут проблемы?" - спросите вы.

И я вам отвечу.

Что произойдет, если я вызову эти методы на пустом контейнере? Если вы задумались, то это нормально, обычно такого не происходит. Но вот я такой Маша-растеряша и забыл проверить на пустоту перед вызовом. Будет UB.

Даже не исключение, которое можно обработать. Просто УБ. И можно УБиться в поисках бага, которая появится в следствии пропуска одной проверки.

Понятно, что так или иначе придется городить огород вокруг подобных моментов, когда что-то может пойти не так. Проблема конкретно этого кейса, что из сигнатура метода настолько безобидная, что даже и мысли не возникает, что может что-то не так пойти. А внезапно может прилететь по башке лопатой.

Туда же идут и методы front() и back(). Они дают такое же UB, когда контейнер пуст.

Почему так сложилось? Вопрос сложный.

Но не в этом суть.

Суть в том, что не нужно делать похожий интерфейс у своих классов. Давайте пользователю сразу понять, что в функции может что-то пойти не так и эту ситуацию надо обработать.

Споры о дизайне - горячо любимый всеми процесс. Каждый может решать этот вопрос по-разному. 

Но пжлст. Не плодите UB. Если есть возможность его обойти во всех случаях - это надо сделать.

Даже что-то подобное, на мой взгляд, куда более безопасный дизайн:

```cpp
bool pop_back() {
	if (data_.empty()) {
		return false;
	}
	// remove element
	return true;
}
```

А если его еще и [аттрибутом nodiscard](https://t.me/grokaemcpp/54) пометить, будет вообще щикарно(привет фанатам южного парка).

Может это и не лучшее решение для стандартной библиотеки. Вполне представляю, что это все бред и комитет лучше знает. 

Но язык С++ никогда не славился своей безопасностью. И если вы можете своими силами обезопасить свой проект - нужно это делать. Даже таким несовершенным образом.

Stay safe. Stay cool.

#cppcore #STL


Опасности автоматического вывода типов

C++17 дал нам замечательную фичу [CTAD](https://t.me/grokaemcpp/14). Это автоматический вывод шаблонных параметров класса по инициализатору. 

Теперь, если вы хотите создать например пару строки и числа, то вместо этого:

```cpp
std::pair<std::string, int> pair{"Hello there!", 1};
```

Можно писать так:
```cpp
std::pair pair{"Hello there!", 1};
```

Удобно? Безусловно! Только вот один вопросик есть. 

Что будет, если я попытаюсь достать размер строки?

```cpp
size_t size = pair.first.size();
```

А будет ошибка 

```
error: request for member 'size' in 'a.std::pair<const char*, int>::first', which is of non-class type 'const char*'
```

Пара-то на самом деле не из строки и числа, а из указателя и числа. 

При более сложном коде могут возникать такие простыни ошибок компиляции, что без бутылки и не разберешься, что там на самом деле происходит.

Поэтому при использовании CTAD нужно тщательно следить за типами аргументов. Классы с не explicit конструкторами могут наделать большую кучу невкусную кучу беспокойства.

Кстати, знаю адептов строгой типизации, которые даже auto не признают. А как вы относитесь к автоматическому выводу типов? Жду ваши мысли в комментах)

Be careful. Stay cool.


#cppcore #cpp17

Возвращаем ссылку в std::optional

В прошлом посте я упоминал, что методы front и back последовательных контейнеров играют в ящик, если их пытаться вызвать на пустом контейнере. Это приводит к UB.

Один из довольно известных приемов для обработки таких ситуаций - возвращать не ссылку на объект, а std::optional. Это такая фича С++17 и класс, который может хранить или не хранить объект.

Теперь, если контейнер пустой - можно возвращать std::nullopt, который создает std::optional без объекта внутри.

Только вот проблема: std::optional нельзя создавать с ссылочным типом. А копировать объект ну вот никак не хочется. А если он очень тяжелый? Мы программисты и тяжести поднимать не любим.

И вроде бы ситуация безвыходная. Но нет! Решение есть!

Можно возвращать std::optional\<std::reference_wrapper\<T>>. reference_wrapper - это такая обертка над ссылками, чтобы они вели себя как кошерные объекты со своими блэкджеком, конструкторами, деструкторами и прочими прелестями.

Это абсолютно легально и теперь у вас никакого копирования нет!

```cpp
std::optional<std::reference_wrapper<T> front() {
	if (data_.empty()) {
		return std::nullopt;
	}
	return std::ref(data_[0]);
}
```

И в добавок есть нормальная безопасная проверка.

Пользуйтесь. 

Stay safe. Stay cool.

#cpp17 #STL #goodpractice 


Неинициализированные переменные

Все мы знаем, что это плохо, ужасно, это проделки Сатаны и заговор евреев. Но нет-нет да и используем их. Сегодня кратко приведу еще один довод в пользу того, чтобы выкинуть из своей картины мира неинициализированные переменные.

Кейс из недавнего ревью.

Вот у вас есть примерно такая функция и примерно так ее можно вызвать:

```cpp
std::optional<SomeType> WaitForSomething(bool& success) {
	SomeType result;
	if (!SomeOperation()) {
		// error
		return std::nullopt;
	}
	if (condition) {
		//fill result
	}
	success = (condition == 1);
	return result;
}

bool success;
auto obj = WaitForSomething(success);
if (!obj) {
	// handle error
}
if (success) {
	// do something
}
```

Вроде нормальная функция, в случае ошибки не возвращает объекта, в случае успешного условия заполняет как-то объект, в случае неуспеха оставляет его дефолтным. И заполняется output параметр, сигнализирующий об наступлении условия.

Здесь success заполняется всегда вне зависимости, наступит условие или нет. И вроде как очень безопасно туда передать неинициализированный bool. Какая же разница? success в любом случае инициализируется в функции.

А вот приходит другой программист и изменяет эту функцию примерно так:

```cpp
std::optional<SomeType> WaitForSomething(bool& success) {
	SomeType result;
	if (!SomeOperation()) {
		// error
		return std::nullopt;
	}
	while (condition1 && condition2) {
		//fill result
		if (condition3)
			success = true;
	}
	return result;
}
```

По логике реального кода было все четко. Кроме того, что теперь в ветке, где не выполняются одновременно condition1, condition2 и condition3 success остается тем же, что и передали в функцию.

Так конечно не нужно делать. Это хоть чуть-чуть, но изменяет логику поведения функции. Но я хочу тут другой момент затронуть.

Теперь при передаче неинициализированной success результат функции может быть дефолтовым, а success == true, так как в него изначально был записан true.

В реальности привело к довольно долгому дебагу.

Но если бы изначально мы создавали бы инициализированную в ложь переменную

```cpp
bool success = false;
```

то этой боли можно было бы избежать.

Вывод: не используйте неинициализированные переменные! Ну пожалуйста....

Define your value. Stay cool.

#cppcore #goodpractice 

Вызываем оператор индексации у указателей

Есть суперважная проблема, с которой сталкиваются 100% разработчиков в каждой строке своего кода. 

Для указателей перегружен оператор квадратные скобки, который сдвигает указатель на величину индекса вправо и разименовывает его.

И вот теперь представим, что у нас есть класс с собственным перегруженным оператором[]. Например, std::deque. У нас каким-то образом в руках появился указатель на экземпляр этого контейнера. Как у него вызвать оператор взятия индекса объекта?

Если сделать так:

```cpp
std::deque<int> * deque_inst = new std::deque<int>{1, 2, 3, 4, 5};
std::cout << deque_inst[4] << std::endl;
```

то получите огромную простыню нечитаемых ошибок компиляции.

Все потому что `deque_inst` - это указатель, а `deque_inst[4]` значит "сдвинь указатель на 4 вправо и разыменуй".

И шо делать?

Так же не напишешь:

```cpp
deque_inst->[3]
```

Немного не очень опытных разработчиков знают, что можно вызывать операторы явно. Так вот в этом случае как раз можно вызвать оператор[] явно:

```cpp
std::deque<int> * deque_inst = new std::deque<int>{1, 2, 3, 4, 5};
std::cout << deque_inst->operator[](4) << std::endl;
```

Ну то есть все как обычно: есть указатель на объект, мы вызываем у него метод через оператор доступа к членам(для пролетариев - оператор стрелочка). Но этот метод - сам оператор и мы просто вызываем его согласно сигнатуре.

Такой вот прикол. Иногда может выручить.

Однако nobody knows зачем и как вы получили указатель на объект с переопределенным оператором[]. Возможно, вам стоит пересмотреть организацию вашего кода.

Express your thoughts explicitly. Stay cool.

#cppcore


Может ли дружественная функция быть виртуальной?
#опытным 

Еще один вопрос из серии "а могут ли рыбы быть рыжими?" - "Да вроде как по цвету могут, но рыжие это обычно про волосы, а волос у рыб нет. Да и вообще, кому это знание нужно?!". Что-то типа такого. Но раз такие вопросы задают, то пора в ваше кунг-фу добавить и этот приемчик.

Давайте начнем с начала.

Дружественная функция - обычная функция, которая имеет доступ к полям класса-друга. И все. Никаких других особенностей у нее нет. И ограничений тоже никаких нет. Ее сигнатура может быть любой. Объект класса-друга может в ней вообще не фигурировать.

А для виртуальности **необходим** экземпляр класса, в котором укромно затаился vptr, который и отвечает за диспатчинг вызовов в рантайме.

Вот и получается, что виртуальных дружественных функций не бывает.

Конечно вопрос о виртуальных friend-функциях может заходить только тогда, когда в параметрах есть ссылка или указатель на объект полиморфного класса. Но в общем случае на это не накладываются ограничения. Поэтому и в общем случае виртуальных друзей у класса не бывает.

Теперь сможете смело парировать интервьюеров четким ударом в глазницу

Но осадочек-то остался. Хочется менять работу дружественной функции в зависимости от того, какой конкретный объект ей передается. Такое мероприятие можно организовать достаточно просто, но это в следующем посте.

Have a real friends. Stay cool.

#interview #cppcore

Виртуальная дружественная функция
#новичкам

Вчера мы поговорили о том, что таких функций не бывает, но очень хочется получить альтернативу. Хочется изменять работу функции в зависимости от динамического типа, который в нее передается. 

Ну и на самом деле ничего сложного здесь нет. Можно ведь сделать полиморфный метод, который будет вызываться в этой функции. И вот его поведение мы можем изменять примерно как нашей душеньке захочется.

Рассмотрим банальный пример - сериализация объекта в поток. Обычно для такой задачи используют дружественный оператор <<. Но вот хотелось бы сериализовать в зависимости от динамического типа. Фигня вопрос.

```cpp
struct Person {
	Person(const std::string first_name,
		   const std::string last_name) : first_name_{first_name},
										  last_name_{last_name} {}
	
	friend std::ostream& operator<<(std::ostream& o, const Person& b) {
		return o << b.to_str();
	}
protected:
	virtual std::string to_str() const{
		return first_name_ + " " + last_name_;
	}
private:
	std::string first_name_;
	std::string last_name_;
};

struct TaxPayer : Person {
	TaxPayer(const std::string first_name,
			 const std::string last_name,
			 const std::string itn) : Person{first_name, last_name}, itn_{itn} {}
protected:
	virtual std::string to_str() const{
		return Person::to_str() + " " + itn_;
	}
private:
	std::string itn_;
};

int main() {
	auto prs1 = std::make_unique<Person>("Ter", "Minator");
	auto prs2 = std::make_unique<TaxPayer>("Ace", "Ventura", "0000");
	std::cout << *prs1 << std::endl;
	std::cout << *prs2 << std::endl;
}
```

Есть у нас класс человека с его именем и фамилией. Есть класс налогоплательщика, который наследуется от человека и добавляет к полям ИНН. Допустим, мы хотим как-то выводить на консоль содержимое этих людей(в смысле поля; расчленением мы не занимаемся, не в Питере живем все-таки). Можно конечно в каждом классе определять свой оператор или выводить на консоль результат работы метода to_str, но это лишний апи и лишний код. 

Мы просто в базовом классе определяем другана и говорим, чтобы он вызывал виртуальный метод. И все.

Да, это очень просто. Но подход скрытия деталей реализации за закрытым виртуальным методом используется, например в [идиоме невиртуального интерфейса](https://t.me/grokaemcpp/89) и еще невесть где. Поэтому о даже о таком приеме надо знать и применять его в подходящих ситуациях.

Have a real friends. Stay cool.

#cppcore



Дедлокаем код
#новичкам

Частый вопрос на собесах или даже на скринингах - сколько минимум нужно мьютексов, чтобы скрафтить дедлок. 

Прежде, чем приступим к разбору, небольшое введение.

Deadlock - это ситуация, когда два или более потока оказываются заблокированными и не могут продолжить свою работу, так как каждый из них ожидает ресурс, который удерживает другой заблокированный поток. В результате, ни один из потоков не может завершиться, а система оказывается в застойном состоянии.

Многопоточка - это мир магии и чудес. Ошибки, которые появляются по причине плохой организации доступа потоков к ресурсам - самые трудновоспроизводимые и сложные для отладки. И никогда не знаешь откуда выстрелит. Да и сами ошибки принимают причудливые облики. Поэтому дедлоки могут по разному быть проявлены в коде, но поведение программы всегда при этом стабильно убогое - потоки не могут дальше продолжать производить полезную работу.

В рамках текущего поста будем обсуждать так называемую циклическую блокировку. Ща поймете, о чем речь.

Стандартный ответ на вопрос из начала - 2. В одном потоке блочим в начале первый мьютекс, потом второй, а в другом потоке наоборот. Таким образом может произойти ситуация, когда оба потока захватили в заложники каждый по одному мьютексу и бесконечно висят в ожидании освобождения второго. Этого никогда не произойдет, потому что каждому нужен замок, который уже захватил другой поток и он его отдавать не собирается, пока пройдет всю критическую секцию. А он ее никогда не пройдет. В общем, собака пытается укусить себя за чресла.

Самый простой пример, который иллюстирует эту ситуацию:

```cpp
std::mutex m1;
std::mutex m2;

std::thread t1([&m1, &m2] {
	std::cout << "Thread 1. Acquiring m1." << std::endl;
	m1.lock();
	std::this_thread::sleep_for(std::chrono::milliseconds(10));
	std::cout << "Thread 1. Acquiring m2." << std::endl;
	m2.lock();
	std::cout << "Thread 1 perform some work" << std::endl;
});

std::thread t2([&m1, &m2] {
	std::cout << "Thread 2. Acquiring m2." << std::endl;
	m2.lock();
	std::this_thread::sleep_for(std::chrono::milliseconds(10));
	std::cout << "Thread 2. Acquiring m1." << std::endl;
	m1.lock();
	std::cout << "Thread 2 perform some work" << std::endl;
});

t1.join();
t2.join();
```

Все канонично. В двух разных потоках пытаемся залочить замки в разном порядке. В итоге вывод будет такой:

```
Thread 1. Acquiring m1.
Thread 2. Acquiring m2.
Thread 2. Acquiring m1.
Thread 1. Acquiring m2.
```

И дальше программа будет бесконечно простаивать без дела, как тостер на вашей кухне.

Do useful work. Stay cool.

#concurrency 


Зачем локать мьютексы в разном порядке
#новичкам

Можете подумать, что раз всем так известно, что мьютексы опасно лочить в разном порядке, то почему вообще кому-то в голову может прийти наступить на грабли и накалякать такое своими программисткими пальчиками снова? 

Дело в том, что иногда это не совсем очевидно. Точнее почти всегда это не очевидно.

Программисты хоть и разные бывают, но ревью никто не отменял и такую броскую ошибку бы явно заметили. Поэтому не все так просто, как на первый взгляд кажется. 

Разберем чуть более сложный пример:

```cpp
struct SomeSharedResource {
	void swap(SomeSharedResource& obj) {
		{
			std::lock_guard lg{mtx};
			// just for results reproducing
			std::this_thread::sleep_for(std::chrono::milliseconds(10));
			std::lock_guard lg1{obj.mtx};
			// handle swap
		}
	}
	std::mutex mtx;
};

int main() {
	SomeSharedResource resource1;
	SomeSharedResource resource2;	
	std::mutex m2;
	std::thread t1([&resource1, &resource2] {
		resource1.swap(resource2);
		std::cout << "1 Do some work" << std::endl;
	});
	std::thread t2([&resource1, &resource2] {
		resource2.swap(resource1);
		std::cout << "2 Do some work" << std::endl;
	});

	t1.join();	
	t2.join();
}
```

Все просто. У нас есть пара объектов, которые используются в качестве разделяемых ресурсов (их могут изменять более 1 потока). Объекты могут обмениваться между собой данными. 

Ну и по всем канонам нам же надо защитить оба объекта при свопе. Поэтому после захода в функцию обмена сначала лочим свой мьютекс, а потом мьютекс объекта с которым собираемся свопаться.

И вроде снаружи кажется, что мы всегда лочим в одном порядке. Пока мы не будем обменивать данные одних и тех же объектов в разных потоках в разном порядке. Тогда первый поток может залочить мьютекс первого объекта и, допустим, заснуть. А второй поток первым залочит мьютекс второго объекта. И все. Приплыли.

И это все еще может показаться детским садом и очевидушкой. Только вот сам момент взятия замка уже не выглядит так подозрительно. А сами объекты могут лежать в каких-то страшных структурах данных и могут быть разбросаны по коду. В таком случае все не так очевидно становится.

В следующий раз поговорим, как же не допускать такие ошибки.

Don't be obvious. Stay cool.

#concurrency 




Локаем много мьютексов
#опытным

Cтандартное решение этой проблемы дедлока из постов выше - лочить замки в одном и том же порядке во всех потоках. Но как это сделать? Они не же на физре, "по порядку рассчитайсьььь" не делали.

Можно конечно на ифах городить свой порядок на основе, например, адресов мьютексов. Но это какие-то костыли и так делать не надо.

Так как проблема довольно стандартная, то и решение мы скорее всего найдем в том же стандарте. 

std::scoped_lock был введен в С++17 и представляет собой RAII обертку над локом множества мьютексов. Можно сказать, что это std::lock_guard на вариадиках. То есть буквально, это обертка, которая лочит любое количество мьютексов от 0 до "сами проверьте верхнюю границу".

Но есть один важный нюанс. Никак не гарантируется порядок, в котором будут блокироваться замки. Гарантируется лишь то, что выбранный порядок не будет приводить к dead-lock'у.

Пример из прошлого поста может выглядеть теперь вот так:

```cpp
struct SomeSharedResource {
	void swap(SomeSharedResource& obj) {
		{
			std::scoped_lock lg{mtx, obj.mtx};
			// handle swap
		}
	}
	std::mutex mtx;
};

int main() {
	SomeSharedResource resource1;
	SomeSharedResource resource2;	
	std::mutex m2;
	std::thread t1([&resource1, &resource2] {
		resource1.swap(resource2);
		std::cout << "1 Do some work" << std::endl;
	});
	std::thread t2([&resource1, &resource2] {
		resource2.swap(resource1);
		std::cout << "2 Do some work" << std::endl;
	});

	t1.join();	
	t2.join();
}
```

И все. И никакого дедлока.

Однако немногое лишь знают, что std::scoped_lock - это не только RAII-обертка. Это еще и более удобная обертка над "старой" функцией из С++11 std::lock.

О ней мы поговорим в следующий раз.

Be comfortable to work with. Stay cool.

#cpp17 #cpp11 #concurrency 



std::lock
#опытным

Сейчас уже более менее все знают про std::scoped_lock и как он решает проблему блокировки множества мьютексов. Однако и в более старом стандарте С++11 есть средство, позволяющее решать ту же самую проблему. Более того std::scoped_lock - это всего лишь более удобная обертка над этим средством. Это std::lock.

Эта функция блокирует 2 и больше объектов, чьи типы удовлетворяют требованию Locable. То есть для них определены методы lock(), try_lock() и unlock() с соответствующей семантикой.

Причем порядок, в котором блокируются объекты - не определен. В стандарте сказано, что объекты блокируются с помощью неопределенной серии вызовов методов lock(), try_lock и unlock(). Однако гарантируется, что эта серия вызовов не может привести к дедлоку. Собстна, для этого все и затевалось.

Штука эта полезная, но не очень удобная. Сами посудите. Эта функция просто блокирует объекты, но не отпускает их. И это в эпоху RAII. Ай-ай-ай.

Поэтому и использование функции выглядит несколько вычурно:

```cpp
struct SomeSharedResource {
	void swap(SomeSharedResource& obj) {
		{
			// !!!
	        std::unique_lock<std::mutex> lk_c(mtx, std::defer_lock);
	        std::unique_lock<std::mutex> lk_c(obj.mtx, std::defer_lock);
	        std::lock(mtx, obj.mtx);
			// handle swap
		}
	}
	std::mutex mtx;
};

int main() {
	SomeSharedResource resource1;
	SomeSharedResource resource2;	
	std::mutex m2;
	std::thread t1([&resource1, &resource2] {
		resource1.swap(resource2);
		std::cout << "1 Do some work" << std::endl;
	});
	std::thread t2([&resource1, &resource2] {
		resource2.swap(resource1);
		std::cout << "2 Do some work" << std::endl;
	});

	t1.join();	
	t2.join();
}
```

Раз мы все-таки за безопасность и полезные практики, то нам приходится использовать std::unique_lock'и на мьютексах. Только нужно передать туда параметр std::defer_lock, который говорит, что не нужно локать замки при создании unique_lock'а. Тем самым мы убиваем 2-х зайцев: и RAII используем для автоматического освобождения мьютексов, и перекладываем ответственность за блокировку замков на std::lock.

Можно использовать и более простую обертку, типа std::lock_guard:
```cpp
struct SomeSharedResource {
	void swap(SomeSharedResource& obj) {
		{
			// !!!
	        std::lock(mtx, obj.mtx);
	        std::lock_guard<std::mutex> lk_c(mtx, std::adopt_lock);
	        std::lock_guard<std::mutex> lk_c(obj.mtx, std::adopt_lock);
			// handle swap
		}
	}
	std::mutex mtx;
};
```

Здесь мы тоже используем непопулярный конструктор std::lock_guard: передаем в него параметр std::adopt_lock, который говорит о том, что мьютекс уже захвачен и его не нужно локать в конструкторе lock_guard.

Можно и ручками вызвать .unlock() у каждого замка, но это не по-православному.

Использование unique_lock может быть оправдано соседством с условной переменной, но если вам доступен C++17, то естественно лучше использовать std::scoped_lock.

Use modern things. Stay cool.

#cpp11 #cpp17 #concurrency 



Порядок взятия замков. Ч1
#опытным 

В [этом посте](https://t.me/grokaemcpp/506) я намеренно совершил ошибку, чтобы посмотреть, найдут ли ее подписчики. Ну и как байт на комменты и следующие посты.

На самом деле залочивание мьютексов в одном и том же порядке - не общепринятая концепция решения проблемы блокировки множества замков. Это лишь одна из стратегий. И она не используется в стандартной библиотеке!

Когда-то у меня тоже была уверенность, что std::scoped_lock блочит мьютексы в порядоке их адресов. Условно, в начале лочим замок с меньшим адресом. Потом с большим и так далее.

Но на самом деле, как я и написал в середине того же поста, что std::scoped_lock вообще не гарантирует никакого порядка залочивания. Гарантируется только что такой порядок не может привести к дедлоку.

Давайте посмотрим на следующий пример:

```cpp
std::mutex log_mutex;

struct MyLock {
	MyLock() = default;
	
	void lock() {
		mtx.lock();
		std::lock_guard lg{log_mutex};
		std::cout << "Lock at address " << &mtx << " is acquired." << std::endl;
	}

	bool try_lock() {
		auto result = mtx.try_lock();
		std::lock_guard lg{log_mutex};
		std::cout << std::this_thread::get_id() << " Try lock at address " << &mtx << ". " << (result ? "Success" : "Failed") << std::endl;
		return result;
	}
	
	void unlock() {
		mtx.unlock();
		std::lock_guard lg{log_mutex};
		std::cout << "Lock at address " << &mtx << " is released." << std::endl;
	}

private:
std::mutex mtx;
};

MyLock lock1;
MyLock lock2;
MyLock lock3;  

constexpr size_t iteration_count = 100;

void func_thread1() {
	size_t i = 0;
	while(i++ < iteration_count) {
		{
			std::lock_guard lg{log_mutex};
			std::cout << std::endl << std::this_thread::get_id() << " Start acquiring thread1" << std::endl << std::endl;
		}
		std::scoped_lock scl{lock1, lock2, lock3};
		std::lock_guard lg{log_mutex};
		std::cout << std::endl << std::this_thread::get_id() << " End acquiring thread1" << std::endl << std::endl;
	}
}

void func_thread2() {
	size_t i = 0;
	while(i++ < iteration_count) {	
		{
			std::lock_guard lg{log_mutex};
			std::cout << std::endl << std::this_thread::get_id() << " Start acquiring thread2" << std::endl << std::endl;
		}	
		std::scoped_lock scl{lock3, lock2, lock1};
		std::lock_guard lg{log_mutex};
		std::cout << std::endl << std::this_thread::get_id() << " End acquiring thread2" << std::endl << std::endl;
	}
}

int main() {
	std::jthread thr1{func_thread1};
	std::jthread thr2{func_thread2};
}
```

Все довольно просто. Определяем класс-обертку вокруг std::mutex, который позволит нам логировать все операции с ним, указывая [идентификатор потока](https://t.me/grokaemcpp/166). Определяем все методы, включая try_lock, чтобы MyLock можно было использовать с std::scoped_lock.

Также определяем 2 функции, которые будут запускаться в разных потоках и пытаться локнуть сразу 3 замка. Все это в циклах, чтобы какую-то статистику иметь. С потоками сложно детерминировано общаться.

Запускаем это дело и смотрим на вывод консоли. Там будет огромное полотно текста, но вы сможете заметить в нем "несостыковочку" с теорией про блокировку по адресам. Возможный кусочек вывода:

```
129777453237824 Start acquiring thread1

129777453237824 Lock at address 0x595886d571e0 is acquired.
129777453237824 Try lock at address 0x595886d57220
129777453237824 Try lock at address 0x595886d57260
...
129777442752064 Start acquiring thread2

129777442752064 Lock at address 0x595886d57260 is acquired.
129777442752064 Try lock at address 0x595886d57220
129777442752064 Try lock at address 0x595886d571e0
```

Тут наглядно показано, что мьютексы лочатся в противоположном порядке в разных потоках. Если посмотреть на код, то видно, что и в нем мьютексы передаются в скоупд лок в противоположном порядке. А значит дело тут не в адресах, а в чем-то другом. О этом в следующий раз.

Don't get fooled. Stay cool.

#concurrency #cpp17 


Порядок взятия замков. Ч2
#опытным 

Так в каком же порядке блокируются мьютексы в std::scoped_lock? Как я уже и говорил - в неопределенном. Но и здесь можно немного раскрыть детали. 

```
The objects are locked by an unspecified series of calls to `lock`, `try_lock`, and `unlock`.
```

Mutex-like объекты блочатся недетерминированной серией вызовов методов lock(), unlock() и try_lock(). 

Зачем так сложно?

Алгоритм можно представить некой игрой в поддавки. Мы пытаемся поочереди захватить мьютексы. И если на каком-то из какой-то из них занят, то мы не ждем, пока он не освободиться. Мы освобождаем все свои мьютексы и после этого начинает пытаться захватывать замки заново.

То есть физически не может произойти ситуации, когда два потока захватили по набору замков и ждут, пока другие освободятся. Один из потоков точно пожертвует захваченными ресурсами в пользу другого и исполнение продолжится.

При запуске кода из предыдущего поста вы можете увидеть вот такую картину(но не гарантирую):

```
128616222426688 Lock at address 0x56aef94a31e0 is acquired.
128616222426688 Try lock at address 0x56aef94a3220. Success
128616222426688 Try lock at address 0x56aef94a3260. Failed
128616222426688 Lock at address 0x56aef94a3220 is released.
128616222426688 Lock at address 0x56aef94a31e0 is released.
128616222426688 Lock at address 0x56aef94a31e0 is acquired.
128616222426688 Try lock at address 0x56aef94a3220. Success
128616222426688 Try lock at address 0x56aef94a3260. Failed
128616222426688 Lock at address 0x56aef94a3220 is released.
128616211940928 Lock at address 0x56aef94a3260 is acquired.
128616211940928 Try lock at address 0x56aef94a3220. Success
128616211940928 Try lock at address 0x56aef94a31e0. Success
```
Надо понимать, что это многопоточка и каких-то упорядоченных логов между потоками быть не может.

(0x56aef94a31e0 - первый мьютекс, 0x56aef94a3220 - второй, 0x56aef94a3260 - третий)

Смотрим. Поток 128616222426688 локает первый замок, пытается локнуть второй и делает это успешно, а вот третий не получается. Значит он освобождает свои два и пытается начать заново. Видим такую же картину - на третьем мьютексе try_lock прошел неудачно -> освобождаем имеющиеся.

Тут просыпается второй поток 128616211940928. И пишет, что он сразу заполучил третий замок. На самом деле он заблочил его еще до начала этой ситуации, так как первый поток не мог залочить третий мьютекс. Просто поток 128616211940928 уснул между локом и выводом на консоль. И дальше пытается захватить второй и первый замки и у него это успешно получается.

То есть поток 128616222426688 пожертвовал своими захваченными замками в пользу потока 128616211940928.

Вот так выглядит реализация функции std::lock(которая лежит под капотом std::scoped_lock) в gcc:

```cpp
template<typename _L1, typename _L2, typename... _L3>
void lock(_L1& __l1, _L2& __l2, _L3&... __l3)
{
#if __cplusplus >= 201703L
	if constexpr (is_same_v<_L1, _L2> && (is_same_v<_L1, _L3> && ...))
	{
		constexpr int _Np = 2 + sizeof...(_L3);
		unique_lock<_L1> __locks[] = {
			{__l1, defer_lock}, {__l2, defer_lock}, {__l3, defer_lock}...
		};
		int __first = 0;
		do {
			__locks[__first].lock();
			for (int __j = 1; __j < _Np; ++__j)
			{
				const int __idx = (__first + __j) % _Np;
				if (!__locks[__idx].try_lock())
				{
					for (int __k = __j; __k != 0; --__k)
					__locks[(__first + __k - 1) % _Np].unlock();
					__first = __idx;
					break;
				}
			}
		} while (!__locks[__first].owns_lock()); 
		for (auto& __l : __locks)
			__l.release();
	}
	else
#endif
	{
		int __i = 0;
		__detail::__lock_impl(__i, 0, __l1, __l2, __l3...);
	}
}
```

Кто сможет - разберется, но что тут происходит в сущности - я описал выше.

Give something up to get something else. Stay cool.
#concurrency #cpp17


Почему не используют стратегию блокировки по адресам?
#опытным 

Точного ответа от разработчиков стандартной библиотеки мы не услышим, но я приведу некоторые рассуждения, которые могут натолкнуть на некоторые мысли.

Начнем с того, что локать один мьютекс - это норма. Все так делают, никто от этого не помер.

Проблемы и эти ваши дедлоки начинаются только тогда, когда поток по какой-то причине блокируется с уже захваченным локом.

А именно это и происходит при вызове метода lock(). Поток мытается захватить мьютекс и если не получается - блокируется до того момента, пока мьютекс не освободится.

Поэтому любая схема с последовательным вызовом методов lock() будет подвержена дедлокам.

А в схеме с упорядоченным по адресам блокировкой именно так и происходит.

Да, эта схема безопасна, если все мьютексы будут захватываться только так. Но в реальных системах все намного сложнее.

А что если в одном потоке замки будут лочиться через scoped_lock по адресной схеме, а в другом потоке - одиночно? 

```
            1 поток            |            2 поток              |
-------------------------------|---------------------------------|
 lock(mutex2) // УСПЕШНО       |                                 |
                               | scoped_lock()                   |
                               |    lock(mutex1) // УСПЕШНО      |
                               |    lock(mutex2) // ОЖИДАНИЕ ... |
 lock(mutex1) // ОЖИДАНИЕ...   |                                 |

```

В этом случае настанет дедлок. Спасибо за пример Сергею Борисову.

Ну или другую ситуацию рассмотрим: есть 4 замка l1, l2, l3, l4. Поток захватил замок с самым большим адресом l4 и надолго(потенциально навсегда) заблокировался.
Но другие треды продолжают нормально работать. И они иногда захватывают пары мьютексов. Все продолжается нормально, пока один из потоков не пытается залочить l3 и l4. Из-за ордеринга захватится l3, а дальше поток будет ждать освобождения l4 aka заблокируется. Дальше другой поток будет пытаться захватить l2 и l3. Он захватит l2 и будет дожидаться l3. 

Логику можно продолжать и дальше. Таким образом из-за одного мьютекса и немного поломанного потока может остановиться вся программа.

```
std::mutex l1, l2, l3, l4;
// Пусть я как-то гарантирую, что они пронумерованы в порядке возрастания адресов и std::scoped_lock(sc_lock для краткости) работает с помощью сортировки по адресам

1 поток      |     2 поток    |     3 поток    |       4 поток       
-------------|----------------|----------------|----------------
 l4.lock();  |                |                |              
//blocks here|                |                |
             |sc_lock(l3, l4);|                |
	         | // lock l3     |                |
	         | // blocks on l4|                |
                              |sc_lock(l2, l3);|
	                          | // lock l2     |
	                          | // blocks on l3|
	                          |                | sc_lock(l1, l2);
	                                           | // lock l1      
	                                           | // blocks on l2
```

Примеры немного преувеличены, но тем не менее они говорят о том, что схема с адресами не совсем безопасна.

Так может тогда вообще не будем блокироваться при уже захваченном мьютексе? Именно это и делают в реализации стандартной библиотеки. Первый захват мьютекса происходит через обычный lock(), а остальные мьютексы пытаются заблокировать через try_lock. Можно сказать, что это lock-free взятие замка. Если мьютекс можно захватить - захватываем, если нет, то не блокируемся и дальше продолжаем исполнение. Так вот в случае, если хотя бы один try_lock для оставшихся замков вернул false, то реализация освобождает все захваченные замки и начинает попытку снова.

Такой алгоритм позволит избежать неприятных последствий обеих ситуаций, представленных выше.

Возможно даже алгоритм "поддавки" работает быстрее, чем на ордеринге адресов. Сам не мерял, но вот [тред с обсуждениями](https://groups.google.com/g/comp.programming.threads/c/iyZ-0UcR7bw) для интересующихся.

Честности ради, нужно сказать, что алгоритм поддавков подвержен livelock'ам. Это такой тип критических ситуаций-блокировок, когда потоки вроде работают, но ничего полезного не делают. Условно, два потока настолько сильно поддаются друг другу, что ни один из них не может захватить полный набор замков.

Видимо, считается, что livelock eventually рассосется. И разработчики выбрали меньшую из зол.

Do the useful job. Stay cool.

#concurrency 

Еще один способ залочить много мьютексов

Вот у мьютекса есть метод lock, который его захватывает. А разработчика stdlib взяли и сделали функцию std::lock, которая лочит сразу несколько замков.

Также у мьютекса есть метод try_lock, который пытается в неблокирующем режиме его захватить. "Авось да получится". И видимо по аналогии с lock в стандартной библиотеке существует свободная функция std::try_lock, которая пытается захватить несколько мьютексов так же в неблокирующем режиме.

```cpp
template< class Lockable1, class Lockable2, class... LockableN >  
int try_lock( Lockable1& lock1, Lockable2& lock2, LockableN&... lockn );
```

То есть в этой функции банально в цикле на каждом из переданных аргументов вызывается try_lock и, если какой-то из вызовов завершился неудачно, то все занятые замки освобождаются и возвращается индекс мьютекса, на котором выполнение зафейлилось. Если все завершилось успешно aka все замки захвачены, возвращается -1.

Чтобы с помощью std::try_lock навернякак захватить все замки, нужно крутиться в горячем цикле и постоянно вызывать std::try_lock, пока она не вернет -1.

Непонятно, зачем эта функция нужна в прикладном программировании при наличии std::scoped_lock и std::lock, которые еще и удобно оборачивают все эти циклы, скрывая все эти кишки в деталях реализации.

Единственное, что пришло в голову - реализация своего scoped_lock'а с блэкджеком и другим алгоритмом предотвращения дедлока. Этот алгоритм должен быть чем-то похож на поддавки, но как-то изменен. У кого есть кейсы применения - отпишитесь в комменты.

В общем, на мой взгляд, это пример избыточного апи. Если человек сам что-то свое мудрит, то ему особо не сложно самому цикл написать. Однако обычные пользователи стандартных примитивов синхронизации возможно никогда в своей жизни этого не применят. Все-таки стандартная библиотека должна быть сборником решения актуальных проблем реальных, а не воображаемых, людей.

Stay useful. Stay cool.

#concurrency 


Инкапсуляция и структуры
#новичкам 

Всем мы знаем, что раскрывать детали реализации класса - это плохо, этого надо избегать и если вы помыслите об обратном, то придет серенький волчок и укусит за бочок.

Однако, как и со многими такими догматами случается, не всегда нужно следовать этой концепции. Давайте посмотрим на следующий код:

```cpp
class MyClass
{
    int m_foo;
    int m_bar;
public:
    int addAll();
    int getFoo() const;
    void setFoo(int foo);
    int getBar() const;
    void setBar(int bar);
};
int MyClass::addAll()
{
    return m_foo + m_bar;
}

int MyClass::getFoo() const
{
    return m_foo;
}

void MyClass::setFoo(int foo)
{
    m_foo = foo;
}

int MyClass::getBar() const
{
    return m_bar;
}

void MyClass::setBar(int bar)
{
    m_bar = bar;
}
```

Выглядит солидно. Сеттеры, геттеры, все дела. Но вот души в этом коде нет. Он какой-то.. Бесполезный чтоли.

Методы класса не делают ничего такого, что пользователь класса не смог бы сделать своими руками. Скорее руками это все сделать будет даже короче.

Этим грешат новички: поначитаются модных концепций(или не очень модных) и давай скрывать все члены.

Brah... Don't do this...

Здесь нет никаких инвариантов, которые нужно было бы сохранять. Интерфейс класса и так позволяет все, шо хош делать с объектом.

Если ваш класс используется просто как хранилище данных, то это ближе не к классу, а к сишной структуре. Сделайте вы уже поля открытыми и замените ключевое слово class на более подходящее struct. 

```cpp
struct MyClass
{
    int m_foo;
    int m_bar;
}
```

Делов-то. Зато прошлым примером можно хорошо отчитываться за количество написанных строчек кода=)

Show your inner world to others. Stay cool.

#cppcore #goodpractice #OOP 
![[Pasted image 20250220103224.png]]


Могу ли я вызвать функцию main?
#опытным

Вопрос из разряда "а что если" и особо практического смысла не имеет. Но когда это нас останавливало? Без знаний стандарта на этот вопрос вряд ли можно ответить правильно, но я попробую хотя бы приблизится к этому.

Прородителем плюсов был язык С, поэтому давайте сначала посмотрим, что там творится по этому поводу.

В C нет запрета вызывать main(). А все, что не запрещено - разрешено. Вот и вы легко можете вызвать main() из любого места программы. 

Можно даже рекурсивно вызвать главную функцию и из этого можно придумать что-то более менее рабочее. Например:

```c
#include <stdio.h>
int main (int argc, char *argv[]) {
    printf ("Running main with argc = %d, last = '%s'\n",
        argc, argv[argc-1]);
    if (argc > 1)
        return main(argc - 1, argv);
    return 0;
}
```

Если это запускать, как 'recursive_main 1 2 3', то вывод будет такой:

```c
Running main with argc = 4, last = '3'
Running main with argc = 3, last = '2'
Running main with argc = 2, last = '1'
Running main with argc = 1, last = './recursive_main'
```

Но вы скорее попадете на переполнение стека от неконтролируемой рекурсии, чем сделаете что-то полезное.

Ну и конечно, в С очень сложно сделать так, чтобы код выполнялся в глобальной области.

А вот в С++ это возможно. В конструкторах глобальных объектов. И вот здесь уже интересно. Инициализация глобальных переменных имеет свой определенный порядок. Что будет, если мы в этот порядок вклинимся и запустим программу раньше?

Такое чувство, что ничего хорошего мы не получим.

В случае с рекурсией любой код теоретически может уйти в переполнение, поэтому как будто и не особо важно, main это или нет.

Но вот если мы можем прервать подготовку программы к вызову main ее преждевременным вызовом - у нас 100% возникнут проблемы.

Скорее всего это одна из мажорных причин, почему **в С++ нельзя вызывать main никаким образом.** Если происходит обратное, то программа считается ill-formed.

Компиляторы по идее должны тут же прервать компиляцию при упоминании main в коде. Но вы же знаете эти компиляторы. Слишком много им свободы дали. Скорее всего, вы сможете скомпилировать свой код с вызовом main и все заработает. Только если прописать какой-нибудь --pedantic флаг, то вам скажут "атата, так делать низя".

В общем, не думаю, что у вас было желание когда-то вызвать main. Однако сейчас вы точно знаете, что так делать нельзя)

Follow the rules. Stay cool.

#cppcore #goodoldc 

Return в main

На собеседовании тут встретил сеньора-помидора, который говорил, что код
не скомпилируется, если не написать return 0 в конце. Думал, что все уже знают эту особенность, но раз нет - придется рассказать. Правда это довольно коротко будет.

В С++ разрешено не указывать возвращаемое значение для функции main. Но только для нее! Это единственное исключение.

Однако процессу требуется какой-то код возврата по завершению работы, это требование ОС. Поэтому,  если исполнение дошло до конца main и ничего плохого не произошло - подразумевается, что возвращается 0. Компилятор также добавляет соответствующую инструкцию в асм.

На счет сишки точно не знаю, но вроде в С99 можно было опускать инструкцию возврата.

Так что все в порядке, город может спать спокойно без return.

Sleep well. Stay cool.

#cppcore 

![[Pasted image 20241126111059.png]]


\_\_Поля_класса\_\_
#опытным

Очень часто в компаниях прибегают к различного рода код-стайлам для обозначения полей класса и выделения из на фоне серой массы локальных переменных. 

Это очень удобно, когда читаешь код класса и сразу понимаешь, что вот это локальная переменная, а вот это поле класса. Читаемость сразу повышается.

Удобно еще бывает различать открытые и закрытые поля с помощью наличия или отсутствия подчеркивания.

Чисто идейно мне очень нравится такой стайл: открытые члены без подчеркиваний, защищенные с одним подчеркиванием, приватные - с двумя. Спереди или сзада - тут уже вкусовщина. 

Но вот беда. У нас проблемы, Хьюстон. 

В С++ есть определенные навязанные ограничения на нейминг сущностей со стороны underscore. Стандарт говорит:

```
Certain sets of names and function signatures are always reserved to the implementation:

- Each name that contains a double underscore (`__`) or begins with an underscore followed by an uppercase letter (2.11) is reserved to the implementation for any use.
- Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace.

Such names are also reserved in namespace `::std` (17.4.3.1).
```

Имплементация загробастала себе права на имена сущностей, которые содержат двойное подчеркивание или начинаются с одного подчеркивания и буквы верхнего регистра, в любых скоупах. А также для глобального неймспейса зарезервированы имена начинающиеся на одинарный underscore.

Итого, чтобы не было коллизии имен, лучше избегать использования имен с префиксом подчеркивания или содержащих двойной underscore. 

Закрытые поля можно помечать одной черточкой с обеих сторон. Только если решите использовать спереди - не пишите дальше заглавную букву. И будет вам счастье.

Be happy. Stay cool.

#cppcore


CamelCase vs Under_Score

Вдохновился прошлым постом и родилось это.

Есть такое ощущение, что программирование - одна из самых холиварных специальностей в мире. А в добавок к этому программисты по своему складу характера зачастую сами по себе ярые холиварщики. Это взрывоопасное комбо, которое приводит к смешным для стороннего человека проблемам.

Одна из них - как записывать многословные переменные. Уже десятилетиями люди спорят и никак не могут выработать один универсальный вариант. Поэтому приходится писать этот пост, чтобы во всем разобраться.

В настоящее время существует много стандартов наименования переменных, но два из них являются наиболее популярными среди программистов: это camel case («Верблюжья» нотация) и underscore (именование переменных с использованием символа нижнего подчеркивания в качестве разделителя). 

Верблюжья нотация является стандартом в языке Java и в его неродственнике JavaScript, хотя ее можно встретить также и в других местах. Согласно этому стандарту, все слова в названии начинаются с прописной буквы, кроме первого. При этом, естественно, не используется никаких разделителей вроде нижнего подчеркивания. Пример: яШоколадныйЗаяцЯЛасковыйМерзавец. Обычно данный стандарт применяют к именам функций и переменных, при этом в именах классов, структур, интерфейсов используется стандарт UpperCamelCase(первая буква заглавная).

В стандарте underscore слова пишутся с маленькой буквы, а между ними стоит _ ( типа такого: йоу_собаки_я_наруто_узумаки). Обычно этот стандарт используется в названиях функций и переменных, а для названий классов, структур, интерфейсов используется стандарт UpperCamelCase. Обычно используется с родственных С языках

Каждый из этих двух стандартов имеет свои сильные и слабые стороны. Вот основные:  

- Нижнее подчеркивание лучше читается: сравните стандарт_с_нижним_подчеркиванием и стандартНаписанияПрописнымиБуквами
- Зато camel case делает более легким чтение строк, например:  
    my_first_var=my_second_var-my_third_var  
    и  
    myFirstVar=mySecondVar-myThirdVar  
    Очевидно, что camel case читается лучше: в случае с нижним подчеркиванием и оператором «минус» выражение с первого взгляда вообще можно принять за одну переменную.
- Подчеркивание сложнее набирать. Даже при наличии intellisense, во многих случаях необходимо набирать символ нижнего подчеркивания. И имена получаются длиннее. 
- Camel Case непоследователен, потому что при использовании констант (которые иногда пишутся целиком заглавными буквами) нам приходится использовать нижнее подчеркивание. С другой стороны, стандарт именования с использованием нижнего подчеркивания может быть полным, если вы решите использовать в названиях классов (структур, интерфейсов) нижнее подчеркивание в качестве разделителя
- Кроме того, для камел кейса не так уж и просто работать с аббревиатурами, которые обычно представлены в виде заглавных букв. Например, как вот правильно iLoveBDSM или iLoveBdsm. Непонятно. Можете написать в комментах, как это по-вашему пишется)

В плюсах реально во многих проектах(и по моему опыту в частности) склоняются к использованию подчеркиваний в именах переменных и функций, а UpperCamelCase используется для имен классов. Но почему-то это нигде особо не упоминается и этому нигде не учат. Это как-то само приходит со временем.Хотя на начальном этапе карьеры, когда проходят первые ревью, то много непоняток в голове по поводу именований.  Поэтому, вообще говоря, лучше заранее с командой обсудить этот вопрос и выработать ваш подробный код стайл, чтобы все были на одной волне по этому вопросу.

Расскажите в комментах, какую нотацию вы используете? Интересно большую репрезентативную статистику.

Choose your style. Stay cool.

#fun

![[Pasted image 20241202115226.png]]

Перегружаем оператор взятия адреса
#опытным

Перегрузка операторов - дело не для слабонервных. Этим пугают детей и пытают людей. Только прожженные плюсовики могут сходу сказать разницу в перегрузке префиксного и постфиксного декремента/инкремента. 

Но не только в этом дело. Есть такие операторы, которые как бы можно перегружать, но непонятно, для чего это делать.

Вот например, оператор взятия адреса. Да его можно перегружать. Можно его перегружать, как метод:

```cpp
struct Class {
	int* operator &() {
		return &member;
	}
	
	int member;
};
```

Можно, как свободную функцию:

```cpp
struct A {
	int member;
};

int* operator &(Class& obj) {
	return &obj.member;
}
```

Но странновато это все. 

Есть объект. У него есть занимаемое место. Зачем вообще заменять такое интуитивно понятное поведение?

Решение сделать этот оператор кастомным очень спорное. В реальном коде вы такого скорее всего никогда не встретите. А если подумаете, что неплохо было бы в своем коде заюзать эту фичу, то подумайте еще раз 300.

Но все-таки если оно есть, значит кто-то этим пользуется.

Например, для врапперов. Вы написали обертку для класса и хотите прозрачно передать контроль над объектами класса в обертку. Тогда вам возможно может понадобиться возвращать из оператора & указатель на внутренний объект, а не на объект враппера.

Однако тогда встает вопрос, как нормально взять адрес у обертки, если это пригодиться.

Но и на этот вопрос есть ответ. Но обсудим мы его несколько позже. 

Однако уже сейчас видно, что для пользователя кода создаются серьезные препятствия для его понимания и использования. Если нужно из обертки доставать адрес оборачиваемого объекта - сделайте геттер, как у умных указателей и не парьтесь с перегрузкой.

Follow the beaten path. Stay cool.

#cppcore


Addressof
#опытным

Говорят вот, что питон - такой легкий для входа в него язык. Его код можно читать, как английские английский текст. А вот С/С++ хаят за его несколько отталкивающую внешность. Чего только указатели стоят...

Кстати о них. Все мы знаем, как получить адрес объекта:

```cpp
int number = 42;
int * p_num = &number; // &number means taking address
```

Человек, ни разу не видевший код на плюсах, увидит здесь какие-то магические символы. Вроде число, а вроде какие-то руны * и &. Но плюсы тоже могут в читаемость! Причем именно в аспекте адресов. 

Вместо непонятного новичкам амперсанда есть функция std::addressof! Она шаблонная, позволяет получить реальный адрес непосредственно самого объекта и доступна с С++11. Для нее кстати удалена перегрузка с const T&&

```cpp
template< class T >
T* addressof( T& arg ) noexcept;

template< class T >
const T* addressof( const T&& ) = delete;
```

Это делает функцию еще одним примером [использования константной правой ссылки ](https://t.me/grokaemcpp/395).

Это конечно круто, что можно в плюсах словами брать адрес, но в чем прикол? Зачем было заводить отдельную функцию для того, что уже есть в самом языке?

А вот теперь мы возвращаемся к посту про перегрузку оператора взятия адреса(ССЫЛКА). Так как его можно перегружать, то мы можем возвращать вообще любой адрес, который потенциально никак не связан с самим объектом. В этом случае не очень понятно, как взять трушный адрес объекта. Как раз таки std::addressof - способ получить валидный адрес непосредственно самого объекта, который мы передаем в функцию.

Также большим преимуществом является шаблонная природа функции. Это позволяет обобщенному коду работать, как с обычными классами, так и с классами, у которых перегружен оператор взятия адреса.

А с С++17 она еще и констэкспр, это для любителей компайл-тайма.

Вот вам примерчик:

```cpp
template<class T>
struct Ptr
{
    T* pad; // add pad to show difference between 'this' and 'data'
    T* data;
    Ptr(T* arg) : pad(nullptr), data(arg)
    {
        std::cout << "Ctor this = " << this << '\n';
    }
 
    ~Ptr() { delete data; }
    T** operator&() { return &data; }
};
 
template<class T>
void f(Ptr<T>* p)
{
    std::cout << "Ptr   overload called with p = " << p << '\n';
}
 
void f(int** p)
{
    std::cout << "int** overload called with p = " << p << '\n';
}
 
int main()
{
    Ptr<int> p(new int(42));
    f(&p);                // calls int** overload
    f(std::addressof(p)); // calls Ptr<int>* overload, (= this)
}

// OUTPUT
// Ctor this = 0x7fff59ae6e88
// int** overload called with p = 0x7fff59ae6e90
// Ptr   overload called with p = 0x7fff59ae6e88
```

Здесь какие-то злые персоналии перегрузили оператор взятия адреса у класса Ptr так, чтобы он возвращал указатель на одно из его полей. Ну и потом сравнивают результат работы оператора с результатом выполнения функции std::addressof.

Видно, что трушный адрес объекта, полученный с помощью this и адрес, возвращенный из std::addressof полностью совпадают. А перегруженный оператор возвращает другое значение.

Express your thoughts clearly. Stay cool.

#cpp #cpp11 #cpp17


Получаем адрес стандартной функции

Иногда людям приходится работать с указателями на функции. И у них может возникнуть надобность взять адрес у стдшной функции. Например, вы хотите как-то трансформировать каждый символ в строке c помощью std::transform и в качестве коллбэка передаете именно указатель на функцию

```cpp
std::transform(s.begin(), s.end(), s.begin(), std::toupper);
```

Вроде ничего страшного не должно случиться. Но согласно стандарту, поведение программы в этом случае unspecified и потенциально даже ill-formed.

Все потому что нельзя брать адреса у стандартных функций. Начиная с С++20 это явно прописано в стандарте.

```
Let F denote a standard library function, a standard library static member function, or an instantiation of a standard library function template.

Unless F is designated an addressable function, the behavior of a C++ program is unspecified (possibly ill-formed) if it explicitly or implicitly attempts to form a pointer to F.

Possible means of forming such pointers include application of the unary & operator, addressof, or a function-to-pointer standard conversion.

Moreover, the behavior of a C++ program is unspecified (possibly ill-formed) if it attempts to form a reference to F or if it attempts to form a pointer-to-member designating either a standard library non-static member function  or an instantiation of a standard library member function template.
```

Нельзя формировать указатели и ссылки на стандартные функции и нестатические методы.

Но почему? Чем они отличаются от обычных функций?

На самом деле ничем. Дело в том, что будет с функциями в будущем.

Вы без проблем получите адрес одиночной функции. Но если вы добавите к ней перегрузку, то у вас все резко перестанет компилироваться, потому что компилятор не сможет понять, какую конкретно вы используете перегрузку.

А стандарт - это штука не статичная. В него постоянно добавляются новые фичи и обновляются в том числе старые инструменты. Например, с приходом С++11 у нас появилась мув-семантика. И условный метод вектора push_back обзавелся новой перегрузкой для правой ссылки. И это сломало код, который брал адрес метода push_back.

```cpp
#include <vector>

template<typename T>
void Invoke(std::vector<int>& vec, T mem_fun_ptr, int arg)
{
	(vec.*mem_fun_ptr)(arg);
}

int main()
{
	std::vector<int> vec;
	Invoke(vec, &std::vector<int>::push_back, 42);
}
```

Этот код успешно собирается на 98 плюсах, но не может этого сделать на 11-м стандарте. Можете поиграться с [примером на годболте](https://godbolt.org/z/f184EExh1).

Если вам все равно нужно сделать что-то подобное, то оберните вызов стандартной функции в лямбду. Тогда вы ничего не нарушите.

```cpp
std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c){ return std::toupper(c); });
```

Don't braak your future. Stay cool.

#cppcore #cpp20

Получаем адрес перегрузки
#новичкам 

Представьте, что у вас есть функция, которая вызывает любой коллбэк:

```cpp
template<class T, class... Args>
void call_callback(T callback, Args... args) {
	callback(args...);
}
```

И есть другая функция, которую вы вызываете через call_callback.

```cpp
int func() {
	return 42;
}

call_callback(func);
```

Все работает прекрасно. Но теперь мы добавляем перегрузку func и пытаемся их вызвать через call_callback.

```cpp
int func() {
	return 42;
}

int func(int num) {
	return num;
}

call_callback(func);
call_callback(func, 42);
```

Получаем ошибку 

```
error: no matching function for call to ‘call_callback(<unresolved overloaded function type>)
```

Компилятор не может понять, какую вы конкретно перегрузку вы имели ввиду.

Дело в том, что имя функции неявно приводится к указателю на эту функцию. Тип указателя на функцию зависит от ее сигнатуры. И просто по имени невозможно понять, с какой сигнатурой функцию мы имеем ввиду.

Что же делать?

Дать компилятору подсказку и использовать static_cast.

```cpp
call_callback(static_cast<int(*)(>(func));
call_callback(static_cast<int(*)(int)>(func), 42);
```

Теперь все работает, как надо.

Give useful hints. Stay cool.

#cppcore 


Все грани new
#опытным

Не каждый знает, что в плюсах new - это как медаль, только лучше. У медали 2 стороны, а у new целых 3!

Сейчас со всем разберемся.

То, что наиболее часто используется, называется new expression. Это выражение делает 2 вещи последовательно: пытается в начале выделить подходящий объем памяти, а потом пытается сконструировать либо один объект, либо массив объектов в уже аллоцированной памяти. Возвращает либо указатель на объект, либо указатель на начало массива.

Выглядит оно так:

```cpp
int* p_triv = new int(42); // creates dynamic object of type int with value equal to 42
int* p_triv_arr = new int[42]; // created an array of 42 dynamic objects of type int with values equal to zero

struct String {std::string str};

String* p_obj = new String{"qwerty"}; // creates dynamic object of custom type String using aggregate initialization
String* p_obj = new String[5]; // created an array of 5 dynamic objects of custom type String with default initialization
```

Эта штука делает 2 дела одновременно. А что, если мне не нужно выполнять сразу 2 этапа? Что, если мне нужна только аллокация памяти?

За это отвечает operator new. Это оператор делает примерно то же самое, что и malloc. То есть выделяет кусок памяти заданного размера. Выражение new именно этот оператор и вызывает, когда ему нужно выделить память. Но его можно вызвать и как обычную функцию, а также перегружать для конкретного класса:

```cpp
// class-specific allocation functions
struct X
{
    static void* operator new(std::size_t count)
    {
        std::cout << "custom new for size " << count << '\n';
        return ::operator new(count); // explicit call to operator new
    }
 
    static void* operator new[](std::size_t count)
    {
        std::cout << "custom new[] for size " << count << '\n';
        return ::operator new[](count);
    }
};
 
int main()
{
    X* p1 = new X;
    delete p1;
    X* p2 = new X[10];
    delete[] p2;
}
```

Но что, если у меня уже есть выделенная память и я хочу на ней создать объект. Допустим, я не хочу использовать кучу и у меня есть массивчик на стеке, который я хочу переиспользовать для хранения разных объектов, потенциально разных типов.
Тогда мне нужен инструмент, который позволяет только вызывать конструктор на готовой памяти.

Для этого есть placement new. Это тот же самый new expression, только для этого есть свой синтаксис. Сразу после new в скобках вы передаете указатель на область памяти, достаточной для создания объекта.

```cpp
alignas(T) unsigned char buf[sizeof(T)];
T* tptr = new(buf) T; // after new in parentheses we specified location of future object
tptr->~T(); // You must manually call the object's destructor
```

В этом случае кстати вызывается специальная перегрузка operator new:

```cpp
void* operator new  (std::size_t count, void* ptr);
```

Однако она не делает ничего полезного и просто возвращает второй аргумент наружу.

Вот так по разному в С++ можно использовать new. Главное - не запутаться!

Have a lot of sides. Stay cool.

#cppcore 

new vs malloc

Чем отличаются new и malloc? Один из популярных вопросов на собеседованиях, которые проверяет, насколько хорошо вы знакомы с тонкостями работы с памятью в С/С++. Поэтому давайте сегодня это обсудим.

Не совсем корректно, наверное сравнивать фичи двух разных языков с разными доминантными парадигмами программирования. Но раз в стандарте есть std::malloc, а new тоже выделяет память, то можно попробовать.

1 new expression помимо аллокации памяти вызывает конструктор объекта. std::malloc  только выделяет память.

2 std::malloc - совсем не типобезопасный. Он возвращает void * без какого-либо признака типа. Придется явно кастовать результат к нужному типу. new в свою очередь возвращает типизированный указатель.

3 При ошибке выделения памяти new бросает исключение std::bad_alloc, в то время как std::malloc возвращает NULL. Соответственно нужны разные способы обработки ошибочных ситуаций.

4 Поведение new может быть переопределено внутри кастомных классов, поведение std::malloc - неизменно.

5 Если вам не нужно конструирование объекта, то просто вызывайте operator new. Он делает то же самое, что и std::malloc(потенциально вызывает его внутри себя).

6 Для new не нужно вручную высчитывать количество нужных байт. То есть мы не лезем на низкий уровень. Мы заботимся только типе данных, количестве объектов и об аргументах конструктора.

7 new плохо работает с реаллокациями. Нужно выделить новый сторадж, скопировать туда данные и вызвать delete. В то время, как malloc имеет функцию-партнера realloc, которая может изменить размер существующего куска памяти более эффективно, чем последовательность new-memcpy-delete.

Однако они имеют одну неочевидную схожесть. Нужно стараться по максимуму избегать их явного вызова. Давно придумали умные указатели и контейнеры, которые позволяют максимально освободить разработчика от обязанности ручного управления памятью.

Мы все же современные плюсовики. Поэтому в большинстве случаев, вам не нужны будут прямые вызовы этих функций. В более редких случаях(например кастомные аллокаторы) можно явно использовать new. Ну и в совсем редких случаях(нужда в реаллокации памяти или работа с сишным кодом) можно использовать malloc.

Control your memory. Stay cool.

#cppcore #interview 

Подкасты

Если вы думали, что подкаст - это такая штука, которая нужна только, чтобы под них ехать в транспорте, кушать или тренироваться, то у меня для вас хорошие новости. Подкасты еще могут помогать образовываться!

Основная проблема подкастов - чтобы поддерживать адекватный уровень вовлеченности должна быть или интересная личность или просто нескончаемый поток годной и полезной информации.

Кажется, есть кандидат, который сочетает в себе и то, и другое. Еще и на смежную с плюсами тему!

У компании Ядро(неподтвержденная информация) есть свой подкаст "Битовые маски", где специалисты высочайшего класса обсуждают низкоуровневое программирование, процессоры, компиляторы и операционные системы.

Порог входа там довольно большой, но именно благодаря таким материалам вы можете серьезно повысить по крайней мере свою осведомленность о том, что происходит по капотом привычных нам инструментов.

У ребят уже 18 выпусков, так что контента вам хватит за глаза.

Если что это не реклама. Ребята реально делают качественный контент, поэтому этот пост для всех тех, кто по каким-то причинам пропустил битовые маски мимо своего информационного поля. 

Вот ссылочка на плейлист с выпусками https://www.youtube.com/watch?v=wknD9AGvKdc&list=PL0YYm7t_DM63uOt3OF2qRpB5rL27aceLs

Enjoy education. Stay cool.


Доступ к элементам многомерных структур
#опытным 

Если вы спросите разработчиков C++ о том, как они получают доступ к элементам многомерных массивов, скорее всего, вы получите несколько различных ответов в зависимости от их опыта.

Если вы спросите кого-то, кто не очень опытен или работает в нематематической области, есть большая вероятность, что ответ будет таким, что вы должны использовать несколько операторов[] подряд: myMatrix\[x]\[y].

Есть несколько проблем с таким подходом:

1 Это не очень удобно чисто внешне. Все номальные люди используют синтаксис [x, y].

2 Это работает только на реально многомерных структурах, типа вложенных массивов(типа вектора векторов). Чтобы поддержать даже такой синтаксис для кастомных классов, придется сильно приседать.

2 Поэтому многие находят лазейки, чтобы делать что-то похожее на [x, y], этих лазеек много, нет какого-то стандарта.

3 Стандарт использует operator[] с одним аргументом для получения доступа к элементам массивов.

4 Лазейки неконсистентны с одноразмерными массивами в плане получения доступа к элементам.

5 Некоторые из них преполагают спорную семантику, а некоторые делают практически нечитаемыми сообщения об ошибках компиляции

6 Возможные проблемы с инлайнингом.

Рассмотрим лазейки в будущем, а сейчас сфокусируемся на решении проблемы.

В С++23 наконец завезли многоаргументный operator[]. Теперь при проектировании своей матрицы или даже тензора перегружать оператор[] для 1, 2, 3 и более входных аргументов. Так для матрицы можно возвращать элемент, если мы передали 2 размерности, или возвращать всю строку, если мы передали только одну размерность.

```cpp
template <typename T, std::size_t X, std::size_t Y>
class Martrix {
	std::array<T, X * Y> a;
public:
	Martrix() = default;
	Martrix(Martrix const&) = default;
	constexpr T& operator[](std::size_t x, std::size_t y) { // C++23 required
		assert(x < X and y < Y);
		return a[x * Y* + y];
	}
	constexpr std::span<T> operator[](std::size_t x) {
		assert(x < X);
		return std::span{a.data() + x * Y, Y};
	}
	constexpr auto& underlying_array() { return a; }
};
int main() {
	constexpr size_t X = 4;
	constexpr size_t Y = 3;
	Martrix<char, X, Y> matrix;
	// fill in the underlying 1D array
	auto& arr = matrix.underlying_array();
	std::iota(arr.begin(), arr.end(), 'A');
	// print out as 3D array using the order: X -> Z -> Y
	for (auto x {0U}; x < X; ++x) {
		std::cout << "│ ";
		for (auto y {0U}; y < Y; ++y) {
			std::cout << matrix[x, y] << " │ ";
		}
		std::cout << "\n";
	}
	std::cout << "\n";
	auto row = matrix[1];
	for (auto y {0U}; y < Y; ++y) {
		std::cout << row[y] << ' ';
	}
}
```

Здесь мы создали матрицу 4х3, заполнили ее буквами алфавита и вывели на экран каждый элемент через matrix[x, y]. А также дальше получили целую строку матрицы через matrix[x] и вывели ее содержимое на экран:

```
│ A │ B │ C │ 
│ D │ E │ F │ 
│ G │ H │ I │ 
│ J │ K │ L │ 

D E F
```

Очень красиво и удобно. Разработчикам математических библиотек сделали большой подарок.

Be consistent. Stay cool.

#cpp23

std::mdspan
#опытным 

"Я понял, что можно перегружать оператор[] для разного числа аргументов. Но это только для моих классов. А что делать со стандартными контейнерами типа std::vector? Могу я как-то на нем использовать многоаргументный оператор?"

И нет, и да.

Интерфейс семантически одномерного контейнера никто менять не будет.

Однако вместе с С++23 появился еще один полезный класс std::mdspan. Это фактически тот же std::span, то есть это view над одномерной последовательностью элементов, только он интерпретирует ее, как многомерный массив.

То есть вы теперь буквально можете интерпретировать свой std::array или std::vector, как многомерный массив.

И! У std::mdspan переопределен оператор[], который может принимать несколько измеренений и выдает ссылку на соответствующий элемент.

```cpp
std::vector v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
 
// View data as contiguous memory representing 2 rows of 6 ints each
auto ms2 = std::mdspan(v.data(), 2, 6);
// View the same data as a 3D array 2 x 3 x 2
auto ms3 = std::mdspan(v.data(), 2, 3, 2);

// Write data using 2D view
for (std::size_t i = 0; i != ms2.extent(0); i++)
	for (std::size_t j = 0; j != ms2.extent(1); j++)
		ms2[i, j] = i * 1000 + j;

// Read back using 3D view
for (std::size_t i = 0; i != ms3.extent(0); i++)
{
	std::println("slice @ i = {}", i);
	for (std::size_t j = 0; j != ms3.extent(1); j++)
	{
		for (std::size_t k = 0; k != ms3.extent(2); k++)
			std::print("{} ", ms3[i, j, k]);
		std::println("");
	}
}
```

В этом примере мы интерпретируем один и тот же массив, как матрицу и как такую кубическую структуру. Ну и играемся с выводом, чтобы продемонстировать, что мы реально можем манипулировать многомерной структурой, как хотим.

Для создания mdspan нужно передать в конструктор начальный итератор и последовательные размерности. Их может быть сколько угодно. Число элементов или последний элемент последовательности не нужны, так как набор размерностей однозначно задает число элементов.

Метод extend возвращает размер вьюхи по заданному ранк индексу.

Так что теперь можно даже обойтись без сооружения своих оберток над стандартными контейнерами для получения доступа к многомерному оператору[]. И использовать стандартный инструмент std::mdspan.

Use standard things. Stay cool.

#cpp23 #STL


Квиз

В тему индексирования многоразмерных массивов закину сегодня #quiz. Ничего супер запутанного, но от этого не менее интересно.

Вот мы в прошлых постах говорили, что начиная с С++23 мы можем определять оператор[], который принимает несколько аргументов.

А что будет, если мы просто возьмем и создадим многомерный массив, как нам бы это было удобно? И будет получать доступ к его элементам:

```cpp
#include <iostream>

int main() {
	auto array = new int[10, 20]{10};
	std::cout << array[1, 0] << " " << array[11, 1] << std::endl;
}
```

Какой будет результат попытки компиляции и запуска этого кода ?

Ошибка компиляции. Оператор же не может принять 2 аргумента, алё.

Segmentation fault. Выход за границы массива.

Какое-то незнакомое заклинание, ХЗ

10 10

0 0

10 0

0 10


Ответ

На самом деле в код выше я упустил оператор delete[], поэтому в нем есть UB. 

Однако

Он соберется, выведет на консоль "10 0" и успешно завершится.

Но то, что код  не значит, что он понятен и работает, как мы ожидаем.

Основная загвоздка в том, что в С++ запятая - это не просто знак препинания. Это оператор! У него есть вполне четкое и прописанное поведение - он игнорирует результат любого выражения, кроме последнего.

То есть 

```cpp
Expression1, Expression2, Expression3
```

Все выражения вычислятся, но результатом комбинированного выражения будет результат Expression3.

Поэтому когда мы пишем [i, j] до с++23, то это полностью эквивалентно [j].

Получается, что с помощью `new int[10, 20]` мы создали одномерный массив на 20 элементов.

Ну и вообще, весь код полностью эквивалентен следующему:

```cpp
#include <iostream>

int main() {
	auto array = new int[20]{10};
	std::cout << array[0] << " " << array[1] << std::endl;
}
```

Теперь, почему `10 0`.

При аггрегированной инициализации мы можем в фигурных скобках указывать меньше элементов, чем может поместиться в массив или структуру. При этом остальные элементов будут инициализироваться так, как если бы они инициализировались от пустых скобок(аля array[2] = {};). Для интов это значит, что все элементы, кроме первого будут иметь нулевое значение.

Вот такая противная запятая.

Don't be confused. Stay cool.

#cpp23 #cppcore



Оператор запятая внутри operator[]

Много народу попалось на ловушку запятой и выбрали неправильный ответ. Все потому что это поведение реально не интуитивное и реально легко ошибиться в семантике.

Именно поэтому начиная с С++20 использование оператора запятая внутри оператора квадратные скобки признано устаревшим(deprecated).

Это значит, что компиляторы будут обязаны выдавать предупреждение на такое использование, что делает детектирование опасной ситуации более простой задачей.

Итого:

```cpp
void f(int *a, int b, int c) 
{
	a[b,c]; // deprecated 
	a[(b,c)]; // OK
}
```

Можно использовать оборачивание в круглые скобки и это будет валидным выражением с точки зрения стандарта. Но так намного проще будет опознать что-то неладное, чем без круглых скобок.

Remove error-prone things. Stay cool.

#cpp20



Допотопный доступ к многомерному массиву Ч1
#опытным 

Начнем рассказ о том, как люди до С++23(то есть до сих пор) жили с оператором[], принимающим только один параметр.

И начнем мы с банальщины. Вот у нас есть класс матрицы. По всем канонам С++ мы должны получать доступ к ее элементам вот так matrix\[x]\[y]. Этот формат сохраняет констистентность с доступом к элементам одномерных массивов.

Однако сразу натыкаемся на проблему. Класс один, а вызываем мы оператор два раза. Несостыковочка.

Ее решает паттерн прокси. Мы создаем прокси класс и возвращаем его объект из первого индекса. Дальше у этого прокси класса определяем оператор\[] и на выходе получаем наш элемент.

Условно, из первого оператора возвращаем ссылку на строку матрицы, а из второго - уже сам элемент.

Выглядит это примерно так:

```cpp
template <typename T>
struct ArraySpan {
	ArraySpan(T * arr, size_t arr_size) : data_{arr}, size_{arr_size} {}
	ArraySpan(T * arr_begin, T * arr_end) : data_{arr_begin}, size_{std::distance(arr_begin, arr_end)} {}
	
	T& operator[](std::size_t i) {
	return *(data_ + i);
	}

	size_t size() const {return size_;}
	T * data() {return data_;}
private:
	T * data_;
	size_t size_;
};

template <typename T>
struct Matrix {
	Matrix() = default;
	Matrix(size_t rows, size_t cols, T init) : ROWS{rows}, COLS{cols}, data(ROWS * COLS, init) {}
	Matrix(Matrix const&) = default;
	ArraySpan<T> operator[](std::size_t row) {
		return ArraySpan{data.data() + row * COLS, COLS};
	}
	std::vector<T>& underlying_array() { return data; }
	size_t row_count() const { return ROWS;}
	size_t col_count() const { return COLS;}
private:
	size_t ROWS;
	size_t COLS;
	std::vector<T> data;
};

int main() {
	Matrix mtrx(4, 5, 0);
	auto& interval_buffer = mtrx.underlying_array();
	std::iota(interval_buffer.begin(), interval_buffer.end(), 0);
	for (int i = 0; i < mtrx.row_count(); ++i) {
		for (int j = 0; j < mtrx.col_count(); ++j) {
			std::cout << std::setw(2) << mtrx[i][j] << " ";
		}
		std::cout << std::endl;
	}
	std::cout << std::endl;
	for (int i = 0; i < mtrx.row_count(); ++i) {
		auto row = mtrx[i];
		for (int j = 0; j < row.size(); ++j) {
			std::cout << std::setw(2) << row[j] << " ";
		}
		std::cout << std::endl;
	}
}
```

Можно было бы конечно не писать отдельно наш прокси тип ArraySpan, а использовать готовый std::span из С++20, но оставим так. Идея использовать такой легковесный объект понятна - нам не нужно лишнего оверхеда на копирование или создание сложного объекта, чтобы просто получить доступ к элементу матрицы.

Ну и здесь мы можем использовать прокси тип в качестве реальной строки матрицы, и не скрывать его в кишках класса. Так мы получаем доступ к большей вариативности в оперировании матрицами. Например, можно делать скалярное произведение строк и прочее. 

Use proxy. Stay cool.

#cppcore #cpp20 #cpp23


Допотопный доступ к многомерному массиву Ч2

Теперь пойдут способы доступов к элементам многомерных массивов не каноничным путем.

Самый простой из них - вместо оператора[], который может принимать только один параметр, использовать оператор(), который можно перегружать, как нашей душе угодно.

Он может принимать ничем не ограниченный набор параметров. И к тому же их несколько штук можно определить. Например, если передаем 1 аргумент, то возвращается ссылка на строку матрицы. А если 2 аргумента, то возвращаем ссылку на сам элемент.

Вот так это может выглядеть:

```cpp
template <typename T>
struct ArraySpan {
	ArraySpan(T * arr, size_t arr_size) : data_{arr}, size_{arr_size} {}
	ArraySpan(T * arr_begin, T * arr_end) : data_{arr_begin}, size_{std::distance(arr_begin, arr_end)} {}
	
	T& operator()(std::size_t i) {
		return *(data_ + i);
	}
	size_t size() const {return size_;}
	T * data() {return data_;}
private:
	T * data_;
	size_t size_;
};

template <typename T>
struct Matrix {
	Matrix() = default;
	Matrix(size_t rows, size_t cols, T init) : ROWS{rows}, COLS{cols}, data(ROWS * COLS, init) {}
	Matrix(Matrix const&) = default;
	
	ArraySpan<T> operator()(std::size_t row) {
		return ArraySpan{data.data() + row * COLS, COLS};
	}
	
	T& operator()(std::size_t row, std::size_t col) {
		return data[row * COLS + col];
	}
	std::vector<T>& underlying_array() { return data; }
	
	size_t row_count() const { return ROWS;}
	size_t col_count() const { return COLS;}

private:
	size_t ROWS;
	size_t COLS;
	std::vector<T> data;
};

int main() {
	Matrix mtrx(4, 5, 0);
	auto& interval_buffer = mtrx.underlying_array();
	std::iota(interval_buffer.begin(), interval_buffer.end(), 0);
	for (int i = 0; i < mtrx.row_count(); ++i) {
		for (int j = 0; j < mtrx.col_count(); ++j) {
			std::cout << std::setw(2) << mtrx(i, j) << " ";
		}
		std::cout << std::endl;
	}
	std::cout << std::endl;
	for (int i = 0; i < mtrx.row_count(); ++i) {
		auto row = mtrx(i);
		for (int j = 0; j < row.size(); ++j) {
			std::cout << std::setw(2) << row(j) << " ";
		}
		std::cout << std::endl;
	}
}
```

Идейно здесь все тоже самое, да и пример почти идентичный, только используем оператор() вместо квадратных скобок. Это нам позволило в одном классе определить, как мы хотим давать доступы по одному и двум индексам. Это также упростило компилятору задачу по инлайнингу доступа к элементу по двум индексам, так это один вызов функции.

Но у метода есть и недостатки. Самый очевидный - все привыкли использовать квадратные скобки для индексов, а теперь только для этих классов нужно использовать круглые. Конечно, в момент компиляции все встанет на свои места, но все равно неприятно.

Из неочевидного: для прокси типа тоже придется использовать круглые скобки, чтобы сохранить сходство обработки с матрицами(на примере во втором цикле для доступа к конкретному элементу прокси массива тоже используем ()). Ну или не придется, но тогда сходства работы не будет и возникнет еще сильнее путаница.

Ну и непонятно, мы вообще функцию вызываем или что??

Тем не менее, этот способ есть даже в [FAQ на странице, посвященному стандарту C++](https://isocpp.org/wiki/faq/operator-overloading#matrix-subscript-op). И он совместим с нотацией индексации в Фортране. Поэтому метод довольно распространенный.

Be consistent. Stay cool.

#cppcore 


Допотопный доступ к многомерному массиву Ч3

Благодаря появившейся в С++11 аггрегированной инициализации, мы можем инициализировать структуры с помощью фигурных скобок:

```cpp
struct Example {
	int i, j;
};

Example test{1, 2};
std::cout << test.i << " " << test.j << std::endl;
```

Вывод: 1 2

Этим можно воспользоваться для индексирования многомерных массивов. Определяем оператор[], который принимает на вход структуру, а вызываем мы этот оператор с помощью списка инициализации, который превращается в структуру.

```cpp
struct Indexes {
	size_t row;
	size_t col;
};

template <typename T>
struct Matrix {
	Matrix() = default;
	Matrix(size_t rows, size_t cols, T init) : ROWS{rows}, COLS{cols}, data(ROWS * COLS, init) {}
	Matrix(Matrix const&) = default;
	T& operator[](Indexes indexes) {
	return data[indexes.row * COLS + indexes.col];
	}
	std::vector<T>& underlying_array() { return data; }
	size_t row_count() const { return ROWS;}
	size_t col_count() const { return COLS;}
private:
	size_t ROWS;
	size_t COLS;
	std::vector<T> data;
};

int main() {
	Matrix mtrx(4, 5, 0);
	auto& interval_buffer = mtrx.underlying_array();
	std::iota(interval_buffer.begin(), interval_buffer.end(), 0);
	for (size_t i = 0; i < mtrx.row_count(); ++i) {
		for (size_t j = 0; j < mtrx.col_count(); ++j) {
			std::cout << std::setw(2) << mtrx[{i, j}] << " "; // MAGIC HERE
		}
	std::cout << std::endl;
	}
}
```

Получается, что мы индексируем элемент матрицы с помощью двух индексов в операторе квадратные скобки! Единственное, что надо добавлять еще и фигурные.

Не самый элегантный способ, но довольно просто реализуется.

У него есть недостаток, что нельзя переопределить опретора[] для другой структуры, которая может принимать другое число параметров.

Например, мы хотим по одному индексу получать всю строку сразу. Можно попробовать определить другую структуру с одним полем и также через {} инициализировать эту структуру в квадратных скобках.

```cpp
struct Index {
	size_t row;
};

template<typename T>
T& Matrix<T>::operator[](Index index) {
	return ArraySpan{data.data() + index.row * COLS, COLS};
}

auto row = mtrx[{1}];
```

Но такое не прокатит. Компилятор не сможет определить, какой конкретно оператор ему нужно вызвать. 

Дело в том, что аггрегированно инициализировать типы можно и меньшим количеством аргументов. То есть с помощью {1} я могу создать и объект Index, и объект Indexes.

Поэтому способ довольно ограниченный.

Don't be limited. Stay cool.

#cppcore #cpp11 





https://www.boost.org/doc/libs/1_55_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.flat_xxx



Программист - творческая профессия

Один мой руководитель говорил: "программирование - это творческий процесс, его невозможно контролировать". Конечно, он это говорил в контексте программ для слежения за работой прогеров. Но меня немного про другое задела его фраза. 

Над программистами в глазах нормисов висит грозовое облако под названием "технари". Типа вот мы все такие бездушные, цифровые, алгоритмичные, шаблонизированные и интровертные. Так-то оно может и так. Но технари - не значит роботы...

Пусть хоть один робот решит хоть какую-то базовую багу. Обнаружить ее он может. Но вот найти решение - для этого нужно эволюционировать чуть дальше, чем посмотреть на все статьи из гугла.

Мало того. Даже сами разрабы не знают, как решить багу. И вот здесь, на стыке проблемы, нужды в ее решении и незнании, как этого достичь, начинается настоящее творчество. 

Вспомните одну свою самую сложную багу и ее решение. Почти уверен, что в начале вы сидели и просто вдупляли в экран в надежде, что оно само как-то пофикситься. Потом у вас появилась идея. Она оказалась провальной. Потом еще идея. И она провалилась. Вы нагенерили уже 100500 гипотез и все они не выдержали проверку бездушной машины. Почти наверняка спустя несколько дней/недель/месяцев вам в голову приходит какая-то зацепка. Как будто бы лампочка в голове загорается. И она - ключ к решению баги. Без этой идеи все виделось в серых красках. А с ней мир играет всеми цветами радуги.

Ко мне как-то раз пришло решение проблемы, которой я занимался годом ранее и тогда придумал лишь воркэраунд. Просто гуляю летним вечером и БАХ, все понял. Хотя вообще об этом не думал.

Идею можно по-разному называть. Инсайт, вдохновение, муза. 

И мы никак не можем контролировать процесс ее появления. 

Как по мне - 100% творчество.

Разработка ПО - это фактически передний край развития цивилизации(не беру в расчет фундаментальную науку). И индустрия жадно ищет именно творческих единиц. Она хочет собрать кучу прогеров, засунуть их в одну комнату, дать им задание: "сделайте мне что-нибудь великое". И через пару лет забрать готовые условный Телеграмм. 

Конечно, речь не только про баги. Это просто как пример, чтобы показать процесс. 

Нужно уметь брейнштормить в широком смысле этого слова. Сочетать несочетаемое и впихивать невпихуемое. Находить боли и приносить облегчение. Именно этим и ценен специалист. Да, каждом грейде нужен разного уровня прокаченности генератор идей. Но без него человека выкинули бы еще на испытательном сроке. Поэтому каждый из нас, по своему Айвазовский, Шишкин или Пикассо.

Теперь можете в статусе в телеге писать: "программист и просто творческий человек".

Be creative. Stay cool.

#fun

Дефолтные и ссылочные параметры

Есть такой паттерн или стиль написания кода, как входные+выходные параметры у функции. Вместо того, чтобы возвращать результат работы функции в возвращаемом значении, его возвращают через ссылочные параметры.

И вот допустим, у нас программист Иннокентий. У него в проекте есть функция, которая хорошо и без нареканий работает и отправляет запрос базе

```cpp
bool DBConnection::SendQuery(const char* query, const DbQueryParams& params = DbQueryParams{});
```
Если запрос отослан удачно, возвращаем тру, если нет, то фолс.

Строка запроса к базе может содержать плейсхолдеры, а может и не содержать. Если они есть, то вместе с query передаются и параметры для подстановки в запрос. Если нет, то у нас есть пустое значение по-умолчанию.

Но жизнь течет, все изменяется. Кенни поступила задачка проверять состояние конекшена перед отправкой запроса, возвращать результат проверки наружу и ...(построить какую-то логику на результате).

А в проекте у него используется паттерн с выходными параметрами. Обычно это реализовывается так: в начале в аргументах функции идут все входные параметры и затем все выходные. Вроде как логично.

Он, согласно своему код стайлу, пишет:

```cpp
bool DBConnection::SendQuery(const char* query, const DbQueryParams& params = DbQueryParams{}, DbConnectionState& state);
```

Реализовал функцию и запустил билд. А он, хромоногий, упал. 

Нельзя указывать параметры функции без значения по умолчанию после параметров, имеющих это значение.

Видимо это сделано так, потому что иначе появляется пространство для  неопределенности. 

Ладно еще в этом случае компилятор видит разные типы и может как-то соотнести 2 и 2. Но например в случае тривиальных типов все не так однозначно. Они могут неявно конвертироваться друг в друга и тут уже распарсить нельзя.

```cpp
void foo(int i, float j = 5.0, unsigned k);

foo(1, 2); // Невозможно понять, вызвали ли вы foo(1, 5.0, 2) или например по ошибке передали слишком мало аргументов
```

Закатив глаза и особо не думая, вы исправляете:

```cpp
bool DBConnection::SendQuery(const char* query, const DbQueryParams& params = DbQueryParams{}, DbConnectionState& state = DbConnectionState::OK);
```

И билд тоже падает! Но теперь уже по другому поводу.

Неконстантные левоссылочные параметры нельзя определять со значениями по-умолчанию. 

Причина тут очень простая. Вы не можете создать левую ссылку из значения типа rvalue reference. У объекта должно быть имя, чтобы его можно было присвоить неконстантной левой ссылке. У DbConnectionState::OK имени нет, поэтому и упали.

Выход только один. Нарушать свой код-стайл. Придется пихать параметр DbConnectionState& state либо первым параметром, либо между query и params.

Первый способ вообще в принципе нарушает все негласные соглашения в объявлениях функции среди всех языков. 

Второй вроде подходит, когда мы не передаем params. Но в случае, если в запросе есть плейсхолдеры и нам приходится передавать params, то выглядит все не менее ужасно.

Кенни не придумал ничего лучше и сильно расстроился. Пошел в лес, увидел там машину, сел в нее и сгорел.

А что Иннокентий в принципе мог сделать в этой ситуации? Жду ваших вариантов в комментариях)

Don't worry. All difficulties will pass.

#cppcore



Квиз

Снова будем развлекаться и отгадывать загадки. Как всегда, все очень запутано и загадочно, в примере подвох на подвохе. Но тем и интереснее сам #quiz и его обсуждения.

Есессно, без знаний стандарта не обойтись. Да и скажу честно, даже с этими знаниями не все так гладко.

Тем не менее. У меня к вам всего один вопрос: Что будет результатом попытки компиляции и запуска следующего кода на С++20:

```cpp
#include <iostream>

struct foo
{
    void bar() { std::cout << "You are the best!" << std::endl; }
};

int main()
{
    foo* f = nullptr;
    f->bar();
}
```

Ошибка компиляции

Этот код такой UBогий

Unspecified Behaviour

Segmentation Fault

Программулина напишет мне, что я лучший!



Удаляем элемент из ассоциативного контейнера по значению

Понимаю, что искать элементы ассоциативного контейнера предполагается чисто по ключу. Иначе зачем бы мы использовали этот тип контейнера?

Но вот бывают иногда случаи, когда под вашу задачу очень хорошо подходит мапа, но чтобы держать ее в консистентном состоянии вам нужно иногда удалять элементы по значению.

Не все хотят тянуть себе в проект какой-нибудь буст с его bimap или прочие сторонние решения. Хочется чего-нибудь стандартного. Понятное дело, что это не будет эффективно и удалять мы будем за линейное время. Но все же...

У ассоциативных контейнеров есть только один метод на удаление элементов - erase. Он принимает либо итератор, либо ключ. И нет такой перегрузки, которая бы как-то на значение смотрела. То есть нужно делать так:

```cpp
std::map<int, int> map{{1, 6}, {2, 7}, {3, 8}, {4, 9}, {5, 10}};
// вот так
auto it = std::find_if(map.begin(), map.end(), [](const auto& elem) {return elem.second == 10;});
map.erase(it);
//
std::for_each(map.begin(), map.end(), [](const auto& item){ std::cout << item.first << " " << item.second << std::endl;});
// OUTPUT
// 1 6
// 2 7
// 3 8
// 4 9
```

Две строчки на идейно очень простое и семантически цельное действие. Ох, если бы был метод erase_if...

И вы знаете, в С++20 появились перегрузки свободной функции std::erase_if для каждого стандартного контейнера. Теперь можно написать просто вот так:

```cpp
std::erase_if(map, [](const auto& elem) {return elem.second == 10;});
```

И результат вывода будет таким же.

У кого есть только древние плюсы - не переживайте. Для вас эти перегрузки реализовали в экспериментальной библиотеке. Просто сделайте так:

```cpp
#include <experimental/map>
std::experimental::erase_if(map, [](const auto& elem) {return elem.second == 10;});
```

И все заработает.

Do things easier. Stay cool.

#STL #cpp20 


Проверяем вхождение элемента в ассоциативный контейнер

Нужно вот нам по ключу проверить вхождение элемента допустим в мапу.

Обычно мы пишем:

```cpp
if (map.count(key)) {
	// do something
}
```

Но для контейнеров без приставки "multi" это выглядит довольно странно. Действительно, если я знаю, что в мапе однозначное соответствие ключа и значения, зачем мне знать сколько вхождений элементов с этим ключом? Я хочу просто знать, есть ли он. 

Такие вот маленькие семантические несостыковочки. С ними вроде все смирились, но осадочек остался...

И 20-е плюсы наконец нам подарили замечательный публичный метод для всех ассоциативных контейнеров contains. Он проверяет, если ли в контейнере элементы с данным ключом. Теперь код выглядит так:

```cpp
if (map.contains(key)) {
	// do something
}
```

И вот уже стало чуть приятнее и понятнее читать код.

Make things clearer. Stay cool.

#STL #cpp20


Double lookup
#опытным 

Решил сделать небольшое дополнение к предыдущему посту по результатам дискуссии в комментариях.

Не нужно использовать методы count(key) и contains(key), если вы потом собираетесь работать с этим ключом в ассоциативном контейнере(например изменять объект по ключу). Это может привести к так называемому double lookup. То есть двойной поиск по контейнеру.

Возьмем для примера std::map для показательности. И вот такой код:

```cpp
std::map<std::string, std::string> map;

std::string get_value(const std::string& key) {
	if (!map.contains(key)) {
		std::string value = longCalculations(key);
		map[key] = value;
		return value;
	} else {
		return map[key];
	}
}
```

Здесь мы по ключу key выдает какое-то значение value. Эти значения вычисляются при помощи долгой функции longCalculations, поэтому было решено закэшировать все уже вычисленные значения в мапе. Так мы сможем обойти долгие вычисления и быстро дать ответ.

Только вот в чем проблема. Поиск по мапе - логарифмическая по времени операция. И в этом примере мы всегда делаем 2 поиска: первый раз на contains(мы должны пройтись по контейнеру, чтобы понять, есть ли элемент) и второй раз на operator\[](нужно пройтись по контейнеру, чтобы вставить в него элемент/получить к нему доступ). Так вот в случае, если ключ есть в мапе, то мы можем делать всего 1 поиск! С помощью метода find и итератора на элемент. 

```cpp
std::string get_value(const std::string& key) {
	auto it = map.find(key);
	if (it == map.end()) {
		std::string value = longCalculations(key);
		map[key] = value;
		return value;
	} else {
		return it->second;
	}
}
```

Мы в начале попытались найти конкретный элемент мапы по ключу. И если его нет, то нам все-таки придется выполнить второй поиск, чтобы найти подходящее место для элемента. Но вот если ключ есть, тогда мы можем использовать сам итератор для возврата значения и второго поиска не будет!


Методы count и contains нужно использовать только тогда, когда у вас не надобности в получении доступа к элементам контейнера. Find в этом случае, по моему мнению, немного синтаксически избыточен. А вот говорящие методы - самая тема. Например, у вас есть множество, в котором хранятся какие-то поля джейсона. И вам нужно трансформировать только те значения, ключи которых находятся во множестве.

```cpp
std::set<std::string> tokens;
std::string json_token;
Json json;
if (tokens.contains(json_token)) {
	transformJson(json, json_token);
}
```

Все прекрасно читается и никакого двойного поиска!

Don't do same work twice. Stay cool.

#cppcore #goodpractice 



std::apply

Метапрогеры очень любят работать с компайл-тайм структурами, типа std::array, std::initializer_list и std::tuple. Когда работают с такими структурами, то интересны прежде всего элементы этих структур. И очень хочется как-то единообразно передавать их распакованные элементы куда-то в другую функцию.

Именно этим и занимается std::apply, которая появилась в С++17. По факту, эта такое дженерик решение для того, чтобы вызвать какую-то функцию с аргументами из элементов tuple-like объектов.

Простейшее, что можно с ней делать - вывести на экран все элементы тапла.

```cpp
const std::tuple<int, char> tuple = std::make_tuple(5, 'a');
std::apply([](const auto&... elem)
{
	((std::cout << elem << ' '), ..., (std::cout << std::endl));
}, tuple);
```

Здесь мы применяем fold-expression и оператор-запятая. Можете освежить знания в [этом посте](https://t.me/grokaemcpp/195).

Можно придумать чуть более сложную задачу. Надо написать функцию, которая принимает неограниченное число параметров, в том числе и tuple-like объекты. Все параметры надо распаковать в строку, а tuple-like объекты выделить с помощью фигурных скобок. Объекты естественно могут быть вложенные.

Может получится что-то такое:

```cpp
template <typename T, typename = void>
struct is_tuple_like : std::false_type {};
template <typename T>
struct is_tuple_like<T, std::void_t<decltype(std::tuple_size<T>::value), decltype(std::get<0>(std::declval<T>()))>> : std::true_type {};
template <typename T>
constexpr bool is_tuple_like_v = is_tuple_like<T>::value;

template<typename Tval, typename ... T>
void serialize_tuple_like(std::stringstream &outbuf, const Tval& arg, const T& ... rest) noexcept {
	if constexpr (is_tuple_like_v<Tval>){
		outbuf << "{ ";
		std::apply([&outbuf](auto const&... packed_values) {
			serialize_tuple_like(outbuf, packed_values ...);
			}, arg);
		outbuf << " }";
	}
	else{
		outbuf << arg;
	}
	
	if constexpr(sizeof...(rest) > 0){
		outbuf << ' ';
		serialize_tuple_like(outbuf, rest ...);
	}
}

template<typename ... T>
std::string args_to_string(const T& ... args) noexcept {
	std::stringstream outbuf{};
	if constexpr(sizeof...(args) > 0){
		serialize_tuple_like(outbuf, args ...);
	}
	return outbuf.str();
}

int main(){
	std::cout << args_to_string("test", 1,
								std::tuple{"tuple1", 2, 3.0,
									std::tuple{"tuple2", "boom"}},
								std::pair{"pair", 4},
								std::array{5, 6, 7, 8, 9});
}
```

Вывод будет такой:
```
test 1 { tuple1 2 3 { tuple2 boom } } { pair 4 } { 5 6 7 8 9 }
```

Даже не знаю, как эту лапшу разбирать. Идея такая что is_tuple_like_v проверяет аргумент на соответствие tuple-like объекту. Если нам на очередном вызове serialize_tuple_like попался такой объект, то мы берем и распаковываем его параметры в рекурсивный вызов serialize_tuple_like. Если у нас не tuple-like объект, то просто выводим его в стрим. Наверное, нужны проверки на то, что объект можно вывести в стрим, но решил, что это немного борщ для этого кода.

У функции довольно специфичные кейсы использования. Впрочем, как и у всей метапроги.

Don't live in metaverse. Stay cool.

#template #cpp17


const this

this - указатель на объект, на котором сейчас находится контекст исполнения. Будь то метод или [default member initializer](https://t.me/grokaemcpp/319). И вот есть в этих ваших интернетах такое мнение, что этот this - нулевой неявный аргумент метода и он передается в него в таком виде:

```cpp
void Foo::bar(Foo * const this, Type1 param1, Type2 param2) {}
```

То есть типа this - константный указатель.

Так наверное можно думать, но это не совсем правда. Точнее так. Действительно, this - адрес неявного аргумента-объекта. Но нигде не написано, что он константный. 

Да ему нельзя ничего присваивать. Например

```cpp
void Foo::change(Foo *foo) { this = foo; }
```

При компиляции кода появится примерно такая ошибка: lvalue required as left operand of assignment. Но если приглядеться, то ни про какой const там речь не идет. Ему не хватает lvalue слева.

Все потому что this - prvalue выражение. То есть можно даже сказать, что это и не указатель. Это выражение, значение которого равно адресу объекта. Оно не может быть использовано слева от знака равенства и у него нельзя взять адрес. 

И именно поэтому ему нельзя ничего присваивать, а не потому что это константный указатель.

Но вот cv-квалификация метода может повлиять на cv-квалификацию указателя на объект. Тип this в обычном методе - Foo \*(указатель на Foo). Однако для cv-квалифицированных методов this становится cv Foo \*. То есть:

```cpp
void Foo::ConstMemberFunction(Type1 param1, Type2 param2) const {
	// this - const Foo *
	this->field = param1; // Error!
}
```

Сделано это, естественно, чтобы мы никак не могли изменить объект, на который указывает this, в константном методе. 

Так что this - prvalue и точка!

Make points in your life. Stay cool.

#cppcore

std::jthread

С std::thread в С++ есть один интересный и возможно назойливый нюанс. Давайте посмотрим на код:

```cpp
int main()
{
	std::thread thr{[]{ std::cout << "Hello, World!" << std::endl;}};
}
```

Простой Хелло Ворлд в другом потоке.  Но при запуске программы она тут же завершится примерно с таким сообщением: `terminate called without an active exception`.

Эм. "Я же просто хотел быть счастливым(ЗАЧЕРКНУТЬ) вывести в другом потоке сообщение. Неужели просто так не работает?"

В плюсах много чего просто так не работает)

А вот такая программа:

```cpp
int main()
{
	std::thread thr{[]{ std::cout << "Hello, World!" << std::endl;}};
	std::this_thread::sleep_for(std::chrono::seconds(1));
}
```

Все-таки напечатает Hello, World!, но потом все равно завершится с std::terminate.

Уже лучше, но осадочек остался. Ничего не понятно. Давайте разбираться.

С помощью слипа мы немного затормозили main тред и сообщение появилось. То есть мы оттянули выход из main и завершение программы. А что происходит при выходе из скоупа функции? Вызов деструкторов локальных объектов.

Так вот в деструкторе единственного локального объекта и проблема. Согласно документации, для каждого потока мы обязательно должны выбрать одну из 2-х стратегий поведения: отсоединить его от родительского потока или дождаться его завершения. Делается это методами detach и join соответственно.

И если мы не вызовем один из этих методов для объекта потока, то в своем деструкторе он вызовет std::terminate. То есть корректный код выглядит так:

```cpp
int main()
{
	std::thread thr{[]{ std::cout << "Hello, World!" << std::endl;}};
	thr.join();
}
```

Мы дожидаемся конца исполнения потока и только после этого завершаем программу. Теперь никаких терминаторов.

Но зачем эти формальности? Вообще говоря, часто мы хотим присоединить поток почти сразу перед вызовом его деструктора. А вот отсоединяем поток мы почти сразу после создания объекта. Мы же заранее знаем, хотим ли мы отпустить поток в свободное плавание или нет. И, учитывая эти факты, было бы приятно иметь возможность не вызывать join самостоятельно, а чтобы он за нас вызывался в деструкторе.

И С++20 приходит здесь нам на помощь с помощью std::jthread. Он делает ровно это. Если его не освободили и не присоединили мануально, то он присоединяется в деструкторе.

Поэтому такой код сделает то, что мы ожидаем:

```cpp
int main()
{
	std::jthread thr{[]{ std::cout << "Hello, World!" << std::endl;}};
}
```

jthread не только этим хорош. Его исполнение можно еще отменять/приостанавливать. Но об этом уже в другой раз.

Кстати. Вопрос на засыпку. Слышал, что там какие-то сложности у кланга с jthread были. Сейчас все нормально работает?

Make life easier. Stay cool.

#cpp20 #concurrency 







По поводу канала