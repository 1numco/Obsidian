
ОРы:
- понимает понятие диапазона в том числе с точки зрения концепта
- понимает понятие отображения в том числе с точки зрения концепта
- понимает понятие поддиапазона
- применяет концепты range и view для при передаче таких объектов в шаблонные функции

Структура:

- говорим, что стандартная библиотека диапазонов создавалась, как альтернатива stl и поэтому в ней есть аналоги для большинства алгоритмов классической stl. приводим пример std::ranges::sort. Показываем ее сигнатуру и видим концепт range.
- Раскрываем понятие range концепта. 2 итератора, которые потенциально разных типов. end() обобщается в sentinel(ограничитель). 
- То есть диапазон - это последовательность элементов, задаваемая двумя итераторами. Любой контейнер подходит под понятие диапазона. Библиотеке диапазонов не нужны голые итераторы для обработки последовательностей, ей нужен лишь диапазон рассматриваемых значений. Поэтому алгоритмы ranges принимают последовательность через 1 параметр диапазона, что очень удобно.
- До этого момента рассматривали только контейнеры в качестве диапазонов. Но иногда хочется оперировать более легковесными объектами - отображениями. Показываем концепт отображения. Показываем базовый пример ranges::views::all
- Если по какой-то причине не нужен весь контейнер, есть поддиапазоны. Он создается через пару итераторов и его потом можно передавать в алгоритмы ranges отдельно.
- common_view. Заворачивает начало и конец диапазона в один тип итератора с проверкой нижележащих элементов.

## Введение

Библиотека диапазонов - одна из мажорных фич С++20. Фактически, это STL2.0 в стандартной библиотеке С++. Диапазоны или рэнджи призваны облегчить обработку данных, сделать ее более выразительной, лаконичной и быстрой. Сегодня мы начнем изучение этой библиотеки с базовых понятий. Вы узнаете:
- Что такое диапазон и каким требованиям он должен удовлетворять;
- Что такое отображение и каким требованиям оно должно удовлетворять;
- Для чего нужны поддиапазоны;
- Как использовать диапазоны со стандартными алгоритмами STL.

Контент

Библиотека диапазонов, как альтернатива привычной нам STL(Всплывашка: Название STL - Standard Template Library - на самом деле относится к сторонней библиотеке, разработанной Александром Степановым в 90-е года прошлого века. Однако благодаря совместной работе Александра и комитета стандартизации С++ ключевые элементы библиотеки, а именно контейнеры, итераторы и алгоритмы, вошли в стандарт. С тех пор эту часть стандартной библиотеки неофициально стали называть STL.), предоставляет свои реализации большинству привычных нам стандартных алгоритмов. Давайте возьмем, к примеру, сортировку в ranges std::ranges::sort и посмотрим, что мы сможем выяснить о диапазонах с ее помощью. Вот сигнатура этой функции:

```cpp
template<std::ranges::random_access_range R, class Comp = std::ranges::less,
          class Proj = std::identity>  
requires std::sortable<std::ranges::iterator_t<R>, Comp, Proj>  
constexpr std::ranges::borrowed_iterator_t<R>  
    sort( R&& r, Comp comp = {}, Proj proj = {} );
```

Все понимаем, очень интересно, но мало что понятно. Все ингредиенты этого коктейля интересностей мы потихоньку будем разбирать в течение этого модуля, однако сейчас нас интересует первый параметр сортировки `R&& r`. Обе буквы `r` здесь обозначают range или диапазон. И тип этого диапазона ограничен концептом `std::ranges::random_access_range`. И зачем здесь часть `random_access*` - понятно, для сортировки нужна последовательность элементов и произвольным доступом всех элементов. То есть `R` должен быть диапазоном с произвольным доступом до всех элементов. Однако, что же такое диапазон?

С точки зрения концепта `std::ranges::range` диапазон - это сущность, удовлетворяющая следующим требованиям:

```cpp
template<class T>  
concept range = requires( T& t ) {  
    std::ranges::begin(t);
    std::ranges::end(t);
};
```

t - это диапазон, если валидны вызовы двух функций `ranges::begin(t)`  и `ranges::end(t)`. Пока что больше понимания у нас не появилось, но появились намеки, что у диапазона есть начало и конец(иногда мы пользуемся услугами капитана очевидности при написании уроков, не обращайте внимания). 

Рассмотрим std::ranges::begin:

```cpp
template<class T>  
constexpr std::input_or_output_iterator auto begin( T&& t );

template<class T>  
using iterator_t = decltype(std::ranges::begin(std::declval<T&>()));
```

Видим, что эта функция возвращает итератор и этот итератор представляет из себя:
- адрес первого элемента, если t - C-style массив.
- тип результата вызова метода t.begin().
- тип результата вызова begin(t). Функция begin может быть стандартной std::begin, а может быть кастомной.

То есть начало диапазона должно быть итератором на начало последовательности.

Логично предположить, что конец диапазона тоже должен быть итератором. Однако все немного сложнее:

```cpp
template<class T>  
constexpr std::sentinel_for<std::ranges::iterator_t<T>> auto end( T&& t );

template<std::ranges::range R>  
using sentinel_t = decltype(std::ranges::end(std::declval<R&>()));
```

std::ranges::end возвращает так называемый sentinel или ограничитель и представляет из себя:
- адрес элемента ячейки памяти, следующей за последним элементом, `t + std::extent_v<T>`, если t -  C-style массив.
- тип результата вызова метода t.end().
- тип результата вызова end(t). Функция end может быть стандартной std::end, а может быть кастомной.

Помимо этого обе функции std::ranges::begin и std::ranges::end должны вычисляться за амортизированно-константное время.

Вы уже заметили очень важный момент? Мы предполагаем, что типы начала и конца диапазона могут различаться. 

Дело в том, что это предположение о том, что начало и конец последовательности должны быть итераторами одного типа - слишком ограничивающее предположение. Например, существует итератор, который предназначен для прохода по стриму std::istream_iterator. Сам std::istream_iterator не знает, когда закончится стрим, поэтому при обработке стримов с помощью стандартных алгоритмов используют следующий хак:

```cpp
// задаем входной поток
std::istringstream str("0.1 0.2 0.3 0.4");
// пишем в std::cout разделенные пробелом double значения, которые нашлись во входном потоке
std::partial_sum(std::istream_iterator<double>(str),
				 std::istream_iterator<double>(),
				 std::ostream_iterator<double>(std::cout, " "));
```

Вторым параметром стандартных алгоритмов STL идет итератор на конец последовательности. Но в случае со стримами мы просто не может заранее указать на их конец. Поэтому для обозначения конца используется дефолтно инициализированный std::istream_iterator. Выглядит это странно и не очень выразительно.

Поэтому в библиотеке диапазонов сделали допущение, что конец последовательности не обязательно должен быть такого же типа, как и начало. Диапазоны и алгоритмы над ними- это прекрасная иллюстрация армейской фразы "копаем отсюда и до обеда". Главное, чтобы итератор, вернувшийся из begin, и ограничитель, вернувшийся из end, можно было сравнивать, чтобы таки найти конец последовательности. Это позволяет использовать алгоритмы диапазонов очень необычным образом:

```cpp
std::vector<int> vec = { 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto pos = std::ranges::find(vec.begin(), std::unreachable_sentinel, 7);
```

Здесь диапазон задается итератором начала вектора и `std::unreachable_sentinel`.
`std::unreachable_sentinel` всегда возвращает `false`, когда происходит сравнение с итератором. То есть достигнуть ограничителя невозможно. Поэтому компилятор оптимизирует проверку границы `it! = End`, так как тогда это выражение всегда истинно. И это ускоряет поиск элемента.

Конечно, для такого трюка требуется гарантия наличия конкретного элемента в векторе, иначе будет неопределенное поведение. Однако этот пример показывает, что с помощью диапазонов мы можем переосмыслить подходы к обработке данных. Мы чуть позже еще вернемся к раскрытию потенциала ограничителя.

Концепты, ограничивающие типы входных данных алгоритмов диапазонов, также помогают также упростить ошибки компиляции в случае, если пользователь передал что-то не то. Например:

```cpp
std::list<int> lst = {1, 4, 2, 3};
std::ranges::sort(lst);
```

Сортировка требует произвольного доступа к данным. А std::list не предоставляет такой возможности. Вместо того, чтобы получать сбивающую с толку информацию об операторе минус при использовании std::sort, теперь мы видим более точное сообщении об ошибке:

```
required for the satisfaction of 'random_access_range<_Range>' [with _Range = std::__cxx11::list<int, std::allocator<int> >&]
```


Получается, с точки зрения пользователя диапазон - это последовательность элементов, у которого определено четкое начало и какой-то конец. Любой контейнер подходит под понятие диапазона, как базовая единица для обработки набора данных. И алгоритмам диапазонов не обязательно передавать голые итераторы для обработки последовательностей, им нужен лишь диапазон рассматриваемых значений. Поэтому все алгоритмы ranges имеют перегрузку, принимающую последовательность через 1 параметр диапазона, что очень удобно и выразительно. Только уже по этой причине стоит перейти на использование библиотеки диапазонов.

Однако пока что тяжело представить сущности, которые могли бы быть диапазонами, помимо контейнеров. Но сейчас мы это исправим. Давайте обсудим еще одно ключевое понятие в библиотеке ranges.

## Отображения

До сих под диапазонами мы подразумевали были контейнеры, которые владели данными. Но обязательное ли это требование?

Диапазон - это по сути всего лишь пара {итератор, ограничитель}. Диапазоном может быть структура, которая генерирует числа по порядку, начиная и заканчивая какими-то числами. Такому диапазону не нужно знать, что находится между началом и концом. Ему достаточно понимать, как переходить от одного элемента последовательности к другому и где остановиться. 

Поэтому идейно мы может оперировать такими легковесными объектами, которые знают только начало последовательности и ограничитель.

Такие объекты называются отображениями или views в библиотеке ranges.

Давайте посмотрим на концепт отображений, чтобы понять, что они из себя синтаксически представляют:

```cpp
template<class T>  
concept view = std::ranges::range<T> && std::movable<T> && std::ranges::enable_view<T>;

template<class T>  
constexpr bool enable_view = std::derived_from<T, std::view_base> || /*is-derived-from-view-interface*/<T>;

struct view_base { };
```

Если тип является диапазоном, его можно перемещать и для него переменная std::ranges::enable_view выставлена в true, то такой тип является отображением. Опустив некоторые детали, enable_view выставляется в true для наследников view_base и для явных специализаций.

Это синтаксические требования. Есть еще семантические требования, которые сводятся к тому, что копирование/перемещение отображения должно происходить за константное время.

Когда мы видим слово `view`, на ум сразу же приходят std::string_view, std::span и std::mdspan. Как отображения из ranges связаны с этими классами?

На самом деле с точки зрения ranges эти классы - это полноценные отображения. Для них явно специализирована переменная enable_view, установленная в true.

Но считать, что все отображения - это просто средства для подсмотра за контейнерами - не совсем верно. Отображения - это нечто сильно большее. Держите это в уме, мы еще вернемся к этому факту в будущих уроках.

А сейчас разберем несколько простых примеров отображений, которые похожи на std::string_view, std::span и std::mdspan, так как являются простыми неваладеющими последовательностями.

Одной из особенностей std::string_view, std::span и std::mdspan является то, что они не помнят, на чьи элементы они смотрят. То есть делают мощный type erasure. Однако такой особенности лишен std::ranges::ref_view. Объекты такого класса мало того, что помнят, на основе какого диапазона они созданы, так еще и могут вернуть ссылку на него:

```cpp
std::string s{"cosmos"};
std::ranges::ref_view rv{s};
std::println("{}", rv.base());
// вывод: `cosmos`
```

Но если передать в ref_view rvalue, то будет неопределенное поведение, так как исходный объект разрушится и ref_view будет смотреть на руины. Для таких случаев существует функция std::views::all. На основе типа входного объекта она понимает, можно ли от него брать ref_view, или объект временный и нужно его переместить в std::ranges::owning_view(отображение, владеющее диапазоном):

```cpp
auto s_view = std::views::all(s);
std::println("{}", s_view.base());

auto vec_view = std::views::all(std::vector{1, 2, 3});
for (const auto& item : vec_view.base()) {
	std::print("{} ", item);
}
// вывод:
// cosmos
// 1 2 3 
```

А что если мы хотим взять view только от части последовательности?

## Поддиапазоны

Для этого существуют поддиапазоны. Это тоже view, то есть невладеющий объект с парой начала и ограничителя, и задается он тоже через пару этих сущностей:

```cpp
std::string s = "Hello, World!";
auto it = s.find("World!");
auto sub = std::ranges::subrange(s.begin() + 7, s.end());
std::println("{}", sub.data());
// вывод: `World!`
```

В этом примере с помощью метода find, мы находим начало подстроки `World!` и создаем поддиапазон, начинающийся с начала подстроки и конца оригинальной строки.

Конечно же поддиапазон, как и обычный диапазон - это всего лишь начало и ограничитель. Мы можем создавать поддиапазоны с ограничиталями, которые не являются итераторами.

Давайте перепишем один из прошлых примеров с неограниченным поиском элемента в векторе с использованием subrange'а:

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};
auto pos = std::ranges::find(std::ranges::subrange(vec.begin(), std::unreachable_sentinel), 7);
```

Это особо ничего не меняет, однако показывает суть. Поддиапазоны помогают демонтировать нестандартные применения ограничителей. Давайте посмотрим совсем необычный пример:

```cpp
int accumulate(const std::ranges::input_range auto& coll) {
	int acc = 0;
	for (const auto& elem : coll)
		acc += elem;
	return acc;
}

template <auto V>
struct CustomSentinel {
	bool operator==(const auto pos) const {
		return *pos == V;
	}
};

std::vector<int> vec{1, 2, 3, 4, 5, 6, 7};
auto sr = std::ranges::subrange(vec.begin() + 1, CustomSentinel<5>{});
auto result = accumulate(sr);
std::println("{}", result);
// вывод: `9`
```

Мы берем поддиапазон от второго элемента вектора до такого элемента, чье значение равно 5. Поддиапазону все равно есть ли такой элемент в векторе. Ему это и не нужно. Единственное, что нужно от ограничителя - это возможность сравнения с ним итератора. А мы как раз реализовали `оператор==`, поэтому все требования выполнены. И мы легко может запускать любые вычисления на этом поддиапазоне. Когда настанет нужное время - итератор дойдет до такого элемента, значение которого равно 5 - вычисления закончатся.

Такого мы точно не могли сделать с помощью привычной нам STL. subrange - это простой инструмент, который поможет создавать самые разнообразные последовательности. 

Отметим важный момент. В примере выше мы использовали самописную функцию accumulate, потому что std::ranges::accumulate еще нет в стандарте.

Как думаете, почему мы не использовали std::accumulate?

*Кнопка* Элементарно, Ватсон

std::accumulate принимает 2 итератора на вход. А у нашего поддиапазона только один итератор и странный ограничитель.

Можем ли мы как-то извернуться и все-таки использовать std::accumulate? 

## Диапазоны общего вида

И оказывается, можем. Для этого есть отображение std::ranges::common_view. Оно делает хитрую штуку: маскирует ограничитель под итератор конца. Так можно сделать, потому что, чтобы по итератору конца понять, что последовательность закончилась, нужно просто сравнить текущий итератор с итератором конца. std::ranges::common_view оборачивает ограничитель в тип итератора начала, а реальное сравнение происходит с обернутым ограничителем:

```cpp
std::vector<int> vec{1, 2, 3, 4, 5, 6, 7};
auto cw = std::ranges::common_view{std::ranges::subrange(vec.begin() + 1, CustomSentinel<5>{})};
auto result = std::accumulate(cw.begin(), cw.end(), 0);
std::println("{}", result);
// вывод: `9`
```

Также любой диапазон, типы начала и ограничителя которого совпадают, называется common_range. Любые стандартные контейнеры - это common_range.

Получается, что диапазоны общего вида - это привычные нам последовательности, задаваемые двумя итераторами. Благодаря std::ranges::common_view мы можем использовать любые диапазоны, даже с самыми необычными ограничителями, со стандартными алгоритмами. Это полезный трюк, который поможет справиться с временными трудностями нехватки ranges аналогов некоторых стандартных алгоритмов и потенциальной недооптимизированности алгоритмов библиотеки ranges.

## Заключение

Сегодня вы узнали:
- Диапазон - это последовательность элементов, начинающаяся с итератора и заканчивающаяся ограничителем;
- Тип ограничителя может не совпадать с типом итератора. Это позволяет гибко создавать последовательности и делать их потенциально бесконечными.
- Отображение - это легковесный объект, который про последовательность знает всего 2 вещи - итератор на начало и ограничитель.
- Отображения позволяют делать универсальные view на любые последовательности и контейнеры с помощью std::ranges::ref_view и std::views::all.
- Поддиапазоны - это отображения, которые смотрят только на часть исходной последовательности.
- С помощью std::ranges::common_view можно использовать диапазоны со стандартными алгоритмами STL.










