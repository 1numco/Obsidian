
TODO: плохо работается с литеральными строками в прероцессоре



Директивы ifdef, ifndef, if
#новичкам

Иногда код, который мы пишем, должен зависеть от каких-то внешних параметров. Например, неплохо было бы довалять дебажный вывод при дебажной сборке. Или нам нужно написать кусочек платформоспецифичного кода и конкретная платформа передается нам наружными параметрами. Разные в общем бывают ситуации. Получается нам нужен какой-то механизм, который может проверять эти внешние параметры и в зависимости от их значений включать или выключать нужный кусок кода. Эту задачу можно решать по-разному. Сегодня мы обсудим доисторический способ, который, несмотря на свой почтенный возраст и опасность применения, активно используется в существующих проектах.

Этот способ - использование директив препроцессора #ifdef, #ifndef, #if. Все три - условные конструкции. Первая смотрит, определен ли в коде определенный макрос. Если да, то делаем одни действия, если нет - другие. Второй наоборот, входит в первую ветку условия, если макрос не определен, и входит во вторую, если определен. Директива #if проверяет какое-то условие, ничего необычного. Все три директивы могут иметь как полные формы(с веткой в случае если условие ложно), так и неполные(без "else"). Однако #ifdef и #ifndef не могут использовать директиву #elif по понятным причинам.

И вот в чем их прикол. Препроцессор работает с текстом программы. И он просто удаляет из этого текста ненужную ветку так, что до компиляции она даже не доходит, а нужная ветка как раз и подвергается обработке компилятором.

Например, у нас есть какой-то платформоспецифичный участок кода. Пусть это будет низкоуровневая оптимизация скалярного произведения на векторных инструкциях. Они разные для интеловских процессоров и для армов. Код может выглядеть примерно так:

```cpp
int DotProduct(const std::vector<int>& vec1, const std::vector<int>& vec2)
{
	int result = 0;
	#if CPU_TYPE == 0
		// mmx|sse|avx code
	#elif CPU_TYPE == 1
		// arm neon code
	#else 
		static_assert(0, "NO CPU_TYPE IS SPECIFIED");
	#endif
	return result;
}
```

Если каждое значение CPU_TYPE включает нужную ветку кода и убирает из текста программы все остальные. 

Если мы хотим оптимизировать только под интеловские процессоры, то можем написать чуть проще:

```cpp
int DotProduct(const std::vector<int>& vec1, const std::vector<int>& vec2)
{
	int result = 0;
	#ifdef OPTIMIZATION_ON
		// mmx|sse|avx code
	#else 
		for (int i = 0; i < vec1.size(); ++i)
			result += vec1[i] * vec2[i];
	#endif
	return result;
}
```
 //>

(Все примеры - учебные, все совпадения с реальным кодом - случайны, не повторяйте код в домашних условиях). Здесь мы проверяем директивой ifdef, определен ли макрос OPTIMIZATION_ON, сигнализирующий что нужно использовать векторные инструкции. Если да, то ключаем в текст программы оптимизированный код. Если нет - обычный.

Можно еще кучу примеров и приложений этим директивам привести. Но я хотел подчеркнуть именно вот эту особенность, что мы можем добавлять или выбрасывать определенные участки кода в зависимости от внешних параметров.

Широко известно, что такой способ не только устарел, но еще и опасен. Завтра посмотрим, чем конкретно.

Choose the right path. Stay cool.

#compiler 


Опасности использования директив препроцессора

Вчерашний способ выбора ветки кода имеет несколько недостатков:

1) Препроцессор работает с буквами/текстом программы, но не понимает программных сущностей. Это значит, что типабезопасность уходит из окна, и открывается простор для разного рода трудноотловимых багов.
   
2) При компиляции проверяется только та ветка, которая попадет в итоговый код. Если вы не протестировали свой код для разных значений внешних параметров, а такое бывает например когда пока что есть только одно значение, а другое будет только в будущем, а в будущем тесты естественно никто дописывать не будет. Тогда в этом будущем, когда значение параметра неожиданно изменится, в лучшем случае упадет сборка, а в худшем - это будет работать на проде и чудить одному Богу известные чудеса.
   
3) Вы ограничены возможностями препроцессора. Это значит, что вы не можете использовать в условии compile-time вычисления (аля результат работы constexpr функции).
   
4) Отсюда же вытекает отсутствие возможности проверки условий, основанных на шаблонных параметрах кода. Это все из-за того, что препроцессор работает до начала компиляции программы. Он в душе не знает, что вы вообще программу пишите. Ему в целом ничего не мешает обработать текст Войны и Мира. Именно из-за отсутствия понимания контекста программы, мы и не можем проверять условия, основанные на compile-time значениях или шаблонных параметрах. Если вы хотите проверить, указатель ли к вам пришел в функцию или нет, или собрать какую-то метрику с constexpr массива и на ее основе принять решение - у вас ничего не выйдет.
   
5) Вы очень сильно ограничены возможностями препроцессора. Попробуйте например сравнить какой-нибудь макрос с фиксированной строкой. Спойлер: у вас скорее всего ничего не выйдет. Например, как в примере из поста выше мы не можем написать так:

```cpp
int DotProduct(const std::vector<int>& vec1, const std::vector<int>& vec2)
{
	int result = 0;
	#if CPU_TYPE == "INTEL"
		// mmx|sse|avx code
	#elif CPU_TYPE == "ARM"
		// arm neon code
	#else 
		static_assert(0, "NO CPU_TYPE IS SPECIFIED");
	#endif
	return result;
}
```
Поэтому и приходилось определять тип циферками. 
Это конечно мем: сущность, которая работает с текстом программы, то есть со строками, не может работать со строками.

6) С препроцессором в принципе опасно работать и еще труднее отлаживать магические баги. Могут возникнуть например [вот такие ](https://habr.com/ru/companies/domclick/articles/593553/) трудноотловимые ошибки. Вам придется смотреть уже обработанную единицу трансляции, причем иногда даже не понимая, где может быть проблема. А со всеми включенными бинарниками и преобразованиями препроцессора это делать очень долго и больно. А потом оказывается, что какой-то умник заменил в макросах функцию DontWorryBeHappy на ILovePainGiveMeMore.

В комментах @xiran22 скидывал пример библиотечки, написанной с помощью макросов. Вот [она](https://github.com/GyverLibs/GyverOS/blob/main/src/GyverOS.h), можете посмотреть. Это не только пример сложности понимания кода и всех проблем выше. Тут просто плохая архитектура, затыки которой решаются макросами. 


if constexpr