
ОРы:
- понимает понятие проекции Квиз 1
- понимает реализацию std::invoke Квиз 2
- применяет std::invoke для вызова любого Callable Квиз 3
- применяет проекции для получения отдельных членов структур или классов Тренажер после урока

Структура:

- Перед рассказом о проекциях нужно нужно поговорить о вызываемых сущностях. Перечисляем известные нам вызываемые сущности. Дальше говорим, что в шаблонном коде бывает полезно вызвать любую такую сущность единообразно. Для этого есть std::invoke. Показываем примерную реализацию std::invoke. (ОР: понимает реализацию std::invoke)
- Вопрос: а что будет, если в std::invoke передать указатель на поле класса? invoke просто разыменует его. По итогу у нас есть все callable сущности и можно их всех перечислить. (ОР: применяет std::invoke для вызова любого Callable)
- Как это применяется в рэнджах. Начинаем с ranges::sort с лямбдой. Говорим, что не всегда удобно сравнивать так, потому что код повторяется,  и на самом деле есть проекции - callable сущность, которая применяется к каждому элементу диапазона перед тем, как обработать его.  Показываем сигнатуру  ranges::sort(ОР:применяет проекции для получения отдельных членов структур или классов)


## Введение

Проекции - одно из нововведений в С++20, связанных с диапазонами. Они позволяют удобно преобразовывать элементы диапазонов перед их обработкой. Сегодня вы узнаете:

- Какие сущности в С++ можно вызывать, как функции;
- Для чего предназначена шаблонная функция std::invoke;
- Какие сущности называются Callable;
- Что такое проекции и как их использовать;


Для полноценного понимания проекций, нам нужно коснуться другой важной темы.

## Вызываемые сущности

Давайте представим, что вы разрабатываете библиотеку для обработки событий, и нам нужно реализовать функцию `call_callback`, которая принимает произвольный обработчик событий и вызывает его.

```cpp
template <typename Callback, typename... Args>
void call_callback(Callback&& cb, Args&&... args);
```

Что мы, как пользователи библиотеки теоретически можем передать этой функции в качестве параметра? То есть, какие сущности в С++ мы можем вызывать, как функции?

1 Указатели на функции. 
Когда мы просто передаем имя функции в call_callback, это имя приводится к типу указателя на функцию:

```cpp
void free_function(int a) {
	std::println("Free function: {}", a);
}

call_callback(free_function, 42);
```

Также мы можем явно определять указатели на функции  и передавать их в качестве коллбэков. Вызов указателя на функцию эквивалентен вызову функции.

Так, мы например можем вызвать статический метод класса через указатель на него:

```cpp
struct Handler {
	static void static_method(int a) {
		std::println("Static method: {}", a);
	}
};

auto static_method_ptr = &Handler::static_method;
call_callback(static_method_ptr, 42);
```

2 Функторы или функциональные объекты. То есть объекты классов с реализованным оператором operator() или оператором приведения к указателю на функцию.

Отличным примером функторов являются лямбды:

```cpp
call_callback(
    [](int a) {
        std::println("Lambda: {}", a);
    }, 42);
```

3 Указатели на нестатические методы класса.
Нестатические методы класса - это такие же функции, только они принимают первым неявным параметром указатель или ссылку на объект, с которым будет работать метод:

```cpp
struct Handler {
	void member_function(int a) {
		std::println("Member method:: {}", a);
	}
};
Handler handler;
call_callback(&Handler::member_function, handler, 42); // работает как с именем объекта
call_callback(&Handler::member_function, &handler, 42); // так и с указателем на него
```

## std::invoke

Хорошо, мы поняли, с чем может работать функция call_callback. Но как эта функция может быть сама реализована?

Попробуем написать влоб:

```cpp
template <typename Callback, typename... Args>
void call_callback(Callback&& cb, Args&&... args) {
	std::forward<Callback>(cb)(std::forward<Args>(args)...);
}
```

Как думаете, в этой реализации есть проблемы?

*Кнопка* Я знаю ответ!

Эта реализация прекрасно работает с указателями на функции и функциональными объектами, но не будет работать с нестатическими методами классов. Для того, чтобы вызвать нестатический метод класса через указатель на него используется следующий синтаксис:

```cpp
(object.*member_function_pointer)(args...);
```

И этот синтаксис не стыкуется с текущей реализацией call_callback.

Что делать?

На помощь приходит стандартная функция std::invoke. Мы может просто передать ей вызываемую сущность и параметры для ее вызова и она сама все сделает. Реализация call_callback с помощью std::invoke выглядит так:

```cpp
template <typename Callback, typename... Args>
void call_callback(Callback&& cb, Args&&... args) {
    std::invoke(std::forward<Callback>(cb), std::forward<Args>(args)...);
}
```

Чтобы понять, как примерно std::invoke работает, давайте посмотрим на ее упрощенную реализацию:

```cpp
#include <type_traits>
#include <utility>

namespace detail {
    // Реализация для указателей на методы
    template <class T, class Type, class T1, class... Args>
    constexpr auto invoke_impl(Type T::* pmd, T1&& t1, Args&&... args)
        -> std::enable_if_t<std::is_member_function_pointer_v<decltype(pmd)>,
            decltype((std::forward<T1>(t1).*pmd)(std::forward<Args>(args)...))>
    {
	    // используем конкретный синтаксис вызова для указателей на методы классов
        return (std::forward<T1>(t1).*pmd)(std::forward<Args>(args)...);
    }

    // Реализация для остальных вызываемых сущностей
    template <class F, class... Args>
    constexpr auto invoke_impl(F&& f, Args&&... args)
        -> decltype(std::forward<F>(f)(std::forward<Args>(args)...))
    {
	    // привычный синтаксис вызова
        return std::forward<F>(f)(std::forward<Args>(args)...);
    }
}

// Основная функция invoke
template <class F, class... Args>
constexpr auto invoke(F&& f, Args&&... args)
    -> decltype(detail::invoke_impl(std::forward<F>(f), std::forward<Args>(args)...))
{
	// вызов перенаправляется в подходящую перегрузку
    return detail::invoke_impl(std::forward<F>(f), std::forward<Args>(args)...);
}
```

Мы отбросили незначительные на данный момент детали, чтобы вы поняли суть. Вызов главной функции перенаправляется в подходящие перегрузки имплементации.

Получается, что std::invoke позволяет единообразно вызывать все функции-подобные сущности в С++. Замечательная вещь!

А давайте проверим вашу интуицию. Не обращая внимания на приведенную выше реализацию std::invoke(она была лишь упрощением), ответьте на вопрос: Каков будет результат вызова std::invoke, если в качестве вызываемой сущности ей передать указатель на поле класса?

```cpp
struct Data {
    int value = 42;
};

auto member_field_pointer = &Data::value;
Data data;
auto res = std::invoke(member_field_pointer, data);
```

*Кнопка* Ну не томите уже!

На самом деле это валидный сценарий использования std::invoke и в переменной res будет храниться число 42. 

То есть "вызов" поля класса в результате выдает значение этого поля. Этот факт очень важен в нашем скором разговоре о проекциях в диапазонах.

В С++ все сущности, которые можно "вызвать" с помощью std::invoke называются Callable сущности. Давайте финально их перечислим:

-  Указатели и ссылки на функции. 

-  Функторы.

-  Указатели на нестатические методы класса.

- Указатели на нестатические поля класса.

## Проекции

Наконец мы начинаем разговор о том, зачем мы здесь сегодня собрались. Библиотека диапазонов предоставляет нам аналоги стандартных алгоритмов, которые "заточены" под работу с диапазонами. Возьмем к примеру std::ranges::sort и попытаемся с помощью этой функции отсортировать людей по возрасту:

```cpp
struct Person {
    std::string name;
    int age;
};

std::vector<Person> people = {
	{"Alice", 30},
	{"Bob", 25},
	{"Charlie", 35}
};

std::ranges::sort(people, [](const Person& a, const Person& b) {
	return a.age < b.age; // Сортировка по возрастанию возраста
});
```

Это работает, однако пока все как с обычной std::sort. Лямбдой задается порядок между объектами. Никаких преимуществ, да еще и код повторяется, так как мы 2 раза берем поле age у объектов.

В таком виде действительно нет никаких преимуществ. Однако давайте взглянем на сигнатуру этой функци сортировки:

```cpp
template<ranges::random_access_range R, class Comp = ranges::less,  
          class Proj = std::identity>  
requires std::sortable<ranges::iterator_t<R>, Comp, Proj>  
constexpr ranges::borrowed_iterator_t<R>  
    sort( R&& r, Comp comp = {}, Proj proj = {} );
```

У этой функции помимо параметра диапазона и компаратора есть третий параметр. Это и есть наша долгожданная проекция.

Проекция - это Callable параметр алгоритмов библиотеки ranges, который позволяет преобразовывать элементы диапазона перед каждой обработкой конкретного элемента, при этом не изменяя сам элемент. Этот параметр как бы "проецирует" элементы из множества объектов диапазона в другое множество значений, которое и будет реально обрабатываться.

Дефолтный параметр проекции - std::identity. Это функтор, который возвращает свой аргумент в неизменном состоянии. То есть это проекция элемента на самого себя.

Можно определить свою кастомную проекцию. Если мы хотим сортировать людей по возраста, то можно написать так:

```cpp
std::ranges::sort(people, {}, [](const Person& a) {
	return a.age; // Сортировка по возрастанию возраста
});
```

По умолчанию компаратор сравнивает проекции элементов с помощью std::ranges::less, что нам и нужно, поэтому можно ничего не передавать вторым параметром. Третьим параметром идет проекция, которая преобразует объект типа Person в значение поля age типа int. И в этом случае сортировка будет идти с полю age.

Но давайте вспомнил, что Callable сущностями могут быть указатели по поля классов. А что если...:

```cpp
std::ranges::sort(people, {}, &Person::age);
```

И да, это прекрасно работает!

Благодаря проекциям вы можете отказаться от использования лямбд, если вы хотите обрабатывать только одно поле класса.

Большинство алгоритмов библиотеки диапазонов поддерживают параметр проекции, поэтому в некоторых случая с его помощью вы можете упростить код, улучшить его понимание и убрать повторение кода.

## Заключение

Сегодня вы узнали:

- Callable сущностями в C++ являются указатели и ссылки на функции, функциональные объекты и указатели на нестатические поля и методы классов.
- Шаблонная функция invoke предназначена для унификации вызова Callable сущностей.
- Проекции - это параметры алгоритмов диапазонов, которые позволяют превращать элементы диапазона в другие значения.
- С использованием проекций можно предотвратить дупликацию кода и улучшить его читаемость.