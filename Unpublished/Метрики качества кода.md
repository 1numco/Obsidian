Метрики качества кода
#опытным 

Качество кода - вещь довольно субъективная. Одному нравится auto, потому что можно сконцентрироваться на логике происходящего и не видеть детали. Другой ненавидит auto, потому что теряется информация о типах и он не понимает, что происходит в коде.

Однако есть какие-то более менее объективные критерии и метрики грамотного проектирования и написания кода, которые работают в 95% случаев, независимо от языка.

Есть метрики, измеряемые в одной функции. В основном они завязаны на когнитивной нагрузке, которую испытывает программист при чтении кода. Чем больше ему надо держать в голове, тем сложнее код.

Есть метрики, касающиеся проектирования. Они показывают, насколько код легко код можно поддерживать и расширять.

Сегодня мы перечислим эти метрики вместе с очень короткой справкой. В дальнейших постах будем рассматривать каждую из них более глубоко.

1 Цикломатическая сложность. Измеряет количество возможных путей исполнения кода внутри функции. Чем больше путей, тем сложнее код.

2 Количество строк кода. Тут пояснения вряд ли нужны.

3 Количество параметров функции. Same.

4 Количество методов и полей в классе. Большое число мемберов может говорить о том, что у класса много ответственности.

4 Глубина вложенности. Чем больше ваш код сдвигается вправо и чем больше он похож на стрелу, тем хуже.

5 Комментарии в коде. Тут скорее про кододокуметацию, автоматичеески отследить полезность комментариев не представляется возможным.

6 Покрытие кода тестами. Чем больше путей исполнения кода покрыты тестами, тем лучше.

7 Метрики Холстеда. Набор сложных формул и значений, которые комплексно оценивают качество кода. Без бутылки не разберешься.

8 Глубина наследования. Больше глубина - сложнее код.

9 Метрики Мартина, связность и зацепление - степень зависимости класса от других классов.

В любом случае, метрики - это конечно хорошо, но это лишь ориентиры и цифры. Единственное, что нужно всегда держать за аксиому - ваши коллеги должны легко читать и понимать ваш код. Принимать решения надо на основе конкретной ситуации.

Measure quality. Stay cool.

#design 



Глубина вложенности
#новичкам

В этом посте мы узнали, какие конструкции языка ответственны за рост цикломатической сложности. Это циклы, условия, свитчи и обработка исключений. В них нет ничего плохого, но большое их количество заставляет программиста держать в голове возможные пути исполнения программы.

Но не только в этом проблема. Давайте посмотрим на пример:

```cpp
void badExample() {
    if (condition1) {
        for (int i = 0; i < n; i++) {
            while (condition2) {
                if (condition3) {
                    if (condition4) {  // too deep
                        // some logic
                    }
                }
            }
        }
    }
}
```

Тут не то, что нужно держать в голове возможные пути. Тут бы вообще понять, как я оказался внутри четвертого условия. 

Чем больше вложенных конструкций в коде, тем больше программисту нужно запоминать происходящего в коде, чтобы понять обстановку текущей строчки. Все меньше декларативности и все больше деталей появляется в коде.

Поэтому и придумали метрику глубины вложенности, чтобы отражать этот аспект когнитивной нагрузки кода. Значение метрики равно максимальному количеству уровней вложенности управляющих конструкций (if, for, while, switch, try-catch) внутри функции или метода. 

```cpp
// Уровень 0
void function() {
    // Уровень 1
    if (condition1) {
        // Уровень 2
        for (int i = 0; i < n; i++) {
            // Уровень 3
            while (condition2) {
                // Уровень 4
                if (condition3) {
                    // Уровень 5 - максимальная глубина!
                }
            }
        }
    }
}
// Общая глубина вложенности = 5
```

Ориентировочные цифры метрики такие:

- 1-3 - так держать, код читается легко
- 4-5 - чтение кода требует внимания
- >= 6 - код понимает только его автор и то только первые 1.5 минуты после коммита. Нужен рефакторинг.

Бороться с вложенностью можно несколькими способами, некоторые из которых мы отдельно рассмотрим.

Но есть один интересный способ, который поможет не допустить высокой вложенности. Можно использовать fibonacci tabbing. Количество отступов на N-ом уровне соответствует N-ому числу из последовательности Фибоначчи. Выглядит это [примерно так](https://www.google.com/url?sa=i&url=https%3A%2F%2Fwww.linkedin.com%2Fposts%2Fevvic_deeply-nested-statements-are-discouraged-activity-7353600148578463744-OIWu&psig=AOvVaw3IoOAfjii-IbxSgw7RiJ4b&ust=1762885560572000&source=images&cd=vfe&opi=89978449&ved=0CBUQjRxqFwoTCPCW0s6a6JADFQAAAAAdAAAAABA2). При этой технике 6-ой уровень улетает куда-то за границу видимой вселенной(рамки монитора), что автоматически стимулирует вас решать проблему.

Don't go too deep. Stay cool.

#design 



Находясь внутри 

Каждая такая конструкция обычно содержит свой скоуп, то есть ограниченный блок инструкций с отступом. Но что, если вы большой любитель 

![](https://miro.medium.com/v2/resize:fit:1400/0*uLS-SbbFtjP3u9F4.png)


Early Bailout
#новичкам 

Мы поняли, что глубина вложенности влияет на восприятие кода. По возможности, нужно стараться делать код более линейным без 100500 вложенных if'ов и прочих циклов.

И на этот счет есть даже специальная техника. Называется "ранний выход" или 
early return" или "early bailout".

Идея простая - как только мы понимаем, что исполнение на каком-то условии прерывается, то надо в коде сразу выходить из функции.

Например, есть у вас такой код обработки http запроса:

```cpp
HttpResponse handleRequest(const HttpRequest& request) {
    HttpResponse response;
    
    if (request.method == "GET" || request.method == "POST") {
        if (request.headers.contains("Content-Type")) {
            if (request.body.size() <= MAX_BODY_SIZE) {
                if (authService.validateToken(request.token)) {
                    // Основная логика обработки
                    response = processBusinessLogic(request);
                } else {
                    response.status = 401;
                    response.body = "Unauthorized";
                }
            } else {
                response.status = 413;
                response.body = "Payload too large";
            }
        } else {
            response.status = 400;
            response.body = "Missing Content-Type";
        }
    } else {
        response.status = 405;
        response.body = "Method not allowed";
    }
    
    return response;
}
```

Вроде обычный код, но не просто держать в голове при каких условиях какие статусы заполняются. Да и условие и заполнение ответа находятся далеко друг от друга по коду, можно легко все перепутать.

А теперь мы применяем early bailout:

```cpp
HttpResponse handleRequest(const HttpRequest& request) {
    // Early bailout для невалидных запросов
    if (request.method != "GET" && request.method != "POST") {
        return HttpResponse(405, "Method not allowed");
    }
    
    if (!request.headers.contains("Content-Type")) {
        return HttpResponse(400, "Missing Content-Type");
    }
    
    if (request.body.size() > MAX_BODY_SIZE) {
        return HttpResponse(413, "Payload too large");
    }
    
    if (!authService.validateToken(request.token)) {
        return HttpResponse(401, "Unauthorized");
    }
    
    // Основная логика - только для валидных запросов
    return processBusinessLogic(request);
}
```

Мы сразу же проверяем корректность пришедшего запроса и если что-то не так - сразу даем ответ. И только если реквест корректный, мы переходим к реальной обработке.

Не нужно запоминать путь из условий, который нужно пройти, чтобы попасть к полезной части работы функции.

Это не всегда работает, потому что в else тоже может быть какая-то логика, условия могут быть внутри циклов и тд. Но сейчас не об этом.

Если можно предотвратить превращение кода в стрелу с помощью раннего выхода, то это точно нужно сделать. Исполнение будет следовать порядку инструкций в коде: чем раньше инструкция в коде, тем раньше она в реальности выполнится. Код станет более понятным и последовательным. 

Return early. Stay cool.

#design #goodpractice 