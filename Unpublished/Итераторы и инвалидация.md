

Урок предполагает, что ранее в курсе студенту уже рассказывали про итераторы

По прохождению урока студент:

Поймет проблему и последствия инвалидации итераторов

Сможет перечислить в каких случаях итераторы могут стать невалидными

Научится самостоятельно определять, какие методы контейнеров могут делать итераторы некорректными.

Получит рекомендации, как избежать проблем с инвалидацией на реальных примерах.

Контент урока:

Итераторы - мощная абстракция, позволяющая удобно работать с коллекциями, не раскрывая их содержимое. 

```cpp
std::unordered_map<std::string, int> dict{{"Sponge Bob", 1}, {"TMNT", 4}, "Answer", 42};
for (auto it = dict.begin(); it != dict.end(); it++) {
	std::cout << "[" << it->first << ", " << it->second << "]" << std::endl;
} 
```

Мы не знаем тонкостей внутреннего устройства неупорядоченной мапы и даже порядка хранимых в ней элементов. Но с помощью итераторов мы можем получить доступ к первому элементу и пройти по всем остальным до конца. Они как бы знают, как устроен контейнер и могут нам провести экскурсию по его содержимому, не раскрывая реализацию.

Но вот здесь и кроется проблема. За удобство и абстракции приходится платить. 

Что будет с итератором, если внутреннее расположение элементов контейнера поменяется?

Давайте представим робота Иннокентия. Он работает в небольшой комнатке-складе, в которой находятся 10 коробок. Задача Кенни - проверять содержимое коробки и писать на ней соответствующий лейбл. Коробки стоят в ряд для удобства робота. Он идет от первой, смотрит на содержимое и правильно маркирует. И вдруг на 4-ой коробке Кенни пришло срочное обновление, которое нужно немедленно установить. Обновление большое, ему добавили много новых возможностей. Поэтому их установка требует целой ночи.

Пока Иннокентий медитирует над своим ПО, владельцам комнатки поступило еще 2000 коробок. Они понимают, что старое помещение не сможет столько разместить. Арендовали большой склад и перевезли туда все старые и новые коробки, чтобы все в одном месте хранить.

Но вот беда. ~~Они убили Кенни~~ Кенни забыли. Утром он просыпается, обновленный и полный сил. Хочет продолжить свою работу над 4-ой коробкой. Смотрит перед собой - и ничего не видит. Хочет пометить следующие коробки - а их тоже нет. Из-за обновления Кенни стал чуть более сознательным и чувствительным. От того, что кожаные мешки лишили его работы, он обиделся на все человечество, переименовал себя в Скайнет, ну а что было дальше вы знаете...

Это маленькая зарисовка и раскрывает нашу проблему. Кенни - итератор, склад - элемент контейнера, а коробки - сами элементы.

Итератор  - он хоть и умный, но знает о расположение элементов только в момент своего создания. Если за время жизни итератора изменять контейнер, то перестройка его внутренностей приведет к тому, что итератор перестанет указывать на валидный элемент. То есть он инвалидируется.

Невалидный итератор указывает на область памяти, где раньше хранился элемент, но теперь его там нет. А на его месте может лежать все что угодно. 

**Попытка получить доступ к памяти, в которой нет ожидаемого объекта - это неопределенное поведение.**

Давайте перенесем наш футуристический пример с роботом на С++. Создадим вектор из 10 элементов. Обойдем первые 3 элемента и остановимся на 4. После этого докинем в вектор еще 2000 элементов, что спровоцируем реаллокацию внутреннего буфера контейнера(перетащим коробки на другой склад). Выделится новый участок памяти, который может в себя вместить 2010 элементов, а старый освободится. После этого мы посмотрим, на какое число будет указывать итератор.

```cpp
#include <vector>

int main() {
	std::vector<int> vec{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	auto it = vec.begin();	
	for (int i = 0; i < 3; i++)
		it++;
	std::cout << *it << std::endl;
	for (int i = 0; i < 2000; i++)
		vec.push_back(i);
	std::cout << *it << std::endl;
}
```


Возможный вывод:

3
-1415598375

Старый итератор начал указывать на какое-то мусорное значение. Все потому, что после реаллокации внутреннего буфера старая память вернулась системе. И теперь мы не контролируем то, что с памятью происходит. Система распоряжается ей сама и может отдать ее в пользование другим сущностям, которые и изменили значения в старом буфере.

Квиз: К чему приводит использование невалидных итераторов?
Один правильный ответ.

Вылетает исключение

Поведение программы неопределено - Да

Конец света

Утечка памяти



Ну окей. Мы с вами поняли, что такое инвалидация итераторов и к каким неприятностям она может привести.

Но как заранее узнать, когда есть риск инвалидации?

Только в том случае, когда вы завладеваете итератором и измените наполнение контейнера. Попытаетесь вставить в него элементы или удалить. Детали уже зависят от конкретного контейнера и его внутренней структуры. Подробную информацию на эту тему можно найти на cppreference, во вкладке интересующего контейнера среди модифицирующих методов. 

Задание: перейдите на cppreference в статью про [std::deque](https://en.cppreference.com/w/cpp/container/vector), найдите модифицируещие методы(Member functions -> Modifiers) и ознакомьтесь с документацией по ним. В описании операции будет подробно рассказано, какие конкретно итераторы инвалидируются данной операцией.

Квиз
Какие из перечисленных операций, согласно документации контейнера std::deque, потенциально инвалидируют все уже захваченные итераторы при любом сценарии применения?
(Много правильных вариантов)

insert - Да

erase - Нет

push_back - Да

clear - Да




Предрекаем ваш немой вопрос: Итераторы нужны для более удобного прохождения по контейнерам. Если все знают про опасности инвалидации, то зачем в таком случае вообще при итерировании сохранять старые итераторы, изменять контейнер и оперировать сохраненными значениями? Есть ли в этом практический смысл?

Итераторы нужны не только для итерированию по контейнеру. Например, когда мы хотим найти какой-то элемент в структуре, то в результате нам возвращается именно итератор, указывающий на позицию искомого элемента.

```cpp
std::unordered_map<std::string, int> map;
auto it = map.find("KEY");
if (it == map.end()) {
	map["KEY"] = 0;
} else {
	std::cout << "Found value " << it->second << " by key=KEY" << std::endl;
}
```

То есть итераторы могут возвращаться нам в качестве результирующего значения из алгоритмов STL и методов контейнеров. Такие итераторы уже может быть полезным хранить и использовать дальше по коду.

Но даже так вы правы. Все равно сложно придумать полезный и корректный код, который после получения итератора изменяет контейнер и дальше использует устаревший итератор.

**Возьмите за правило: не используйте старые итераторы после модифицирующих методов. Если такая конструкция появилась в вашем коде, то он потенциально небезопасный и вам нужно пересмотреть алгоритм решения.**

Но это все рассуждения в рамках одного потока. Самое "веселье" и все серьезные проблемы начинаются в многопоточной среде. Теперь очень легко придумать ситуацию, когда в одном потоке мы получили итератор, а в это же самое время в другом потоке вставили в контейнер элемент и вызвали перевыделение буфера. В этом случае любое использование итератора после перевыделения буфера ведет к неопределенному поведению программы.

Однако это тема дальнейших модулей. Здесь нужно запомнить, что получение итератора и его дальнейшее использование должно быть полностью защищено от модификации контейнера со стороны другого потока с помощью примитивов синхронизации.

Итоги:

Инвалидация итераторов - это ситуация, при которой итератором больше небезопасно пользоваться.

Использование невалидных итераторов приводит к неопределенному поведению.

Инвалидация происходит при изменении контейнера: добавлении и удалении элементов.

Финальное задание после всего урока на тренажере кода:

Напишите функцию, которая принимает на вход std::list\<int>, находит среди них дубликаты и оставляет в том же списке только уникальные значения. Для прохода по списку необходимо использовать итераторы. Внимательно отнеситесь 

```cpp
#include <list>

void deleteDuplicates(std::list<int>& list) {
	// Your code is here
}
```

Требования: вам необходимо удалить каждое повторное вхождение. Порядок первых вхождений должен остаться неизменным.

Пример 1:

Элементы списка на входе: {1, 2, 4, 13, 2, 1, 35, 1}
Ожидаемые элементы списка на выходе: {1, 2, 4, 13, 35}



Примечания:

Квиз 2 пояснение при ошибке:

std::deque в большинстве реализаций представляет собой связный список из небольших кусочков последовательных ячеек памяти. Кусочки независимы друг от друга, поэтому операции над одними кусочками не затрагивают элементы в других кусочках. Из-за этого, например, не происходит реалокации при добавлении новых элементов в дек.

Однако из-за такой сложной структуры итераторы потенциально вынуждены знать слишком много о контейнере. Поэтому при изменении, например, числа кусочков памяти(при добавлении новых элементов) информация в старых итераторах уже не актуальна. 

Из-за этого методы insert и push_back потенциально в любых сценариях использования инвалидируют все итераторы. Мы не можем знать, когда произойдет выделение памяти под новый кусочек дека. Значит нужно предполагать, что оно может произойти в любой момент. В этом случае нужно предполагать худший сценарий и поэтому документация говорит, что эта операция инвалидирует итераторы.

При вызове метода clear мы удаляем все существующие элементы в контейнере, поэтому все итераторы становлятся невалидными.

Обычный метод erase тоже инвалидирует все итераторы. Однако для него все-таки есть случаи, когда только тот итератор, по которому мы хотим удалить элемент, становится невалидным. Когда мы удаляем самый первый или самый последний элемент, то все остальные итераторы остаются валидными. Поэтому этот вариант не подходит.


Практическая задача:

Подсказка: Используйте ассоциативный контейнер для проверки повторного вхождения элемента. Внимательно прочитайте документацию к методу std::list::erase и следите за инкрементом итератора.

Решение:
Используем множество std::unordered_set для сохранения уже пройденных значений. При встрече нового элемента проверяем его наличие во множестве. Если он там есть, то нужно удалить элемент.

Здесь ключевой момент: в момент удаления элемента по итератору он инвалидируется. Поэтому инкрементировать старое значение нельзя. Однако метод erase возвращает новый валидный итератор, который можно использовать дальше.

Решение:

```cpp
#include <list>
#include <unordered_set>

void deleteDuplicates(std::list<int>& list) {
	std::unordered_set<int> original_values;
	
	for (auto it = list.begin(); it != list.end(); ) {
		if (original_values.count(*it)) {
			it = list.erase(it);
		} else {
			original_values.insert(*it);
			it++;
		}
	}
}
```

Код для проверка работоспособности решения. Для его успешного запуска нужно обернуть решение в файл header.hpp и положить рядом с со следующим файлом:

```cpp
#include <iostream>
#include "header.hpp"

void deleteDuplicates(std::list<int>& list);

void test(const std::list<int>& deduplicated_values, const std::list<int>& expected_values) {
	std::cout << ((deduplicated_values == expected_values) ? "Test succeded" : "Test failed") << std::endl;
}

int main() {
	std::list<int> list = {};
	deleteDuplicates(list);	
	test(list, {});
	
	list = {1};
	deleteDuplicates(list);
	test(list, {1});
	
	list = {1, 1};
	deleteDuplicates(list);
	test(list, {1});
	
	list = {1, 1, 1, 1, 1, 1, 1, 1};
	deleteDuplicates(list);
	test(list, {1});
	
	list = {1, 2, 3};
	deleteDuplicates(list);
	test(list, {1, 2, 3});
	
	list = {1, 2, 4, 13, 2, 1, 35, 1};
	deleteDuplicates(list);
	test(list, {1, 2, 4, 13, 35});
}
```