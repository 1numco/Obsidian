
ОРы:

- применяет продвинутые адаптеры С++23 (**enumerate**, chunk, **chunk_by**, **zip**, **cartesian_product** ..)
- применяет адаптеры диапазонов из C++26 (**adjacent_filter**, **linear_distribute**, set_difference, **tail**, **split_when**)

Структура:

группы алгоритмов
1 Сегментация данных
- chunk - разбиение диапазон на пачки одинакового размера. На примере батчевых запросов к базе.
- chunk_by - разбиение диапазона по условию на смежных элементах. На примере определения выбросов из среднего уровня значений последовательности.
- split_when - разбиение диапазона по условию. На примере разбиения текста по предложениям с разделителями ".", "!" и "?".
2 Фильтрация
- tail - убирает первый элемент. На примере особенной обработки последнего элемента мапы.
- adjacent_filter - фильтрация диапазона по соседним элементам. На примере обнаружения аномалий в трафике(слишком частоидущие пакеты).
- set_difference - показывает разницу между двумя отсортированными последовательностями. На примере разницы в содержимом директорий
3 Объединение последовательностей:
- zip - объединение нескольких диапазонов в тупл. На примере объединения параметров и ожидаемых результатов в тестах
- enumerate - добавление индекса к последовательности. На примере дампа результов обработки каждого N-ого элемента диапазона.
- cartesian_product - декартово произведение. На примере генерации координатной сетки
4 Математические операции
- linear_distribute - генерация равномерно распределенных чисел между двух чисел. На примере генерации точек для построения графика.


## Введение

В прошлом уроке мы затрагивали только базовые адаптеры диапазонов. На самом деле в стандартной библиотеке множество адаптеров диапазонов, которые позволяют очень гибко изменять элементы последовательностей. Сегодня вы узнаете:

- какие адаптеры позволяют разбивать данные на сегменты.
- с помощью каких инстументов можно гибко выделить из диапазона нужные элементы.
- какие есть способы объединения нескольких диапазонов.
- как генерировать последовательности для математических вычислений.

## Адаптеры диапазонов

С++20 принес нам прекрасную библиотеку диапазонов. Как это бывает с большинством нововведений в стандарт, у диапазонов есть так сказать прародитель - библиотека [ranges-v3](https://github.com/ericniebler/range-v3). Все алгоритмы и отображения из v3 постепенно адаптируют и переносят в стандарт. Вот дорожные карты по обогащению стандарта из ranges-v3 в [С++23](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2214r2.html#the-group_by-family) и в [С++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2214r2.html#the-group_by-family) . Много полезных адаптеров уже перенесли в std, однако в данном уроке мы будет рассматривать также адаптеры v3, так как они рано или поздно попадут в стандарт. В данном уроке упоминание стандартных адаптеров начинается с пространства имен `std`, а адаптеров ranges-v3 начинается с пространства имен `ranges`.

Чтобы немного систематизировать рассказ, разобьем адаптеры на группы по выполняемым функция.

## Сегментация данных

Пусть у вас есть вектор 1000 запросов к базе данных, и вы хотите обрабатывать их пачками по 10, чтобы каждый запрос обрабатывался на своем коннекшене. Для такой задачи отлично подойдет std::views::chunk, который помогает разбить диапазон на порции одинакового размера:

```cpp
auto data = get_database_request();
for (auto batch : data | std::views::chunk(10)) {
	// Отправляем пачкой запросы и получаем фьючерс результата
    auto future_result = db.request_batch(batch);
    // дожидаемся результата
    future_result.wait();
    // далее обрабатываем результат
    // ...
}
```

std::views::chunk принимает всего 1 аргумент и возвращает отображение из поддиапазонов исходного диапазона. Элементы в поддиапазонах не пересекаются и их размер одинаковый, за исключением последнего - в нем может находится меньше элементов, так как размер исходного диапазона не всегда кратен размеру чанка.

Но что, если вам хочется разбивать диапазона не на чанки равной длины, а на основании отношений между двумя соседними элементами? 

Например, у вас есть данные датчика температуры, и нужно найти периоды, когда она была стабильна (±0.5°C). Для этого существует адаптер std::views::chunk_by. Он принимает функтор от двух параметров, которые представляют собой соседние элементы последовательности. Если функтор возвращает true, то оба элемента относятся к одному чанку, в обратном случае - к разным.

```cpp
auto sensor_data = {20.1, 20.3, 20.4, 22.0, 21.0, 21.1, 20.9, 20.8};
auto stable_periods = sensor_data | std::views::chunk_by([](double a, double b) {
	return std::abs(b - a) < 0.5; // Группируем "стабильные" значения
});

for (auto period : stable_periods) {
	std::print("Period: ");
	for (auto i : period)
		std::print("{} ", i);
	std::println("");
}
// Вывод:
// Period: 20.1 20.3 20.4 
// Period: 22 
// Period: 21 21.1 20.9 20.8 
```

В библиотеке ranges-v3 есть похожая функция, которая позволяет разбивать диапазон на части - ranges::views::split_when. Этот адаптер принимает унарный предикат от элемента диапазона и разбивает исходную последовательность на поддиапазоны, когда предикат оказывается истинным. 

С помощью ranges::views::split_when можно, например, разделить текст на предложения:

```cpp
std::string text = "Hello! How are you? I'm fine...";
auto sentences = text | ranges::views::split_when([](char c) { return c == '.' || c == '!' || c == '?'; });

for (auto sentence : sentences) {
	std::println("sentence: '{}'", std::string(&*sentence.begin(), ranges::distance(sentence)));
}
// Вывод:
// sentence: 'Hello'
// sentence: ' How are you'
// sentence: ' I'm fine'
```

Предложения оканчиваются либо точкой, либо вопросительным или восклицательным знаком. Именно эти символы и детектирует предикат и по ним разделяется текст на предложения. Обратите внимание, что разделительные символы не включаются в поддиапазоны.

Учитывайте, что все адаптеры - это все еще отображения. То есть начало и ограничитель последовательности. Они могут хранить только последовательно расположенные элементы. Поэтому все сегментирующие адаптеры диапазонов разделяют последовательность либо на поддиапазоны фиксированного размера, либо на основании значений элементов или отношения смежных элементов.

Если вам нужно сделать что-то вроде group_by, то есть разделить все элементы последовательностей на группы на основании их идентичности, то адаптеры здесь бессильны.

## Фильтрация

А что, если мы хотим выделить из последовательности только нужные нам данные? Безусловно, мы с вами уже изучили std::views::filter, это мощный инструмент. Но что если нам нужно принимать решения на основе отношения между соседними элементами последовательности?

Например, у вас есть вектор сетевых пакетов и вы хотите найти среди из них DDoS-атаку, то есть пакеты, временная метка которых будет отстоять от метки предыдущего пакета на очень маленькую величину. Для решения этой задачи нам поможет ranges::views::adjacent_filter. Этот адаптер принимает предикат от двух смежных элементов и если он истинный, то элемент попадает в результирующее отображение.

```cpp
struct Packet {
	Payload payload;
	Timestamp ts;
};
auto packets = get_network_packets();
auto suspicious = packets | std::views::adjacent_filter([](auto&& a, auto&& b) {
    return b.ts - a.ts < 1ms; // Слишком частые пакеты
});
```

Однако у adjacent_filter есть одна особенность. Из-за того, что для первого элемента нет пары для сравнения, так как перед ним ничего нет, то он автоматически попадает в выходную последовательность:

```cpp
auto packet_timestamps = {0, 5, 6, 7, 10, 11, 23, 26, 27};
auto suspicious = packet_timestamps | ranges::views::adjacent_filter([](auto&& a, auto&& b) {
	return b - a < 2; // Слишком частые пакеты
});

for (auto& ts : suspicious) {
	std::print("{} ", ts);
}
// Вывод:
// 0 6 7 11 27 
```

Если вас не устраивает такое поведение, то не проблема. На помощь приходит адаптер ranges::views::tail. Его единственное предназначение - выкинуть первый элемент диапазона:

```cpp
auto packet_timestamps = {0, 5, 6, 7, 10, 11, 23, 26, 27};
auto suspicious = packet_timestamps | ranges::views::adjacent_filter([](auto&& a, auto&& b) {
	return b - a < 2; // Слишком частые пакеты
}) | ranges::views::tail;

for (auto& ts : suspicious) {
	std::print("{} ", ts);
}
// Вывод:
// 6 7 11 27 
```

Теперь в выходной последовательности находятся действительно только подозрительные пакеты.

Аналог этого адаптера в стандартной библиотеке - адаптер std::views::drop, которому передается количество пропускаемых спереди элементов.

Двигаемся к следующему примеру.

Представьте, что у вас есть программа, которая генерирует какие-то файлы. Как проверить корректность работы программы? Сравнить списки файлов и их содержимое. С первой частью может помочь справиться алгоритм std::ranges::set_difference. Он находит разницу между двумя отсортированными последовательностями и помещает отличающиеся элементы с новую коллекцию. Так как в файловой системе файлы располагаются в лексикографическом порядке, то условие отсортированности выполняются, значит можем применить set_difference:

```cpp
TEST_F(ProgramTest, FileListsComparison) {
	auto ref_file_names = get_file_names("reference/"); 
	auto test_file_names = get_file_names("result/");
	std::vector<std::string> difference;
	std::ranges::set_difference(ref_file_names, test_file_names, std::back_inserter(difference));
	ASSERT_TRUE(difference.empty());
}
```

Также для set_difference есть возможность задать проекции элементов исходных последовательностей. Допустим у вас есть не список имен файлов, а список объектов файлов, которые отсортированы по имени. Вы также можете найти различия в элементах списков вот так:

```cpp
std::vector<std::string> difference;
	std::ranges::set_difference(ref_files, test_files, std::back_inserter(difference), &File::filename, &File:filename);
```

Как видим, у диапазонов очень мощные возможности по фильтрации данных.

## Объединение последовательностей

Если данные можно разделять, то можно и объединять. И самый простой и прямолинейный способ это сделать - передать все диапазоны в std::views::zip. Этот адаптер возвращает отображение, i-ый элемент которого является tuple-подобным объектом, который хранить i-ые элементы всех аргументов-диапазонов. Количество элементов в результирующем отображении равно размеру аргумента-диапазона с минимальным количеством элементов.

Пусть вы хотите протестировать функцию вычисления итогового среднего балла ученика школы. Для тестов у вас есть исходные данные функции и ожидаемые результаты. Можно конечно итерироваться с помощью индексов, но так вы вводите лишние сущности в код. А можно сделать так:

```cpp
TEST_F(ScoreCalculationTest, Simple) {
	std::vector<Student> students = /*заполняем значениями*/;
	std::vector<double> scores = {4.45, 5.0, 3.87, 4.0};
	for (auto& [student, score] : std::views::zip(students, scores)) {
		ASSERT_TRUE(score == CalculateScore(student));
	}
}
```

Красиво, элегантно и без лишних назойливых индексов. И работает для любого разумного числа входных диапазонов.

Но иногда без индексов все еще не обойтись, но уж очень не хочется всегда приписывать `[i]` для упоминания элемента. Диапазоны и в этом помогут с помощью std::views::enumerate. Возможно некоторые из вас знакомы с аналогичной функцией из python. Ее задача - добавлять к элементам диапазона их порядковый номер и возвращать пару из индекса и элемента.

```cpp
std::set<std::string> data = {"A", "B", "C"};
for (auto [i, val] : data | std::views::enumerate) {
    std::println("Element #{}: {}", i,  val);
}
// Вывод
// Element #0: A
// Element #1: B
// Element #2: C
```

Понятный и простой инструмент, который поможет обогатить индексами даже не индексируемые диапазоны, такие как std::set и std::map.


Иногда нужно сгенерировать все возможные пары, которые можно составить из нескольких диапазонов. Например, вы хотите сгенерировать 2D координатную сетку с узловыми точками. Вы легко это сможете сделать с помощью библиотеки диапазонов и адаптера std::views::cartesian_product:

```cpp
auto x = {1, 2, 3};
auto y = {10, 20};
for (auto [x_val, y_val] : std::views::cartesian_product(x, y)) {
	std::println("({}, {})", x_val, y_val);
}
// Вывод:
// (1, 10)
// (1, 20)
// (2, 10)
// (2, 20)
// (3, 10)
// (3, 20)
```

Если раньше вам для этого понадобился бы двойной цикл:

```cpp
for (auto x_val : x) {
	for (auto y_val : y) {
		std::println("({}, {})", x_val, y_val);
	}
}
```

То сейчас все решается одинарным более экспрессивным циклом. Красота!

Все адаптеры из этой темы спокойно заменяются использованием сырых индексов или итераторов. Но зачем, если есть готовые и удобные инструменты?


## Математические операции

В этом блоке всего один адаптер - ranges::views::linear_distribute. Он принимает 3 аргумента (start, stop, count) - начальный элемент, конечный элемент и количество элементов и возвращает соответствующую этим параметрам последовательность элементов. stop входит в результирующий диапазон в отличии от второго параметра std::views::iota.

```cpp
auto points = ranges::views::linear_distribute(0.0, 1.0, 10);
for (double x : points) {
	std::println("sin({}) = {}", x, sin(x));
}
// Вывод
// sin(0) = 0
// sin(0.11111111111111116) = 0.11088262850995304
// sin(0.22222222222222232) = 0.22039774345612237
// sin(0.33333333333333337) = 0.32719469679615226
// sin(0.4444444444444444) = 0.42995636352835553
// sin(0.5555555555555556) = 0.5274153857718655
// sin(0.6666666666666667) = 0.6183698030697371
// sin(0.7777777777777778) = 0.7016978761467353
// sin(0.8888888888888888) = 0.7763719213006605
// sin(1) = 0.8414709848078965
```


## Заключение

Сегодня вы узнали:
- такие адаптеры, как chunk, chunk_by и split_when позволяют разбивать данные на сегменты.
- нужные элементы.можно гибко выделить из диапазона с помощью adjacent_filter, tail, set_difference
- вместо написания циклов с итерацией по индексами можно использовать адапатеры zip, enumerate и cartesian_product, чтобы итерироваться более экспрессивно.
- linear_distribute позволяет генерировать последовательности для математических вычислений.