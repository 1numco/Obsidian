Идиомы вариабельных шаблонов

ОРы:
- применяет сверточные выражения для реализации функций
- применяет сверточные выражения для рекурсивного обхода пакета параметров

Структура

- Рекурсивный обход пакета параметров. На примерах compile-time превращения числа в соответствующую строку и compile-time поиска максимального значения в пакете параметров. (ОР: применяет вариабельные шаблоны для рекурсивного обхода пакета параметров.)
- fold expression. Введение. fold - это по факту синтаксический сахар, сворачивающий рекурсию. На простых примерах суммы чисел.
- правый и левый унарный и бинарный фолд. Порядок раскрытия аргументов и коммутативность операций. Сумма, умножение и некоторые бинарные операции - коммутативны, там нет разницы. А вот вычитание - нет.
- Оператор запятая и fold. На примере функции, принтующей с разделителем.
- Короткосхемные && и || и fold expression. На примере compile-time подсчета статистики по std::array. Но в фолде нужно инстанцировать типы все типы из пака, и если, например, в инстанциациях нет зависимого типа, то компиляция провалится даже если самое первое условие давало бы однозначный результат вычислений.


## Введение

Вариабельные шаблоны - это один из самых мощных инструментов вычислений времени компиляции в руках С++ разработчика. Конечно, со временем сложились идиомы и паттерны использования variadic templates, о которых сегодня пойдет речь. Вы узнаете:

- Как рекурсивно обходить пакет шаблонных параметров?
- Что такое fold expression и как оно помогает реализовывать вариабельные шаблоны функций?
- Как оператор запятая помогает там, где не может помочь раскрытие пакета параметров?

Контент

## Рекурсивный обход пакета шаблонных параметров

В прошлом уроке мы узнали, как можно рекурсивно обходить пакета параметров функции, если не помогает раскрытие пакета параметров. Но функциями дело не ограничивается. Рекурсия - это также один из основных инструментов работы с вариабельными шаблонами классов. На каждом шаге рекурсии происходит compile-time обработка крайнего шаблонного параметра и запуск обработки для оставшегося набора параметров. С помощью вариабельных шаблонов классов и рекурсивного обхода пакета шаблонных параметров можно переносить вычисления на время компиляции.

Попробуем с помощью рекурсии вычислить максимальное значение из переданных в шаблон:

```cpp
// Общий случай: один и более элементов
template<auto First, auto... Rest>
struct MaxValue {
private:
	static const auto rest_max = MaxValue<Rest...>::value; // Рекурсивно ищем максимум в хвосте
public:
	// само значение максимума
	static const auto value = (First > rest_max) ? First : rest_max;
};

// Базовый случай: один элемент
template<auto Val>
struct MaxValue<Val> {
	static const auto value = Val;
};

// Вспомогательная переменная для удобного доступа
template<auto... Values>
inline const auto max_value = MaxValue<Values...>::value;

std::println(max_value<1, 5, 3, 9, 2>); // 9
std::println(max_value<-5, -1, -10>); // -1
std::println(max_value<'a', 'z', 'x'); // 'z'
```

Основная реализация `MaxValue` запускает рекурсию для вычисления максимума оставшихся параметров из пакета `Rest` и записывает максимум в статическое поле `value`. Таким образом на каждом шаге рекурсии инстанцируется новый шаблон `MaxValue` для другого набора значений со своими статическими полями `rest_max` и `value`. В конце концов рекурсия останавливается на базовом сценарии, когда параметр всего один. Он и записывается в поле `value` инстанциации для последнего параметра. Далее по цепочке вверх мы выходим из рекурсии и собираем информацию о максимальном значении среди всех параметров.

Для того, чтобы явно не получать каждый раз доступ к статическому полю `value`, можно определить вариабельный шаблон переменной max_value.

Рекурсивный обход пакета параметров позволяет реализовать сложную compile-time обработку элементов пакета параметров.

## Fold expression

Мы не зря делаем такой большой акцент на рекурсии, потому что при введении вариабельных шаблонов, это был один из основных инструментов нетривиальной обработки шаблонных параметров. Но нам всегда нужно писать "дополнительный код" в виде базы рекурсии. Даже для простой функции суммирования:

```cpp
template<typename T, typename... Rest> 
auto Sum(T arg, Rest... rest) {
	return arg + Sum(rest...);
}

template<typename T>
auto Sum<T1>(T arg) {
	return arg;
}
```

Программисты коллективно поняли, что это не очень удобно, и в С++17 у нас появились fold expressions или сверточные выражения. Это синтаксический сахар, который сворачивает рекурсию в одно выражение. С помощью сверточного выражения очень легко написать функцию, суммирующую неограниченное количество чисел:

```cpp
template<typename ...Args> 
auto SumCpp17(Args ...args) {
	// используем сверточное выражение
	return (args + ...);
}
```

Это лишь демонстрация прелестей fold expressions. Фича имеет много нюансов, поэтому давайте подробнее про нее поговорим.

## Разновидности fold expression

В сущности, fold expression - сворачивание рекурсии по всему пакету шаблонных параметров функции с помощью комбинации синтаксиса variadic templates и бинарных операторов. Есть всего 4 формата fold expression:

1️ ( pack op ...) - унарная правая свертка
2️ ( ...  op pack) - унарная левая свертка
3️ (pack op ... op init ) - бинарная правая свертка
4️ (init op ... op pack) - бинарная левая свертка

где pack - выражение, содержащее нераспакованный пакет шаблонных параметров. op - бинарный оператор. В последних двух случаях он должен быть одинаковым справа и слева от точек. В число бинарных операторов входит почти все, что вы могли бы себе представить: +   -      /   %   ^   &   |   =   <   >   <<   >>   +=    -=   =   /= %=   ^=   &=   |=   <<=   >>=   ==   !=   <=   >=   &&   ||   ,   .   ->. init - выражение, которое никак не относится к шаблонным параметрам, является базой вычислений и начальным значением для аггрегации.

Разберемся, во что по итогу раскрывается каждый вариант сверточного выражения:

1 Унарная правая свертка (E op ...) раскрывается в  (E1 op (... op (En-1 op En)))
2 Унарная левая свертка (... op E) раскрывается в  (((E1 op E2) op ...) op En)
3 Бинарная правая свертка (E op ... op init) раскрывается в  (E1 op (... op (En−1 op (EN op init))))
4 Бинарная левая свертка (init op ... op E) раскрывается в  ((((init op E1) op E2) op ...) op En).

Где E - это Expression, выражение, содержащее пакет шаблонных параметров.

Выбор правого или левого фолда происходит на основании конкретной задачи, необходимости расположения скобок и ассоциативности операции

Операция сложения - это ассоциативная операция. Поэтому результат операции не зависит от положения скобок: `(a + (b + c)) == ((a + b) + c)`. Поэтому для сложения подходит и правый, и левый фолд.

Операция вычислания - это не ассоциативная операция. Результат вычитания  зависит от положения скобок: `(a - (b - c)) == ((a - b) - c) так как  (8 - (2 - 2)) == 8, а ((8 - 2) - 2) == 4`. 

Также бинарная свертка дает нам возможности для сворачивания пустого списка параметров, так как мы имеем начальное значение. Без начального значения сумма нулевого количества аргументов не имеет смысла, поэтому для подавляющего большинства операторов унарная свертка с пустым пакетом параметров запрещена и приводит к ошибке компиляции.

Давайте приведем по примеру для каждого вида свертки, чтобы была понятна разница:

1 Унарная правая свертка:

```cpp
template<typename... Args>
auto right_subtract(Args... args) {
    return (args - ...);
}
double result = right_subtract(1.0, 0.5, 0.1); // 1-(0.5-0.1) = 0.6
right_subtract(); // ошибка компиляции
```

2 Унарная левая свертка:

```cpp
template<typename... Args>
auto sum(Args... args) {
    return (... + args);
}
double result = sum(1.0, 0.5, 0.1); // ((1+0.5)+0.1) = 1.6
sum(); // ошибка компиляции
```

3 Бинарная правая свертка:

```cpp
template<typename... Args>
double average(Args... args) {
    return (args + ... + 0.0) / sizeof...(args);
}
double avg = average(1, 2.5, 3, 4.2); // (0.0 + (1 + (2.5 + (3 + 4.2))))/4 = 2.675
double zero_args = average(); // 0
```

4 Бинарная левая свертка:
```cpp
template<typename... Args>
void println(Args... args) {
	(std::cout << ... << args) << std::endl;
}
println(1, 2, 3); // выведется "123".
println(); // выведется символ конца строки
```

## Оператор запятая и fold expression

Да, сверточные выражения - это круто и они помогают сократить объем кода. Однако нам не всегда нужны какие-то математические преобразования. Часто нужно просто подряд выполнить некоторые действия с шаблонными параметрами и никак не аггрегировать результат. В этом может помочь оператор запятая. С ним мы можем в операндах оператора выполнять любые выражения, даже применять функции над параметрами.

Например, мы можем выводить на консоль аргументы функции, разделенные пробелом. Не хочется постоянно добавлять в консольный вывод пробелы. Хочется просто передать переменные, содержимое которых мы хотим увидеть на консоли, в функцию, которая сама позаботится о разделении переменных пробелами:

```cpp
void print_one_with_space(const auto& v) {
	std::cout << v << ' ';
}

template<typename ...Args>
void print_with_space(Args&&... args) {
	(print_one_with_space(args), ... , (std::cout << std::endl));
}

print_with_space(3.14, 42, "myau"); // выведет "3.14 42 myau "
```

Здесь мы используем бинарную правую свертку, которая раскрывается в это: `(print_one_with_space(3.14), (print_one_with_space(42), (print_one_with_space(42), (std::cout << std::endl))))`.  С `operator,` различий между правыми и левыми свертками нет, так как `operator,` всегда выполняет операции слева направо.

Сверточные выражения с использованием оператора запятая - отличный способ гибко обрабатывать пакет параметров с помощью выражений, возвращающих void, не прибегая к рекурсии.

## Короткосхемные вычисления и fold expression

Бинарные операторы && и || обладают свойствами короткосхемности. Это значит, что нет необходимости вычислять все операнды в выражении, если результат уже предопределен. Например, operator&& при наличии хотя бы одного операнда, возвращающего false, все равно вернет false, какими бы не были другие операнды. Тогда при появлении такого операнда становится бессмысленным вычисления дальнейшего выражения и оператор немедленно возвращает результат.

Это свойство операторов && и || также проявляется при использовании fold expression:

```cpp
bool print_arg(bool arg) {
	std::println("{}", arg);
	return arg;
}

template <typename... Args>
auto check_short_circuit(Args... args) {
	// выводим аргументы на консоль до тех пор, пока не встретим true
	return (print_arg(args) || ...);
}

check_short_circuit(false, true, false, true);
// На консоль выведется:
// false
// true
```

operator|| вернет true, как только встретит среди своих операндов true, и не будет вычислять все следующие выражения. Из-за этого на консоли появятся вывод только 2-х аргументов функции, вместо 4-х.

Таким образом мы избежим выполнения лишних вычислений, если результат всего выражения уже известен.

## Заключение

Сегодня вы узнали:
- Рекурсия - это универсальный инструмент для сложной обработки пакетов шаблонных параметров
- Сверточные выражения позволяют избавиться от рекурсивных синтаксических конструкций и упростить понимание кода.
- Оператор запятая позволяет выполнять подряд выполнить операции над аргументами из пакета параметров функции. Причем результат этих операций не обязан аггрегироваться в одно значение.
- Операторы && и || при использовании внутри fold expression также обладают короткосхемными свойствами. Это позволяет избежать лишних вычислений.



