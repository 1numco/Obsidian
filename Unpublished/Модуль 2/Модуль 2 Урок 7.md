Вариабельные шаблоны

ОРы:
- применяет сверточные выражения для реализации шаблонных функций
- применяет сверточные выражения для реализации рекурсивного обхода пакета параметров

Структура:
- Нужны функции, принимающие неопределенное число аргументов. Определять много перегрузок ведет к повторению кода, а сишный подход (как реализован printf) - нетипобезопасный. В С++ есть типобезопасная альтернатива - вариадики. Дальше потихоньку на разных примерах показываем особенности определения вариадиков. (ОР: понимает языковую конструкцию пака параметров)
- template parameter pack.(ОР: понимает языковую конструкцию пака параметров)
- function parameter pack.(ОР: понимает языковую конструкцию пака параметров)
- function parameter pack expansion. Здесь несколько видов распаковки показать на разных примерах.(ОР: понимает языковую конструкцию пака параметров)
- sizeof... (ОР: применяет вариабельные шаблоны для реализации функции.)
- частичная специализация вариадиков. Ключевой момент в использовании вариадиков. Пример с рекурсивным вызовом print и отщиплением одного параметра каждый раз. (ОР: применяет вариабельные шаблоны для реализации функции)
- идеальная передача аргументов функции. На примере invoke. (ОР: применяет вариабельные шаблоны для реализации функции)
- вариадик наследование от пака параметров. Показываем, что так можно делать.Но раскрываем через вариадик CRTP по Пикусу. (ОР: понимает как использовать variadic crtp, чтобы наследоваться от множества политик)


Введение

Мы научились использовать шаблоны с фиксированным количеством шаблонных параметров. Однако бывают ситуации, когда необходимо использовать шаблон с неопределенным количеством шаблонных параметров. Для этого в С++ есть особенный синтаксис - variadic templates(Всплывашка: вариабельные шаблоны, то есть шаблоны с переменным числом аргументов). Сегодня вы узнаете:

- как реализовывать шаблоны с переменным числом аргументов.
- для чего используется частичная специализация вариабельных шаблонов.
- как использовать perfect forwarding в variadic templates.
- для чего может быть полезно наследование от неопределенного количества шаблонных параметров.

Контент

Бывают ситуации, когда нам нужна функция, которая принимает переменное число аргументов. Пусть мы хотим вычислить сумму всех аргументов, переданных в функцию. Мы можем определить несколько перегрузок такой функции, чтобы каждая из них работала с определенным набором аргументов:

```cpp
int add(int a) {
	return a;
}
int add(int a, int b) {
	return a + b;
}
int add(int a, int b, int c) {
	return a + b + c;
}
```

Но это плохо расширяемый подход. Если потребуется складывать больше чисел, то придется добавлять нужную перегрузку. Хочется одну функцию на все случаи жизни

Существует C-style подход в для достижения этой цели. Это вариабельные функции. Вот пример определения вариабельной функции add:

```cpp
#include <stdarg.h>
int add(int argcount, ...) {
	int counter, total = 0;
	
	// Определяем переменную типа va_list.
	va_list argptr;
	// Инициализируем эту переменную
	va_start (argptr, argcount);
	
	for (counter = 0; counter < argcount; counter++) {
		// суммируем параметры из пакета аргументов
		total += va_arg (argptr, int);
	}
	// завершаем использование переменной
	va_end (argptr);
	
	return total;
}

add(3, 12, 34, 190); // функция возвращает 236
```

Первым аргументом функции передается количество следом идущих параметров, для которых необходимо посчитать сумму. Далее специальная конструкция `...`, которая обозначает переменное количество параметров. Внутри функции с помощью специального синтаксиса мы инициализируем переменную, которая будет шагать по переменному числу параметров и в цикле суммируем все эти параметры.

Этот подход работает. Например, известная функция printf реализована как вариабельная функция. Однако такой подход не является типобезопасным. Мы можем передать в функцию значения любого типа, в том числе отличающегося от int. Функция все равно будет честно пробовать сложить все эти аргументы. Это приводит к неопределенному поведению:

```cpp
struct SomeStruct {};
// следующая строчка компилируется
add(4, 12, 34, 190, SomeStruct{}); // одно из возможных возвращаемых значений: 1671545148.
```

Но мы же плюсовики и любим типобезопасность, как котики любят коробки. Поэтому нужно типобезопасное решение, в котором программист не сможет совершить подобную ошибку.

Встречайте, variadic templates.

## Variadic Templates

## Template Parameter Pack

Ключевым игроком в этой истории является template parameter pack(Всплывашка: пакет шаблонных параметров). Шаблон с хотя бы одним пакетом параметров называется вариабельным. Он определяется следующим образом:

```cpp
template<typename... Types> struct Tuple {};

Tuple<> t0;           // Types не содержит аргументов
Tuple<int> t1;        // Types содержит один аргумент: int
Tuple<int, float> t2; // Types содержит 2 аргумента: int and float
```

Где:

- `Types` - это имя template parameter pack.
- `...` указывает, что параметр вариабельный.

Важно:

1 Пакет параметров может содержать от 0 до любого количества аргументов.
2 Пакет параметров может использоваться в шаблонах классов, функций и псевдонимов.

Варибельные шаблоны можно параметризовать не только неограниченным числом типов, но и неограниченным набором значений определенного типа, используя NTTP:

```cpp
template<size_t... Numbers> struct NumbersSet {};
```

Так вы получаете возможность работать с переменным числом значений одного и того же типа(в данном случае size_t).

Однако пакет не может одновременно содержать параметры разных видов, так как мы указываем вид всего один раз. Пакет параметров содержит либо конкретный NTTP, либо типовые параметры, либо шаблон-шаблонные параметры.
## Function Parameter Pack

Если же вы хотите определить variadic template функцию, то вам необходима вторая синтаксическая конструкция - function parameter pack(Всплывашка: пакет параметров функции):

```cpp
template<typename... Types>
// в скобках испольуем function parameter pack
void foo(Types... args);
 
foo();       // OK: args contains no arguments
foo(1);      // OK: args contains one argument: int
foo(2, 1.0); // OK: args contains two arguments: int and double
```

`Types... args` в этой конструкции Types обязательно должен быть именем пакета шаблонных параметров из объявления шаблона, а args - имя пакета параметров функции.

В вариабельных шаблонах функций также работает вывод типов и, если компилятор может вывести тип, то можно его не указывать при использовании шаблона.

## Parameter Pack Expansion

Хорошо, мы научились упаковывать неограниченное число типов в одну синтаксическую конструкцию. Следующий шаг - нам нужно распаковать обратно этот пакет параметров в это первоначальное множество параметров. Для этого существует parameter pack expansion:

```cpp
pattern...
```

Паттерн, в котором содержится имя по крайней мере одного пакета параметров, следом за которым идет троеточие, раскрывается в ноль или больше инстанциаций паттерна, в которых имя пакета параметров заменяется на все элементы из пакета параметров в том же порядке, в котором они были при создании пакета. Все инстанциации разделяются запятой, кроме использования alignment спецификатора(alignas).

На самом деле существует огромное множество вариантов, как можно использовать раскрытие пакета параметров. Это зависит от конкретной задачи. Сейчас нам важно понять самую суть, поэтому вот несколько базовых примеров.

1 Мы можем распаковывать пакет параметров функции в набор аргументов для вызова нижележащей функции:

```cpp
template<typename Func, typename... Args>
void call_func(Func f, Args... args) {
	f(args...); // Раскрытие пакета параметра функции как аргументов функции
}

void example1(int, double) {}
void example2(int, double, bool) {}

call_func(example1, 42, 3.14); // работает
call_func(example2, 42, 3.14, true); // также работает
call_func(example1, 42, 3.14, true); // не компилируется, набор параметров функции `example1` и `call_func` не совпадает
```

Здесь мы определили функцию, которая может вызывать другие функции, работающие с тем же самым набором типов, которые мы передали в `call_func`. Раскрытие пакета происходит здесь `f(args...)`. `args` в этом случае является тем самым pattern'ом. Раскрытый пакет внутри компилятора превращается в нечто подобное: `f(args1, arg2, arg3 /*и так далее перечисляем все параметры*/)`.

2 Также можно раскрывать пакет параметров шаблона для передачи его в другой шаблон:

```cpp
template<typename... Args>
auto make_tuple(Args... args) {
    return std::tuple<Args...>(args...); // Args... внутри треугольных скобок раскрывает пакет параметров шаблона в параметры класса std::tuple, args... раскрывает пакета параметра функции как аргументов конструктора std:tuple
}

auto t = make_tuple(42, "text", 3.14);
```

Здесь мы используем раскрытие двух пакетов параметров: функции и шаблона. Пакет параметров шаблона раскрывается для передачи полного списка параметров в качестве шаблонных параметров другого шаблона. Пакет параметров функции раскрывается для передачи полного списка параметров в конструктор std::tuple. Кусок кода `std::tuple<Args...>(args...);` внутри компилятора преобразуется в нечто подобное: `std::tuple<Arg1, Arg2, Arg3/*и тд*/>(arg1, arg2, arg3 /*и тд.*/);`
## Размер пакета параметров

Иногда полезно знать, сколько параметров содержится в пакете параметров. Для этого существует специальный синтаксис оператора sizeof:

```cpp
template<typename... Types>
struct count
{
    static const std::size_t value = sizeof...(Types);
};
```

`sizeof...(Types)` - так мы получаем размер пакета параметров. Это форма оператора `sizeof` также считается раскрытием пакета параметров.

Однако даже раскрытие пакета параметров не в любой ситуации может помочь обрабатывать пакеты, как того требует задача. В этих случаях поможет рекурсивный обход пакета параметров.

## Рекурсивный обход пакета параметров

Это ключевой момент при использовании вариабельных шаблонов.

Главная идея: реализовать шаблон, в котором будем рекурсивно проходиться по пакету параметров и на каждом шаге обрабатывать только один параметр. Таким образом мы последовательно обработаем весь пакет.

Посмотрим на пример:

```cpp
template<typename First, typename... Rest>
void process(First first, Rest... rest) {
	process_argument(first);
	// рекурсия
	process(rest...);
}

template<>
void process<>() {}
```

Шаблонная функция process принимает один типовой шаблонный параметр и один пакет параметров. В этой функции мы обрабатываем один элемент и запускаем рекурсию для всех других параметров из пакета. При повторных вызовах функции от пакета будет снова и снова "отщипываться" один параметр, пока в пакете не останется параметров. У каждой рекурсии есть база рекурсии.

## Специализация вариабельных шаблонов

В примере выше базой рекурсии выступает полная специализация шаблонной функции process для нулевого количества аргументов. Она предназначена для изначального вызова функции с пустым списком параметров и для обеспечения окончания рекурсии, когда от пакета параметров уже нельзя ничего "отщипнуть".

Вариабельные шаблоны также можно специализировать и на варианты специализаций накладываются такие же ограничения. Вариабельные шаблоны функций можно только полностью специализировать. Вариабельные шаблоны классов и переменных можно и частично, и полностью специализировать. 

## Идеальная передача пакета параметров функции

В вариабельных шаблонах функций очень важно сохранять категорию выражения и точный тип переданных в функцию параметров. Мы уже встречались с подобной задачей для одного аргумента. Тогда нужно было использовать функцию std::forward.  Но благодаря parameter pack expansion мы можем использовать ее и для идеальной передачи категории выражения всех элементов пакета параметров функции во внутренние вызовы.

Посмотрим, как это правильно делать на примере упрощенной версии std::make_unique. Она создает объект желаемого класса и оборачивает его в уникальный указатель. Так как сама std::make_unique не знает, с какими типами аргументов она будет работать, ей очень важно использовать perfect forwarding:

```cpp
template<class T, class... Args>
make_unique(Args&&... args)
{
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}
```

Обратите внимание, что универсальные ссылки также работают для пакета параметров функции. Они в сочетании с идеальной передачей раскрытого пакета параметров в конструктор объекта и дают эффект сохранения категории выражения и точного типа каждого отдельного параметра.

`std::forward<Args>(args)...` - этот фрагмент кода и есть раскрытие пакета параметров. Внутри компилятора он превращается в нечто такое: `std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), std::forward<Arg3>(arg3) и тд.` 

## Наследование от пака параметров

Удивительно, но факт: от пакета параметров даже можно наследоваться!

```cpp
template<typename... Bases>
class Derived : public Bases... { // Раскрытие в списке базовых классов
public:
	// const Bases&... - раскрытие пакета в список типов аргументов конструктора
	// Bases(bases)... - раскрытие пакета в список инициализации базовых классов
    Derived(const Bases&... bases) : Bases(bases)... {}
};

struct A {}; struct B {};
Derived<A, B> d(A{}, B{});
```

При  инстанциации шаблона с конкретными типами A и B,  `class Derived : public Bases...`  в этой строчке пакет параметров раскрывается так: ``class Derived : public A, B`.

На первый взгляд, не очень понятно, зачем может понадобиться такая возможность в практических задачах. Однако они есть. Большинство из них мы будем разбирать по ходу курса, а сейчас рассмотрим один пример,  котором используются уже изученные нами концепции.

Вспомним про идиому CRTP:

```cpp
template <typename D> struct Base {/*реализация*/};
class Derived : public Base<Derived> {/*реализация*/};
```

Здесь мы наследуемся от базового класса, параметризованного наследников.

Суть CRTP - расширять класс дополнительным функционалом. Однако не всегда нам будет достаточно одного базового класса. В наследнике могут понадобиться различные расширения, которые, согласно принципу проектирования Single Responsibility(Всплывашка: Принцип единственной ответственности, согласно которому сущность должна быть ответственна лишь за какое-то одно действие), нужно разделить на разные классы.

```cpp
template <typename D> struct Factory {
	// создание объекта с помощью вариабельного шаблона функции и идельной передачи параметров в конструктор.
    template <typename... Args>
    static D* create(Args&&... args) {
		return new D(std::forward<Args>(args)...);
    }
    // разрушение объекта 
    static void destroy(D* d) { delete d; }
};
template <typename D> struct Stringify {
	// оператор приведения к строковому типу
    operator std::string() const {
		std::stringstream S;
		S << *static_cast<const D*>(this);
		return S.str();
	}
};
// CRTP наслдеование от двух классов
class Derived : public Stringify<Derived>, public Factory<Derived> {/*реализация*/};
```

Класс Factory предоставляет статический интерфейс для создания и уничтожения объектов, а Stringify - для преобразования объекта в строку. А класс Derived наследует эти интерфейсы.

Но что если мы захотим второй класс, очень похожий на Derived, который будет наследовать другой набор интерфейсов? 

```cpp
// создает объекты в thread-local памяти
template <typename D> struct TLFactory {};

class Derived : public TLFactory<Derived> {/*реализация*/};
```

Такими темпами мы рискуем наткнуться на проблему провторения кода, если нам придется реализовывать практически идентичные классы, но с разными наследуемыми интерфейсами.

На помощь приходят вариабельные шаблоны. Просто определяем пакет параметров, который может содержать любые типы, от которых мы хотим наследоваться:

```cpp
template <typename... Policies>
class Derived : public Policies... {};
```

Есть всего одна проблема... Это не будет работать. Дело в том, что CRTP базовые классы - шаблонные классы и мы обязаны для них указать шаблонные параметры. Чего мы не сделали в самом последнем примере.

Если нам нужны шаблонные параметры в качестве шаблонных классов, то у нас в арсенале есть подходящий инструмент для этого. Это шаблон-шаблонные параметры. Для простого CRTP с одним параметром использование template-template параметра выглядит так:

```cpp
template <typename D> struct Base {};

template <template <typename> class Base>
class Derived : public Base<Derived<Base>> {};
```

Тут один тонкий момент.  Базовый класс - это шаблон, который нужно параметризовать наследником. Однако, наследник - тоже шаблон, который должен быть параметризован шаблон-шаблонным параметром базового класса. Такая комбинация параметризаций порождает наследование от `Base<Derived<Base>>`.

Теперь расширим этот пример для неопределенного количества параметров:

```cpp
// объявление пакета шаблон-шаблонных параметров
template <typename T, template <typename> class... Policies>
// наследование от пакета шаблон-шаблонных параметров
class Derived : public Policies<Derived<Policies...>>... {
    T t_;
public:
    explicit Derived(T t) : t_(t) {}
    const T& get() const { return t_; }
    // необходимо, если наследуемся от Stringify, чтобы сериализовать объект в поток и далее преобразовать данные из потока в строку
    friend std::ostream& operator<<(std::ostream& out, const Derived& d) {
		out << d.t_;
		return out; 
	}
};
```

Обратите внимание на раскрытие пакета параметров шаблона при наследовании. Мы 2 раза упоминаем пакет параметров и дважды его раскрываем, чтобы корректно скомбинаровать и правильно определить все шаблонные базы класса Derived.

Теперь у нас появилась простая обертка над любым шаблонным типом T, которая может быть расширена неограниченным количеством CRTP интерфейсов.

## Заключение

Повторим, что мы сегодня узнали:

- вариабельные шаблоны - типобезопасный и расширяемый способ обработать неограниченное число аргументов функций и шаблонных параметров классов.
- С помощью template parameter pack и function parameter pack мы запаковываем всё множество параметров в одну сущность, а с помощью parameter pack expansion мы раскрываем пакет обратно в, возможно, преобразованную последовательность параметров.
- Вариабельные шаблоны также можно специализировать. В основном это нужно для задания базы рекурсии.
- Perfect forwarding важен для вариабельных шаблонов функций, так как позволяет единообразно передавать тип и категорию выражения переданных аргументов.
- Вариабельное наследование в сочетании с шаблон-шаблонными параметрами позволяет использовать наследоваться от неограниченного количества CRTP базовых классов, чтобы гибко расширять функциональность шаблона.