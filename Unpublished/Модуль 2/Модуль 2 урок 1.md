### Урок: Шаблоны функций в C++ — или как перестать копипастить и начать жить

---

1 я всю нужную информацию даю в первом предложении. ключевое слово typename не имеет никакой другой семантики кроме обозначения того, что дальше идет тип.
2 Шаблонную функцию можно объявить и с нетиповым шаблонным параметром(например числом). Об этом будет говориться в подмодуле про метапрограммирование. Я это упоминаю, чтобы подчеркнуть, что typename нужно использовать, когда Т - это тип.
3 
4 Это правило языка такое, на то нет особой причины
#### Введение

Шаблоны функций - это волшебная палочка в арсенале С++ программиста. Они позволяют писать один код, который работает с любыми типами данных. Тем самым избавляют нас от написания кучи разных функций, делающих похожую работу, и помогают реализовывать один из принципов разработки программного обеспечения - DRY(don't repeat yourself). Но, как и с любой магией, здесь есть свои нюансы и  подводные камни. В этом уроке вы еще раз вспомните, почему писать повторяющий код плохо и после этого узнаете:

- Корректный синтаксис объявления шаблонов функций.
- Что такое полная специализация шаблонов функций.
- Порядок разрешения перегрузок шаблоннов функций.

---

#### Проблемы дублирования кода на примере `sum`

Давайте начнем с простой задачи: написать функцию `max`, которая возвращает максимум из двух чисел. Казалось бы, что может быть проще? Но если мы хотим поддерживать разные типы данных (например, `int`, `double`, `float`), то нам придется написать несколько версий этой функции:

```cpp
int max(int a, int b) { return (a < b) ? a : b; }
float max(float a, float b) { return (a < b) ? a : b; }
double max(double a, double b) { return (a < b) ? a : b; }
...
```

Для всех базовых типов-то не так просто поддержать эту функцию. А если мы захотим еще и для кастомных пользовательских типов? Это может превратить файл с этими функциями в большую простыню одинаковых по наполнению функций.
И так для каждого типа. А если у нас есть 10 типов? А если 20? А если мы хотим добавить поддержку сложения для пользовательских типов? Всё, ваш файл превращается в бесконечный список функций, которые делают одно и то же, но для разных типов. Это как если бы у вас на работе висели инструкции по приготовлению кофе, которые бы отличались только формой кружки. 

Конечно, так делать не нужно и проблему нужно решать. И С++ предлагает несколько решений этой проблемы.


---
https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es31-dont-use-macros-for-constants-or-functions
#### C-style решение — макросы

Один из способов избежать дублирования кода — использовать макросы. Макросы — инструкции препроцессора, которые позволяют заменять одни строки на другие

```cpp
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```

Теперь вы можете использовать этот макрос для любых типов данных:

```cpp
int result1 = MAX(1, 2);          // Работает
double result2 = MAX(1.5, 2.5);   // Тоже работает
```

Но макросы — это как игра в русскую рулетку. Они работают на уровне текстовой подстановки, и если что-то пойдет не так, компилятор вам не поможет. Давайте посмотрим на такой пример:

```cpp
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int main() {
	int x = 5;
	int y = 10;
	
	int result = MAX(x++, y++);
	
	std::println("Result: {}", result);
	std::println("x: {}", x);
	std::println("y: {}", y);
}
```

Какие значения будут у переменных result, x и y после исполнения макроса MAX?

Ожидаемые значения: 11, 6, 11. Однако у препроцесора и компилятора есть свое мнение на этот счет. Реальный вывод:

```
Result: 11
x: 6
y: 12
```

Переменная y имеет значение на один больше ожидаемого. Это перестает быть удивительным после того, как мы посмотрим на то, во что раскрывается макрос:

```cpp
int result = x++ > y++ ? x++ : y++;
```

Мы просто подставили текст и в любых значениях x и y, одна из этих переменных претерпит лишний инкремент.

Более сложные ситуации генерируют все менее и менее тривиальные ошибки. 

#### Недостатки макросов

1. **Нетипобезопасность**: Макросы не проверяют типы данных. Программа может скомпилироваться, но упасть в runtime.
    
2. **Побочные эффекты**: Макросы могут привести к неожиданным результатам, особенно если аргументы содержат побочные эффекты (например, инкременты).
    
3. **Сложность отладки**: Макросы могут раскрываться в причудливые строки, которые вы просто не увидите в своем коде. Придется отлаживаться по файлу с кодом после препроцессора, а это нетривиальная задача.

Макросы — это как использовать переводчик текста по изображению. В идеальных случаях работает хорошо, но иногда может "кабачок" интерпретировать как "дешевый ресторан".

Поэтому [CppCoreGuideLines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es31-dont-use-macros-for-constants-or-functions) говорят нам не использовать макросы при определении функций

#### C++ решение — шаблоны

Шаблоны — это как макросы, но с типами и без подводных камней. Они позволяют создавать обобщенные функции, которые могут работать с разными типами данных, сохраняя при этом типобезопасность.

Посмотрим, как можно было бы реализовать нашу функцию max с помощью шаблонов:

```cpp
template <typename T>
T max(T a, T b) {
    return a > b ? a : b;
}
```

Здесь `typename T` указывает, что шаблонный параметр `T` — это имя типа, который может быть заменен на любой реальный тип данных. Шаблонные параметры могут быть не только типами, но и, например, числами. Подробно сейчас об этом мы говорить не будем, но typename показывает, что T обозначает именно шаблонный тип данных. В контексте указания вида шаблонного параметра typename взаимозаменяем с ключевым словом `class`:

```cpp
template <class T>
T max(T a, T b);
```

Однако `typename` имеет более понятную семантику "имени типа" и не все типы в С++ являются классами. Поэтому современные стандарты С++ рекомендуют использовать именно typename. 

Теперь вы можете использовать эту функцию для любых типов, для которых определен operator<:

```cpp
int result1 = max<int>(1, 2);           // T = int
double result2 = max<double>(1.5, 2.5);    // T = double
```

При использовании шаблонной функции в треугольных скобках вы указываете тип, с которым функция будет работать.

Вы можете заметить, что по типу аргументов и так можно понять, с какими типами работает функция. Почему бы компилятору самому не определять тип шаблонного параметра на основе переданных параметров?

И он может так делать! Это называется автоматический вывод типов. Более подробно мы познакомимся с ним на следующих уроках. Сейчас же вам нужно знать, что в большинстве случаев вам не нужно явно указывать тип шаблонного параметра при вызове функции. Компилятор может сделать это за нас:

```cpp
auto result1 = max(1, 2);           // T = int
auto result2 = max(1.5, 2.5);    // T = double
```

Обратите внимание, что типы вообще перестали фигурировать в коде. Именно для этого нужны шаблоны. Чтобы максимально обобщить код и сфокусироваться именно на логике приложения. Теперь вызов нашей шаблонной функции ничем не отличается отличается от вызова обычной функции.

И никакого дублирования кода! 

---

#### Шаблоны с несколькими шаблонными параметрами

Что если мы хотим сравнивать числа разных типов? Например, `int` и `double`. Давайте чуть модифицируем код: определим функцию, которая выводит на экран большее из двух значений и попробуем ей передать числа разных типов.

```cpp
template <typename T>
void print_max(T a, T b) {
	a > b ? std::println("{}", a) 
		  : std::println("{}", b);
}

print_max(42, 3.14); 
```

Будет ошибка компиляции. В шаблоне функции указано, что параметры должны быть **в точности** одного типа. Однако мы передаем числа типа int и типа double. Компилятор не может самостоятельно выбрать, с каким одним типом ему работать. 

Один из способов решения проблема - дать компилятору подсказку, в каком типу приводить аргументы:

```cpp
print_max<int>(1, 1.5); // OUTPUT: 1
print_max<double>(1, 1.5); // OUTPUT: 1.5
```

Но тут 2 проблемы. Первая - человеческий фактор: мы можем указать неправильный тип и результат окажется неожиданным(в первом примере с print_max\<int>). Вторая - мы концентируемся на деталях, делаем лишнюю работу - указываем тип и лишаем компилятор своей работы по выводу типов. Компилятор же очевидно умеет корректно сравнивать типы int и double. 

Давайте эксплуатировать его умения. Раз у нас проблемы из-за того, что у нас всего один шаблонный параметр, мы можем сделать так, чтобы функция принимала несколько шаблонных параметров:

```cpp
template <typename T1, typename T2>
void print_max(T1 a, T2 b) {
	a > b ? std::println("{}", a) 
		  : std::println("{}", b);
}

print_max(1, 1.5); // OUTPUT: 1.5
```

Теперь функция работает корректно и мы используем умения компилятора по сравниванию целых и вещественных чисел и по выводу типов.

Вообще, двумя параметрами дело не ограничивается. Вы может объявлять функции со сколь угодно большим(не повторять в домашних условиях) объемом шаблонных параметров. Главное, чтобы это отвечало условиям вашей конкретной рабочей задаче.

#### Шаблоны функций-членов класса

Шаблоны можно использовать не только для функций, но и функций-членов(методов) классов. У шаблонов функций-членов тот же синтаксис, поведение и требования, что и изученных нами шаблонов функций. Это понятно: методы класса - это такие же функции. Просто они принимают один неявный аргумент this.

Давайте посмотрим, как работают шаблоны функций членов на примере шаблонного конструктора, который принимает шаблонное key-value хранилище, из которого инициализируется структура. Ключ и значение в такой структуре должны быть строками:

```cpp
class SomeStruct {
public:
	template<typename KeyValueStorage>
	SomeStruct(const KeyValueStorage& storage);
private:
	int field1;
	double field2;
	std::string field3;
};

template<typename KeyValueStorage>
SomeStruct::SomeStruct(const KeyValueStorage& storage) {
	field1 = std::stoi(storage.at("field1"));
	field1 = std::stod(storage.at("field2"));
	field3 = storage.at("field3");
}
```

Такой конструктор может принимать хоть std::unordered_map<std::string, std::string>, хоть std::map<std::string, std::string>, хоть json.

Заметьте, что при определении шаблонного метода вне класса вам также нужно указывать `template<...>` и имя класса, чей метод вы будете сейчас определять.



Шаблоны- это конечно хорошо. Сердце радуется, как ловко они позволяют единообразно обрабатывать типы. Но все ли так радужно и солнечно? Уверены ли мы, что один и тот же шаблон будет подходить для всех-всех типов? 

Действительно, иногда нужно как-то подкручивать поведение функции для определенных типов. Для этого есть несколько разных способов.

#### Полная специализация шаблонов функции

Сразу к примеру. В целях дебага иногда хочется красиво выводить тип переменной. Давайте напишем шаблон функции, который это делает. 
Но как? В стандартной библиотеке есть способ достать название типа: применить к объекту оператор typeid и вызывать метод name у результата:

```cpp

template<typename T>
std::string getTypeName(const T& obj){
    return typeid(obj).name();
}
```

Однако не всегда связка typeid+name() работает хорошо:

```cpp
std::vector<int> vec;
std::println(getTypeName(vec));
// На консоль выведется следующее:
// St6vectorIiSaIiEE
```

Глаза захотят покинуть чат после того, как увидят эту надпись. 
Вот здесь как раз наша остановочка. Хочется, чтобы шаблон нормально выводил тип вектора интов. И нужно как-то подкрутить шаблон так, чтобы для этого конкретного типа выводилась красивая надпись. 

Для таких целей существует **полная специализация шаблонов функций**. Она используется для изменения реализации шаблона для конкретного фиксированного типа данных: 

```cpp
template<>
std::string getTypeName<std::vector<int>>(const std::vector<int>&){
    return "std::vector of int";
}
```

Чтобы определить полную специализацию шаблона функции нужно:
- убрать все из треугольных скобок возле ключевого слова template. Тем самым мы даем понять компилятору, что это полная специализация существующего шаблона.
- После имени функции указать в треугольных скобках тип, для которого мы хотим специализировать шаблон.
- В аргументах функции вместо имени шаблонного параметра поставить конкретный тип, для которого мы хотим специализировать шаблон. При этом **сигнатура специализации должна полностью повторять сигнатуру шаблона с точностью до замены шаблонного типа Т на выбранный конкретный тип.**

Если по типу параметров функции можно вывести шаблонный тип внутри треугольных скобок, то их можно не указывать:

```cpp
template<>
std::string getTypeName(const std::vector<int>&){
    return "std::vector of int";
}
// компилятор сможет на основе типа const std::vector<int>& вывести шаблонный параметр Т = std::vector<T>

// Также вы можете добавлять сколько угодно новых специализаций:

template<>
std::string getTypeName(const std::vector<std::string>&){
    return "std::vector of std::string";
}

template<>
std::string getTypeName(const std::unordered_map<std::string, std::string>&){
    return "std::unordered_map with std::string key type and std::string value type";
}
```

#### Перегрузка шаблонных функций

Второй способ изменить поведение шаблона. Также, как обычные функции, шаблоны функции можно перегружать. И теперь вы не ограничены сохранением той же сигнатуры. Как и в перегрузках функций, в перегрузках шаблонов может быть любой набор аргументов и шаблонных параметров.

По прошлым примерам вы уже могли заметить, что нам нужно для каждого конкретного типа делать свою специализацию. Это опять же может привести к дублированию кода. Давайте посмотрим, как с помощью перегрузки шаблонной функции можно решить эту проблему.

Скажем, мы хотим красиво выводить типы семейства указателей. Мы можем перегрузить шаблон функции так, чтобы он принимал только указатели, и добавить еще несколько нешаблонных перегрузок для конкретных типов:

```cpp
template<typename T>
	std::string getTypeName(T * pointer){
	return "pointer of " + getTypeName(T{});
}

std::string getTypeName(int num){
	return "int";
}

std::string getTypeName(float num){
	return "float";
}

int num1= 0;
float num2 = 0;
std::println(getTypeName(&num1));
std::println(getTypeName(&num2));
// OUTPUT:
// pointer of int
// pointer of float
```

Обратите внимание, что сейчас разделены ответственности перегрузок: только одна из них отвечает за обработку указателей, а остальные сконцентрированы на своих типах. Если мы захотим изменить логику обработки указателей, то нам нужно поменять всего одну функцию:

```cpp
template<typename T>
std::string getTypeName(T * pointer){
	if (pointer)
		return "pointer of " + getTypeName(T{});
	else 
		return "null pointer of " + getTypeName(T{});
}

std::string getTypeName(int num){
	return "int";
}

std::string getTypeName(float num){
	return "float";
}
```

Как мы видим, перегрузка шаблонных функций позволяет намного гибче изменять функциональность шаблонов функций.

[CppCoreGuideLines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#t144-dont-specialize-function-templates) говорит нам, что стоит предпочитать перегрузку шаблонных функций полной специализации. Но не только по причине гибкости. Давайте посмотрим на пример:

```cpp
template<typename T>            // (1): основной шаблон
std::string getTypeName1(T){
    return "unknown";
}

template<typename T>            // (2): перегрузка
std::string getTypeName1(T*){
    return "pointer";
}

template<>                      // (3): полная специализация (2)
std::string getTypeName1(int*){
    return "int pointer";
}

template<typename T>            // (4): основной шаблон
std::string getTypeName2(T){
    return "unknown";
}

template<>                      // (5): полная специализация (4)
std::string getTypeName2(int*){
    return "int pointer";
}

template<typename T>            // (6) перегрузка
std::string getTypeName2(T*){
    return "pointer";
}

int num= 0;
std::println("getTypeName1: {}", getTypeName1(&num));
std::println("getTypeName2: {}", getTypeName2(&num));

// OUTPUT:
// getTypeName1: int pointer
// getTypeName2: pointer
```

Мы определили 2 семейства функци: getTypeName1 и getTypeName2. Обратите внимание: они реализованы абсолютно одинаково, только изменен порядок определения вариантов функций. И, неожиданно, на один и тот же вход на консоль пишутся разные надписи. Почему так происходит?

### Порядок разрешения перегрузок

Корневая причина в большом разнообразии возможных вариантов, что из себя может представлять функция. Вызов шаблонной функции ничем не отличается от вызова обычной функции. Поэтому компилятору необходимо выбрать правильную реализацию среди:

- перегрузок обычных функций
- шаблонов функций
- перегрузок шаблонов функций
- полных специализаций шаблонов функций

То есть разрешить перегрузки. Соотвественно нужен какой-то алгоритм, который позволит сопоставить вызов функции с определенным набором аргументов и конкретную реализацию функции.

Последовательность приоритетов при выборе подходящей перегрузки такова:

1. Обычные функции с идеальным совпадение типов аргументов при вызове типам параметров.
2. Шаблоны функции:
2.1. Шаблоны с меньшим количеством шаблонных параметров
2.2. Шаблоны с наиболее уточненными аргументами
2.3 Шаблоны общего вида
1. Обычные функции, к параметрам которых можно привести типы аргументов при вызове с использованием стандартных и пользовательских преобразований.

Заметьте, что в этой последовательности нет специализации шаблонных функций! Они не участвуют в разрешении перегрузок. 

Только после того, как компилятор выбрал наиболее подходящую перегрузку шаблона функции, он начинает рассматривать его полные специализации на предмет соответствия параметров.

Именно поэтому все пошло не по плану в нашем последнем примере. Для обеих перегрузок getTypeName1 и getTypeName2 компилятор выбрал наиболее подходящим шаблоны, который принимают шаблонный указатель, как шаблоны с наиболее уточненными параметрами(Т* - это более точный параметр, чем просто Т). Только у getTypeName1(Т*) есть полная специализация для int*, которая идеально подходит по типу аргумента и которую в итоге и выберет компилятор. А для getTypeName2(Т*) нет никакой специализации и выберется неспециализированный шаблон.

Вывод: если вы считаете, что вам нужна полная специализация шаблонной функции, то подумайте еще раз. Скорее всего вам нужна именно перегрузка шаблона функции в сочетании с обычными, нешаблонными перегрузками. 

#### Заключение

Шаблоны функций в C++ — это мощный инструмент, который позволяет писать обобщенный и типобезопасный код. Они избавляют вас от дублирования кода, делают ваш код более гибким и поддерживаемым. Сегодня вы узнали:

- как решать проблему дублирования кода с помощью шаблонов.
- как правильно определять шаблоны функции.
- какие есть механизмы изменения поведения шаблона для некоторых типов.
- порядок разрешения перегрузок.


Шаблоны могут быть сложными, особенно когда вы начинаете использовать специализацию и перегрузку. Куча правил и еще больше нюансов, которые надо знать. Но не бойтесь экспериментировать! Только так можно стать истинным гуру шаблонов.