class ModelInput;
{
	std::vector<char> Serialize = 0;
	void Deserialize(std::vector<char>& bytes) = 0;
}
class ModelOutput
{
	std::vector<char> Serialize = 0;
	void Deserialize(std::vector<char>& bytes) = 0;
}
enum class ModelType {}; 

class ModelParams
{
	void Upload() = 0;
	ModelType type;
};

struct ExecutableModel
{
    void Infer (const ModelInput& input, ModelOutput& output) = 0;
};

struct Model
{
	void Infer (const ModelInput& input, ModelOutput& output) = 0;
	ModelType type;
};

struct Processor
{
    std::unique_ptr<Model> FindModel (ModelType id);
    void UploadModels(const std::vector<ModelParams> model_files);
};

Как я понимаю, модели загружаются в анклав с помощью метода Processor::UploadModels.  Метод загружает набор моделей, вероятно разных типов. Поэтому предлагаю завести абстрактный класс ModelParams, наследники которого представляют собой параметры моделей конкретного типа и реализуют конкретную логику загрузки модели в анклав, то есть для каждого из них будет свой ecall_load_model_<type>. Они будут принимать разный набор параметров, специфический для каждого типа модели. Далее в анклаве в ecall_load_model_<type>  из параметров функции создаются объекты-наследники класса ExecutableModel, которые смогут делать инференс. Для каждого ecall_load_model_<type> этот наследник будет свой, то есть его тип будет определен на момент компиляции.  Объекты исполняемых моделей кладутся в хэш-таблицу вида std::unordered_map<ModelType, ExecutableModel>.
Дальше нужно только выполнить инференс нужной модели. Модель нужного типа определяется перечислением ModelType. Думаю, что число типов моделей не будет очень большим, а значит хранить их в виде строки будет несколько избыточно. И на мой взгляд enum лучше подходит для представления вида какой-то сущности. Метод Processor::FindModel на основе типа модели создает и возвращает адаптер для общения с моделью из анклава - наследник класса Model.
У этого класса чисто виртуальный метод infer, который принимает полиморфные входные и выходные параметры. Наследники Model реализуют конкретную логику инференса модели с помощью конкретных типов параметров. Каждая такая логика подразумевает свой ecall_infer_model_<type>. И в каждом ecall_infer_model_<type> мы знаем какой конкретный тип модели и параметров нужно использовать. Достаем объект из мапы, кастуем его к нужному типу. Создаем объект входных параметров для этого типа модели и десериализуем его из байтов. Создаем объект выходных параметров для этого типа модели . И вызываем метод ExecutableModel::Infer с объектами параметров. В методе ExecutableModel::Infer кастуем параметры к конкретным типам и выполняем логику инференса. После завершения ExecutableModel::Infer десериализуем ModelOutput и отдаем наружу из анклава в метод Model::Infer. Там сериализуем выходной параметр и завершаем обработку.

Преимуществом подхода с использованием полиморфных классов Model, ExecutableModel и ModelParams для каждого типа модели в том, для каждого конкретного типа будет свой ecall, где все типы определены семантикой класса. Это позволяет упростить процесс добавления новой функциональности путем простого добавления новых классов и ecall'ов. А также увеличивает понятность кода, потому что разработчик находится в контексте конкретной функциональности, а не обобщений. Изменять существующий код для нового типа модели нужно будет в методе FindModel.