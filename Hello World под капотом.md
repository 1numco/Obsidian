Славная традиция писать программу по выводу Hello World! самой первой при изучении языка. Я так не делал, но понимаю, что это прикольный артефакт мира программирования. Как выглядит эта программа на языке С++:

#include "stdio.h"
int main() {
	printf("Hello World!");
}

Да, это скорее С, но я так намеренно сделал. Да и в конце-концов, компилировал я g++'ом поэтому это С++!

Было ли вам когда-нибудь интересно, какие инструкции ассемблера выполняются для этой программы? Думаю, что такого никогда не происходило) Но надеюсь, вы заинтересовались достаточно, чтобы такие мысли появились. Поэтому продолжу.

Компилируем это дело с флагом -S и получаем asm. Я прикрепил его картинкой, чтобы не занимать место текста, поэтому буду ссылаться на код из картинки. И построчно объяснять, что там таки происходит.

.line "main.cpp"  - эта строчка говорит о том, что следующие следующий код принадлежит файлу с названием main.cpp

.text - директива, указывающая, что дальше пойдут исполняемые инструкции.

.section .rodata  - директива, указывая, что следующая секция содержит данные, доступные только для чтения. Дальше пойдет определение строковой константы, которые, как мы знаем недоступны для изменения. Собственно, поэтому здесь эта директива

.LC0:  - определяем метку которая указывает на ...

.string "Hello World!"  - строковую константу.

.text  - не буду повторяться.

.globl main  - определяется глобальный символ с именем main, который является входной точкой в программу.

.type main, @function  - определяется тип символа - функция.

main:  метка, указывающая, что отсюда начинается код функции main.

.LFB0:  - метка для внутреннего использования. Иногда для исполнения нужны такие метки, разделяющие функцию на блоки. Если кто-то знает более глубоко, зачем она нужна - напишите к комменты)

pushq %rbp - инструкция сохраняет значение регистра rbp на стек, чтобы после выполнения функции его можно было восстановить.

movq %rsp, %rbp" - загружаем значение стек поинтера в rbp, для того чтобы добавить новый фрейм на стек. Благодаря этим двум инструкциям растет стек заходе в функцию.

leaq .LC0(%rip), %rdi - загружаем эффективный адрес нашей строки по метке в регистр rdi, который будем аргументом для следующей функции. Упоминание rip нужно для вычисления абсолютного адреса строки относительно указателя на инструкцию.

call printf@PLT - вызываем функцию printf, реализация которой находится внутри разделяемой библиотеки libc. Именно для этой строчки и были посты про PLT и GOT тут, тут и тут. Теперь мы понимаем, как на самом деле происходит вызов функций из шареных библиотек и каким образом проблема неизвестности адресов решается в рантайме.

popq %rbp - восстанавливаем предыдущее значение rbp из сохраненного значения на стеке. Таким образом как бы удаляем фрейм, на котором выполняли функцию main.

ret - возвращаем контроль к вызывающей функции. Эта инструкция поднимает возвращаемый адрес со стека и выполнение продолжается с этого адреса. Дальше ищут какие-то подготовительные мероприятия по завершению программы.

Я опустил в коде некоторые моменты и инструкции, которые были сгенерированы компилятором для каких-то малозначимых и малопонятных целей. Тут самый смак и выжимка, только то, что и нужно понимать.

Не знаю, как вам, но мне нравится иногда смотреть в ассемблер(особенно в такой простой) и разбираться в базовых вещах, как и что работает под капотом. Пост получился довольно объемный, но на мой взгляд интересный)

Stay hardwared. Stay cool.

![[Pasted image 20231219104955.png]]