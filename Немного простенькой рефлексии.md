Представим себе ситуацию, когда у нас большой и сложный шаблонный код(думаю, что все легко представят). Используя какой-то шаблонный класс, мы получаем не совсем то поведение, которое ожидаем от него. И грешим на тот тип, с которым он инстанцирован. Однако мы не понимаем, какой это тип на самом деле. А очень хотелось бы понять, чтобы выяснить природу неожиданного поведения. Что делать в таком случае? Рефлексии в плюсах-то с гулькин нос.

Хочется это все еще делать в compile-time. Мне кажется очень правильным принцип, что если что-то можно вычислить во время компиляции, то это нужно делать именно в это время. Не к чему нагружать приложение ненужными операциями в рантайме.

И тут на помощь приходит макрос из расширения gcc, называется \_\_PRETTY\_FUNCTION\_\_. Этот макрос содержит в себе всю сигнатуру функции, в которой он вызывается. Включая шаблонные параметры. 

Ну и еще немного упрощает жизнь использование функции std::char\_traits<char>::length, которая начиная с С++17 стала constexpr. Она позволяет вычислить длину строки и делает она это теперь как раз в compile-time

Что нужно сделать, так это всего-на-всего вырезать из сигнатуры ненужные нам куски и оставить только тот тип, с которым шаблонный класс инстанцирован. А std::char\_traits<char>::length используется просто для удобного подсчета длины кусков, которые мы хотим вырезать.

То, что получилось, можете увидеть на картинке под постом. Вряд ли это какой-то продакшен вариант, потому что это и не стандартный с++ и работает в обход одного варнинга. Но все равно интересно, что такие штуки можно делать.

Если вам есть, что добавить или возразить по поводу кода, велком в комменты)

Stay cool.
