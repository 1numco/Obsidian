В этом посте мы познакомились с Remove-Erase Idiom. Я специально там не объяснял, как она конкретно работает. Точнее объяснял, но только идейно, совсем не вдаваясь в детали. Сегодня закроем этот пробел.

Немного ревизии для тех, кто не хочет читать прошлый пост. Удалить из вектора элементы по значению или подходящие под какой-то шаблон не получится напрямую через API вектора. Есть проблемы с копированием. 

Хорошо. Лезем в cpp-reference и находим там алгоритмы std::remove и std:remove_if. Они принимают рендж начало-конец, ищут там конкретное значение или проверяют предикат на верность и удяляют найденные элементы. Вот что там написано про сложность:
Given `N` as std::distance(first, last)

1,2) exactly `N` comparisons with value using `operator==`.

3,4) exactly `N` applications of the predicate p.

Сложность удаления найденных элементов - линейная. Ну отлично. Хуяк и в рабочий код. Тесты валятся, код работает не так как ожидалось. После этого алгоритма на самом деле ничего не удалилось. Элементов столько же, только они в другом порядке. Почему?

Дело в том, что каждый раз, когда std::remove находит нужную ячейку, он свопает ее содержимое с последней ячейкой массива, в которую еще не перемещали найденный элемент. Проделывает так со всем массивом и возвращает итератор на самый первый удаленный элемент вектора. То есть все, что слева итератора - отфильтрованные элементы. Все, что справа - типа "удаленные".

И это хорошо, потому что теперь мы можем действительно удалить эти элементы. Причем все разом. Делается это через метод вектора erase. Если erase очищает рэндж и этот рендж заканчивается последним элементом, то никаких копирований не происходит. Поэтому получается такая каша:

myVec.erase(std::remove(myVec.begin(), myVec.end(), value), myVec.end());

Собственно, когда эти 2 алгоритма применяются в одной строчке, можно наглядно увидеть причину названия идиомы.

Да, это выглядит не очень солидно, но имеем, что имеем. Хотя в 20-х плюсах эта ситуация изменилась, как-нибудь расскажу про это.

Так что не надо городить кастомных методов, которые решаю эту задачу. Применяйте готовые и общепринятые решения. И код быстрее и поймут вас быстрее и проще.

Stay clear. Stay cool.