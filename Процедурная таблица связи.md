Понимание того, как на самом деле вызываются функции, является неотъемлемой частью работы программиста. Особенно плюсовика. Потому что работаем в том числе на низком уровне, когда все вот эти тонкости играют роль. Это например может быть важно при выборе способа линковки библиотеки - динамического и статического. Потому что оба способа каким-то образом аффектят нашу систему, посредством затрат памяти и перформанса. И важно понимать, какие ограниченич есть и что выборать, исходя из этих ограничений. Сегодня поговорим про один из механизмов вызова функций из динамических библиотек.

Процедурная таблица связи (Procedure Linkage Table, PLT) - это эффективный механизм, применяемый в системах с динамической компоновкой для вызова функций из разделяемых библиотек. Когда ты вызываешь функцию из такой библиотеки, компилятор не знает точный адрес этой функции на этапе компиляции, поэтому он создаёт вызов через таблицу связи - PLT.

Вот представь себе. Пишешь ты код, и вызываешь функцию из библиотеки. Например printf. C library, которая содержит printf, линкуется динамически. Это уменьшает размер бинаря, потому что информация из библиотеки там просто не содержится.Но есть проблема – компилятор не знает точный адрес этой функции на этапе компиляции. Мало того, адреса динамической библиотеки в виртуальной памяти процесса могут меняться от запуска к запуску. На это есть разные причины, но не суть. Вот здесь-то наш герой, PLT, и выходит на сцену!

PLT состоит из набора "трамплиновых заглушек" (trampoline stubs), которые выполняются при первом вызове функции. Эти заглушки включают в себя небольшой блок кода, который вызывает динамический загрузчик для разрешения адреса вызываемой функции. PLT - это своего рода посредник между твоим кодом и функцией в библиотеке. 

Когда функция вызывается впервые, то есть когда она проходит через PLT, заглушка PLT вызывает функцию "lazy resolver" (ленивый разрешитель). Ленивый разрешитель обращается к динамическому загрузчику и запрашивает точный адрес функции в соответствующей разделяемой библиотеке. Затем этот адрес сохраняется в PLT, чтобы последующие вызовы функции могли обойти этот этап разрешения и перейти непосредственно к функции.

Если функция уже была вызвана ранее, то адрес функции уже известен, и PLT переходит прямо к этому адресу без задержек. Это позволяет избежать накладных расходов, связанных с повторным разрешением адреса.

Одно из главных преимуществ использования PLT заключается в ленивой загрузке библиотеки. То есть библиотека загружается только по мере необходимости, при первом вызове функции. Это позволяет сократить время запуска программы и сэкономить память, так как не все функции из библиотеки обязательно используются.

Конечно, это не единственный механизм вызова функций из разделяемых библиотек. Однако теперь вы имеете представление о том, как это в принципе может работать.

И да, конечно разговор про PLT не может обойтись без упоминания GOT или Global Offset Table. Именно эти две сущности в связке и позволяют разрешать адреса функций. В этом посте я изолированно рассказал про PLT, опуская и связи с GOT. Полную картину дам в следующих постах.

Хочу узнать, нравится ли вам такой низкоуровневый контент? Или нахрен вам все это и лучше рассказывать про плюсы? Поделитесь своим мнением в комментариях.

Stay based. Stay cool.
![[Pasted image 20231216220611.png]]