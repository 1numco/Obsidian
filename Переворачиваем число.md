Сегодня у нас будет задачка. Формулируется просто - дано 32-битное целое число x. Верните число, десятичные цифры которого стоят в обратном порядке относительно числа x. Если будет переполнение, верните 0.

Решение, в целом, довольно очевидное. И скорее это задача для братьев наших меньших, кто еще не достиг дзена плюсового(ну хотя бы 20% от него). Однако здесь очень много нюансов, на которых вы можете споткнуться. Именно в этом и "сложность" задачи и ее польза. Поэтому нужно очень тщательно тестировать решение, чтобы оно было действительно корректным.

Но без одного уточнения решение будет совсем легким. Нельзя использовать переменные, которые занимают больше 4-х байтов в памяти.

Также у меня появились мысли по формату публикаций задач на канале. Под постом с непосредственно задачей будут идти обсуждения для тех, кто не очень понимает, в правильную ли сторону он мыслит, и хочет обсудит обсудить "большие штрихи" в решении.

Далее я буду отправлять следом за задачей еще один пост, в котором люди могут присылать свои решения на всеобщее ревью. Разделение нужно, чтобы собственно отделить сомневающихся и уже разобравшихся с деталями.

Ответ будет публиковаться вечером в комментах к еще одному посту. Это предотвратит явное появление ответа в ленте для тех, кто присоединится к каналу позже, и возможно тоже захочет порешать без спойлеров.

Погнали решать)

Challenge your problems. Stay cool.

#задачки

тред для ревью ваших решений

![[Pasted image 20240312113003.png]]


Решение задачи с переворачиванием числа.

Для начала разберемся, почему появилось ограничение на использование 64-битных переменных. Берем самый очевидный подход - создаем int64_t переменную результат, заводим цикл, где домножаем результат на 10 и прибавляем к нему остаток от деления икса на 10. После этого делим х на 10 целочисленно и продолжаем цикл пока х ненулевой.

И кстати да, вдруг кто не осознавал. Остаток деления отрицательного числа будет отрицательным числом. Иногда это знание спасает людей от лишних манипуляций со знаковым битом. 

И единственное, что остается сделать - проверить выходит ли полученный результат за границы инта: если да, вернуть ноль, если нет, вернуть результат.

Суперпросто и думать почти не надо.

Но все несколько осложняется, если мы не можем использовать 64-битные переменные. Значит нам нужно налету проверять, может ли произойти переполнение на следующем шаге переноса циферки. Как определить, что вот вот произойдет переполнение?

Формула у нас такая: result = result \* 10 + x % 10; 

Если result будет меньше, чем INT_MAX / 10 или больше, чем INT_MIN / 10, то будет все ок. Но вот если какое-то из этих условий не выполнится, то на следующей итерации произойдет переполнение и нужно вернуть ноль. Почему тут просто целочисленное деление без упоминания цифр числа? Потому что переполнение может произойти по факту только на последней итерации цикла, когда у нас 10 десятичных цифр в числе. Буду разбирать для положительных чисел. То есть от 1'000'000'000 до 2'147'483'647. INT_MAX / 10 будет давать нам 7 в запасе к последней итерации цикла. То есть если мы добавим цифру, меньшую 7-ми, то we are good. А учитывая, что для нашего "опасного" рэнджа чисел последняя цифра либо 1, либо 2, то и беспокоится нам не о чем.

Если вам удобно работать только с положительными числами, то можно выделить знаковый бит из х. Если х отрицательный, то домножаем его на -1 и оперируем с ним, как с положительным числом. В конце просто домножим результат на -1 и все встанет на свои места. Этот вариант решения похуже, нужны дополнительные действия. Но концепция решения та же.

Хотел прикрепить решение, но наш подписчик https://t.me/artyomka_tlt представил очень хороший вариант, поэтому я буду отсылаться на его коммент https://t.me/c/2009887601/1977. 

Solve your problems. Stay cool.
